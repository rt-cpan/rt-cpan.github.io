<!DOCTYPE html>

<html lang="en">
  <head>
    <title>Bug #83595 for CAD-Format-STL: Tiny fatal bug in Windows</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <!-- The X-UA-Compatible <meta> tag above must be very early in <head> -->

    <script>
if (window.top !== window.self) {
    document.write = "";

    window.top.location = window.self.location;

    setTimeout(function(){
        document.body.innerHTML = "";
    }, 1);

    window.self.onload = function(){
        document.body.innerHTML = "";
    };
}
</script>



<link rel="shortcut icon" href="/NoAuth/images/favicon.png" type="image/png" />
<link rel="stylesheet" href="/NoAuth/css/aileron-squished-00f758259152f8b6670ee485f462e6b8.css" type="text/css" media="all" />
<link rel="stylesheet" href="/NoAuth/css/print.css" type="text/css" media="print" />




<script type="text/javascript" src="/NoAuth/js/squished-42167f2409ce368da2d31038e5cb2a57.js"></script>

<script type="text/javascript"><!--
	jQuery( loadTitleBoxStates );

--></script>


<!--[if lt IE 8]>
<link rel="stylesheet" href="/NoAuth/css/aileron/msie.css" type="text/css" media="all" />
<![endif]-->
<!--[if lt IE 7]>
<link rel="stylesheet" href="/NoAuth/css/aileron/msie6.css" type="text/css" media="all" />
<![endif]-->
<script type="text/javascript">
jQuery(document).ready(function(){
    jQuery.fn.supersubs.defaults = {
        maxWidth: 30,
        extraWidth: 2
    };

    jQuery("#app-nav.toplevel").addClass('sf-menu sf-js-enabled sf-shadow').supersubs().superfish({ speed: 'fast' });
    jQuery("#page-menu.toplevel").addClass('sf-menu sf-js-enabled').supersubs().superfish({ dropShadows: false, speed: 'fast' }).supposition();
});
</script>


<!-- Site CSS from theme editor -->
<style type="text/css" media="all" id="sitecss">
</style>

<meta name="google-site-verification" content="kD3-uEJK1AkTqaC-rckcSt_HPkAj674DPPuEN6i-y0g" />

</head>
  <body class="aileron sidebyside" id="comp-Public-Bug-Display">

<div id="logo">
<a href="/"><img
    src="/NoAuth/images/cpan.png"
    alt="CPAN"
    width="181"
    height="38" /></a>
    <span class="rtname">RT for rt.cpan.org</span>
</div>


<div id="quickbar">
  <div id="quick-personal">
    <span class="hide"><a href="#skipnav">Skip Menu</a> | </span>
</div>

</div>
<div id="header"><h1>Bug #83595 for CAD-Format-STL: Tiny fatal bug in Windows</h1></div>



<div id="page-navigation"><ul id="page-menu" class="toplevel">
 <li id="li-page-active_bugs"><a id="page-active_bugs" class="menu-item " href="/Public/Dist/CAD-Format-STL/Active/">Active bugs</a></li>
 <li id="li-page-resolved_bugs"><a id="page-resolved_bugs" class="menu-item " href="/Public/Dist/CAD-Format-STL/Resolved/">Resolved bugs</a></li>
 <li id="li-page-rejected_bugs"><a id="page-rejected_bugs" class="menu-item " href="/Public/Dist/CAD-Format-STL/Rejected/">Rejected bugs</a></li>
 <li id="li-page-report"><a id="page-report" class="menu-item " href="/Public/Dist/CAD-Format-STL/Active/"></a></li>
</ul></div>
<div id="topactions">



</div>
<div id="body">


<a name="skipnav" id="skipnav" accesskey="8"></a>





<p>This queue is for tickets about the <a href="https://metacpan.org/release/CAD-Format-STL">CAD-Format-STL CPAN distribution</a>.</p>





<div class="">
  <div class="titlebox" id="">
  <div class="titlebox-title">
    <span class="widget"><a href="#" onclick="return rollup('TitleBox\x2D\x2D\x5FPublic\x5FBug\x5FDisplay\x5Fhtml\x2D\x2D\x2D\x2D\x2D\x2DUmVwb3J0IGluZm9ybWF0aW9u\x2D\x2D\x2D0');" title="Toggle visibility"></a></span>
    <span class="left">Report information</span>
    <span class="right-empty">		    </span>
  </div>
  <div class="titlebox-content " id="TitleBox--_Public_Bug_Display_html------UmVwb3J0IGluZm9ybWF0aW9u---0">


<table width="100%" class="ticket-summary">
<tr>
  <td valign="top" class="boxcontainer">
    <div class="ticket-info-basics">
  <div class="titlebox ticket-info-basics " id="">
  <div class="titlebox-title">
    <span class="widget"><a href="#" onclick="return rollup('TitleBox\x2D\x2D\x5FPublic\x5FBug\x5FDisplay\x5Fhtml\x2D\x2Dticket\x2Dinfo\x2Dbasics\x2D\x2D\x2D\x2DVGhlIEJhc2ljcw\x5F\x5F\x2D\x2D\x2D0');" title="Toggle visibility"></a></span>
    <span class="left">The Basics</span>
    <span class="right-empty">		    </span>
  </div>
  <div class="titlebox-content " id="TitleBox--_Public_Bug_Display_html--ticket-info-basics----VGhlIEJhc2ljcw__---0">


        <table>
  <tr class="id">
    <td class="label">Id:</td>
    <td class="value">83595</td>
  </tr>
  <tr class="status">
    <td class="label">Status:</td>
    <td class="value">new</td>
  </tr>
  <tr class="priority">
    <td class="label">Priority:</td>
    <td class="value">0/
</td>
  </tr>
  <tr class="queue">
    <td class="label">Queue:</td>
    <td class="value"><a href="/Public/Dist/CAD-Format-STL/Active/">CAD-Format-STL</a>
</td>
  </tr>
</table>

        <hr class="clear" />
  </div>
</div>




</div>


    <div class="ticket-info-people">
  <div class="titlebox ticket-info-people " id="">
  <div class="titlebox-title">
    <span class="widget"><a href="#" onclick="return rollup('TitleBox\x2D\x2D\x5FPublic\x5FBug\x5FDisplay\x5Fhtml\x2D\x2Dticket\x2Dinfo\x2Dpeople\x2D\x2D\x2D\x2DUGVvcGxl\x2D\x2D\x2D0');" title="Toggle visibility"></a></span>
    <span class="left">People</span>
    <span class="right-empty">		    </span>
  </div>
  <div class="titlebox-content " id="TitleBox--_Public_Bug_Display_html--ticket-info-people----UGVvcGxl---0">


        <table>
  <tr>
    <td class="label">Owner:</td>
    <td class="value">Nobody in particular
    
    </td>
  </tr>
  <tr>
    <td class="labeltop">Requestors:</td>
    <td class="value">
b [...] bathsheba.com

<br />

</td>
  </tr>
  <tr>
    <td class="labeltop">Cc:</td>
    <td class="value">

</td>
  </tr>
  <tr>
    <td class="labeltop">AdminCc:</td>
    <td class="value">

</td>
  </tr>
</table>

        <hr class="clear" />
  </div>
</div>




</div>



  </td>
  <td valign="top" class="boxcontainer">
    
    <div class="ticket-info-cfs">
  <div class="titlebox ticket-info-cfs " id="">
  <div class="titlebox-title">
    <span class="widget"><a href="#" onclick="return rollup('TitleBox\x2D\x2D\x5FPublic\x5FBug\x5FDisplay\x5Fhtml\x2D\x2Dticket\x2Dinfo\x2Dcfs\x2D\x2D\x2D\x2DQnVnIEluZm9ybWF0aW9u\x2D\x2D\x2D0');" title="Toggle visibility"></a></span>
    <span class="left">Bug Information</span>
    <span class="right-empty">		    </span>
  </div>
  <div class="titlebox-content " id="TitleBox--_Public_Bug_Display_html--ticket-info-cfs----QnVnIEluZm9ybWF0aW9u---0">

 
        <table>
  <tr id="CF-1-ShowRow">
    <td class="label">Severity:</td>
    <td class="value">
Critical    </td>
  </tr>
  <tr id="CF-224206-ShowRow">
    <td class="label">Broken in:</td>
    <td class="value">
v0.2.1    </td>
  </tr>
  <tr id="CF-224207-ShowRow">
    <td class="label">Fixed in:</td>
    <td class="value">
<i>(no value)</i>
    </td>
  </tr>
</table>


        <hr class="clear" />
  </div>
</div>




</div>


    <div class="ticket-info-attachments">
  <div class="titlebox ticket-info-attachments " id="">
  <div class="titlebox-title inverse">
    <span class="widget"><a href="#" onclick="return rollup('TitleBox\x2D\x2D\x5FPublic\x5FBug\x5FDisplay\x5Fhtml\x2D\x2Dticket\x2Dinfo\x2Dattachments\x2D\x2D\x2D\x2DQXR0YWNobWVudHM\x5F\x2D\x2D\x2D0');" title="Toggle visibility"></a></span>
    <span class="left">Attachments</span>
    <span class="right-empty">		    </span>
  </div>
  <div class="titlebox-content " id="TitleBox--_Public_Bug_Display_html--ticket-info-attachments----QXR0YWNobWVudHM_---0">




onetri.stl<br />
<ul>


<li><font size="-2">
<a href="/Ticket/Attachment/1184972/625117/onetri.stl">
Sun Feb 24 08:30:07 2013 (184b) by b [...] bathsheba.com
</a>
</font></li>
</ul>


STL.pm<br />
<ul>


<li><font size="-2">
<a href="/Ticket/Attachment/1184979/625126/STL.pm">
Sun Feb 24 08:59:24 2013 (11.4k) by b [...] bathsheba.com
</a>
</font></li>


<li><font size="-2">
<a href="/Ticket/Attachment/1184972/625116/STL.pm">
Sun Feb 24 08:30:07 2013 (11.4k) by b [...] bathsheba.com
</a>
</font></li>
</ul>

    <hr class="clear" />
  </div>
</div>




</div>







  </td>
</tr>
</table>

    <hr class="clear" />
  </div>
</div>




</div>


<br />


<div class="history">
<div class="titlebox" id="">
  <div class="titlebox-title">
    <span class="widget"><a href="#" onclick="return rollup('TitleBox\x2D\x2D\x5FPublic\x5FBug\x5FDisplay\x5Fhtml\x2D\x2D\x2D\x2D\x2D\x2DSGlzdG9yeQ\x5F\x5F\x2D\x2D\x2D0');" title="Toggle visibility"></a></span>
    <span class="left">History</span>
    <span class="right">		<a href="#" data-direction="open" onclick="return toggle_all_folds(this, 'Show\x20all\x20quoted\x20text', 'Hide\x20all\x20quoted\x20text');">Show all quoted text</a>    </span>
  </div>
  <div class="titlebox-content " id="TitleBox--_Public_Bug_Display_html------SGlzdG9yeQ__---0">


<div id="ticket-history">
<div class="ticket-transaction message Create odd">
<div class="ticket-transaction">
  <div class="metadata">
    <span class="type">
      &nbsp;      
    </span>
    <span class="date">Sun&nbsp;Feb&nbsp;24&nbsp;08:30:07&nbsp;2013</span>
    <span class="description">b [...] bathsheba.com -  Ticket created</span>
    <span class="time-taken"></span>    <span class="actions hidden"></span>
  </div>
    <div class="content">
      
<table>
  <tr>
    <td align="right" class="message-header-key">Subject:</td>
    <td class="message-header-value"> Tiny fatal bug in Windows</td>
  </tr>
</table>
<div class="messageattachments">

<div class="messagebody">
<div class="message-stanza plain-text-white-space">Thanks for writing this module!  

I was using it in Windows 7 with ActivePerl to import a lot of STL
files, and I saw it fail intermittently with binary format.  I tracked
this down and found that when bytes 0x0D, i.e. a carriage return, occur
in such a file, it fails.  Drops the character, reads a lot of gibberish
numbers, and eventually fails with an unexpected EOF.  Attached is a
small STL, 2 triangles, that shows this behavior.

I think it&#39;s because the perl read function is, in systems that
distinguish binary from text files, a text read: it strips carriage
returns.  Unfortunately Windows is such a system.  

I found that by calling binmode on the file handle, this is fixed. 
In STL.pm at line 348 I inserted &#39;binmode $fh;&#39;.  Attached is this file
with that change.

This is probably not the right place to add that, because it could fail
earlier during format detection.  But I didn&#39;t understand that part very
well and I only need to read binary files, so this is the best I could
do right now.

I&#39;m not a developer and don&#39;t feel up to putting a patch on CPAN,
especially when I don&#39;t think it&#39;s quite right.  But it would be awesome
if this got fixed properly.

Thanks for your consideration!
</div></div>
<table>
  <tr>
    <td align="right" class="message-header-key">Subject:</td>
    <td class="message-header-value"> STL.pm</td>
  </tr>
</table>

<div class="messagebody">
<div class="message-stanza plain-text-white-space">package CAD::Format::STL;
$VERSION = v0.2.1;

use warnings;
use strict;
use Carp;

use CAD::Format::STL::part;

=head1 NAME

CAD::Format::STL - read/write 3D stereolithography files

=head1 SYNOPSIS

Reading:

  my $stl = CAD::Format::STL-&gt;new-&gt;load&#40;&#34;foo.stl&#34;&#41;;
  # what about the part/multipart?
  my @facets = $stl-&gt;part-&gt;facets;

Writing:

  my $stl = CAD::Format::STL-&gt;new;
  my $part = $stl-&gt;add_part&#40;&#34;my part&#34;&#41;;
  $part-&gt;add_facets&#40;@faces&#41;;
  $stl-&gt;save&#40;&#34;foo.stl&#34;&#41;;
  # or $stl-&gt;save&#40;binary =&gt; &#34;foo.stl&#34;&#41;;

Streaming read/write:

  my $reader = CAD::Format::STL-&gt;reader&#40;&#34;foo.stl&#34;&#41;;
  my $writer = CAD::Format::STL-&gt;writer&#40;binary =&gt; &#34;bar.stl&#34;&#41;;
  while&#40;my $part = $reader-&gt;next_part&#41; {
    my $part_name = $part-&gt;name;
    $writer-&gt;start_solid&#40;$part_name&#41;;
    while&#40;my @data = $part-&gt;facet&#41; {
      my &#40;$normal, @vertices&#41; = @data;
      my @v1 = @{$vertices[0]};
      my @v2 = @{$vertices[0]};
      my @v3 = @{$vertices[0]};
      # that&#39;s just for illustration
      $writer-&gt;facet&#40;\@v1, \@v2, \@v3&#41;;
      # note the omitted normal
    }
    $writer-&gt;end_solid;
  }

=begin design

The reader auto-detects whether it is binary &#40;but assumes ascii when
seek can&#39;t go backwards.&#41;

The reader and writer both take 1, 2, or {1,2}+2n arguments.

This package and/or the reader/writer are subclassable &#40;though getting
$self-&gt;reader to instantiate a subclass implies that you have subclassed
$self.&#41;

A cached_facet &#40;or raw_facet&#41; method is necessary to ensure uniform
tranformation of shared points &#40;and optimize the computation.&#41;  This
would return the normal and points as a list of scalars rather than
arrays, with a later call to unpack_point&#40;&#41; or something.  The caller
needs to be able to handle the caching &#40;or else there is a callback for
non-cached &#40;or an override for unpack_point&#40;&#41;.&#41;

Maybe $self-&gt;set_writer&#40;&#41; and set_reader&#40;&#41; immutable object methods?

=end design

=head1 ABOUT

This module provides object-oriented methods to read and write the STL
&#40;Stereo Lithography&#41; file format in both binary and ASCII forms.  The
STL format is a simple set of 3D triangles.

=cut

use Class::Accessor::Classy;
lo &#39;parts&#39;;
no  Class::Accessor::Classy;

=head1 Constructor

=head2 new

  my $stl = CAD::Format::STL-&gt;new;

=cut

sub new {
  my $package = shift;
  my $class = ref&#40;$package&#41; || $package;
  my $self = {parts =&gt; []};
  bless&#40;$self, $class&#41;;
  return&#40;$self&#41;;
} # end subroutine new definition
########################################################################

=head2 add_part

Create a new part in the stl.

  my $part = $stl-&gt;add_part&#40;&#34;name&#34;&#41;;

Optionally, add the faces directly:

  my $part = $stl-&gt;add_part&#40;&#34;name&#34;, @faces&#41;;

=cut

sub add_part {
  my $self = shift;
  my &#40;$name, @faces&#41; = @_;

  my $part = CAD::Format::STL::part-&gt;new&#40;$name, @faces&#41;;
  push&#40;@{$self-&gt;{parts}}, $part&#41;;
  return&#40;$part&#41;;
} # end subroutine add_part definition
########################################################################

=head2 part

Get the part at $index.  Negative indices are valid.

  my $part = $stl-&gt;part&#40;$index&#41;;

Throws an error if there is no such part.

=cut

sub part {
  my $self = shift;
  my &#40;$index&#41; = @_;

  @{$self-&gt;{parts}} or croak&#40;&#34;file has no parts&#34;&#41;;

  $index ||= 0;
  exists&#40;$self-&gt;{parts}[$index]&#41; or croak&#40;&#34;no part $index&#34;&#41;;
  return&#40;$self-&gt;{parts}[$index]&#41;;
} # end subroutine part definition
########################################################################

=head1 I/O Methods

=head2 load

Load an STL file &#40;auto-detects binary/ascii&#41;

  $stl = $stl-&gt;load&#40;&#34;filename.stl&#34;&#41;;

Optionally, explicitly declare binary mode:

  $stl = $stl-&gt;load&#40;binary =&gt; &#34;filename.stl&#34;&#41;;

The $self object is returned to allow e.g. chaining to C&lt;new&#40;&#41;&gt;.

The filename may also be a filehandle.

=cut

sub load {
  my $self = shift;
  my &#40;$file, @and&#41; = @_;

  my $mode;
  if&#40;@and&#41; {
    &#40;@and &gt; 1&#41; and croak&#40;&#39;too many arguments to load&#40;&#41;&#39;&#41;;
    $mode = $file;
    &#40;$file&#41; = @and;
  }

  # allow filehandle
  unless&#40;&#40;ref&#40;$file&#41; || &#39;&#39;&#41; eq &#39;GLOB&#39;&#41; {
    open&#40;my $fh, &#39;&lt;&#39;, $file&#41; or
      die &#34;cannot open &#39;$file&#39; for reading $!&#34;;
    $file = $fh;
  }

  # detection
  unless&#40;$mode&#41; {
    unless&#40;seek&#40;$file, 0,0&#41;&#41; {
      croak&#40;&#39;must have explicit mode for non-seekable filehandle&#39;&#41;;
    }
    # now, detection...
    $mode = sub {
      my $fh = shift;
      seek&#40;$fh, 80, 0&#41;;
      my $count = eval {
        my $buf; read&#40;$fh, $buf, 4&#41; or die;
        unpack&#40;&#39;L&#39;, $buf&#41;;
      };
      $@ and return &#39;ascii&#39;; # if we hit eof, it can&#39;t be binary
      $count or die &#34;detection failed - no facets?&#34;;
      my $size = &#40;stat&#40;$fh&#41;&#41;[7];
      # calculate the expected file size
      my $expect =
        + 80 # header
        +  4 # count
        + $count * &#40;
          + 4 # normal, pt,pt,pt &#40;vectors&#41;
          * 4 # bytes per value
          * 3 # values per vector
          + 2 # the trailing &#39;short&#39;
        &#41;;
      return &#40;$size == $expect&#41; ? &#39;binary&#39; : &#39;ascii&#39;;
    }-&gt;&#40;$file&#41;;
    seek&#40;$file, 0, 0&#41; or die &#34;cannot reset filehandle&#34;;
  }

  my $method = &#39;_read_&#39; . lc&#40;$mode&#41;;
  $self-&gt;can&#40;$method&#41; or croak&#40;&#34;invalid read mode &#39;$mode&#39;&#34;&#41;;

  $self-&gt;$method&#40;$file&#41;;
  return&#40;$self&#41;;
} # end subroutine load definition
########################################################################

=head2 _read_ascii

  $self-&gt;_read_ascii&#40;$filehandle&#41;;

=cut

sub _read_ascii {
  my $self = shift;
  my &#40;$fh&#41; = @_;

  my $getline = sub {
    while&#40;my $line = &lt;$fh&gt;&#41; {
      $line =~ s/\s*$//; # allow any eol
      length&#40;$line&#41; or next;
      return&#40;$line&#41;;
    }
    return;
  };
  my $p_re = qr/&#40;[^ ]+&#41;\s+&#40;[^ ]+&#41;\s+&#40;[^ ]+&#41;$/;

  my $part;
  while&#40;my $line = $getline-&gt;&#40;&#41;&#41; {

    if&#40;$line =~ m/^\s*solid &#40;.*&#41;/&#41; {
      $part = $self-&gt;add_part&#40;$1&#41;;
    }
    elsif&#40;$line =~ m/^\s*endsolid &#40;.*&#41;/&#41; {
      my $name = $1;
      $part or die &#34;invalid &#39;endsolid&#39; entry with no current part&#34;;
      &#40;$name eq $part-&gt;name&#41; or
        die &#34;end of part &#39;$name&#39; should have been &#39;&#34;,
          $part-&gt;name, &#34;&#39;&#34;;
      $part = undef;
    }
    elsif&#40;$part&#41; {
      my @n = &#40;$line =~ m/^\s*facet\s+normal\s+$p_re/&#41; or
        die &#34;how did that happen? &#40;$line&#41;&#34;;
      #warn &#34;got &#34;, join&#40;&#39;|&#39;, @n&#41;;
      my @facet = &#40;\@n&#41;;

      my $next = $getline-&gt;&#40;&#41;;
      unless&#40;$next and &#40;$next =~ m/^\s*outer\s+loop$/&#41;&#41; {
        die &#34;facet doesn&#39;t start with &#39;outer loop&#39; &#40;$next&#41;&#34;;
      }
      push&#40;@facet, do {
        my @got;
        while&#40;my $line = $getline-&gt;&#40;&#41;&#41; {
          &#40;$line =~ m/^\s*endloop$/&#41; and last;
          if&#40;$line =~ m/^\s*vertex\s+$p_re/&#41; {
            push&#40;@got, [$1, $2, $3]&#41;;
          }
        }
        @got;
      }&#41;;
      &#40;scalar&#40;@facet&#41; == 4&#41; or
        die &#34;need three vertices per facet &#40;not $#facet&#41;&#34;;
      my $end = $getline-&gt;&#40;&#41;;
      &#40;$end and &#40;$end =~ m/^\s*endfacet/&#41;&#41; or
        die &#34;bad endfacet $line&#34;;
      $part-&gt;add_facets&#40;[@facet]&#41;;
    }
    else {
      die &#34;what? &#40;$line&#41;&#34;;
    }
  }
  $part and die &#34;part &#39;&#34;, $part-&gt;name, &#34;&#39; was left open&#34;;
} # end subroutine _read_ascii definition
########################################################################

=head2 get_&lt;something&gt;

These functions are currently only used internally.

=over

=item get_triangle

=item get_ulong

=item get_float32

=item get_short

=back

=cut

sub get_triangle {
  my &#40;$fh&#41; = @_;

  my &#40;$n, $x, $y, $z&#41; = map&#40;{[map&#40;{get_float32&#40;$fh&#41;} 1..3&#41;]} 1..4&#41;;
  my $scrap = get_short&#40;$fh&#41;;
  return&#40;$n, $x, $y, $z&#41;;
}

sub get_ulong {
  my &#40;$fh&#41; = @_;

  my $buf;
  read&#40;$fh, $buf, 4&#41; or warn &#34;EOF?&#34;;
  return&#40;unpack&#40;&#39;L&#39;, $buf&#41;&#41;;
}

sub get_float32 {
  my &#40;$fh&#41; = @_;

  my $buf;
  read&#40;$fh, $buf, 4&#41; or warn &#34;EOF?&#34;;
  return&#40;unpack&#40;&#39;f&#39;, $buf&#41;&#41;;
}

sub get_short {
  my &#40;$fh&#41; = @_;

  my $buf;
  read&#40;$fh, $buf, 2&#41; or warn &#34;EOF?&#34;;
  return&#40;unpack&#40;&#39;S&#39;, $buf&#41;&#41;;
}

=head2 _read_binary

  $self-&gt;_read_binary&#40;$filehandle&#41;;

=cut

sub _read_binary {
  my $self = shift;
  my &#40;$fh&#41; = @_;

  binmode $fh;

  $self-&gt;parts and die &#34;binary STL files must have only one part&#34;;

  die &#34;bigfloat&#34; unless&#40;length&#40;pack&#40;&#34;f&#34;, 1&#41;&#41; == 4&#41;;
  # TODO try to read part name from header &#40;up to \0&#41;
  my $name = &#39;a part&#39;;
  seek&#40;$fh, 80, 0&#41;;

  my $triangles = get_ulong&#40;$fh&#41;;
  my $part = $self-&gt;add_part&#40;$name&#41;;

  my $count = 0;
  while&#40;1&#41; {
    my @tr = get_triangle&#40;$fh&#41;;
    # TODO check that the unit normal is within a thousandth of a radian
    # &#40;0.001 rad is ~0.06deg&#41;
    $part-&gt;add_facets&#40;[@tr]&#41;;
    $count++;
    eof&#40;$fh&#41; and last;
  }
  &#40;$count == $triangles&#41; or
    die &#34;ERROR: got $count facets &#40;expected $triangles&#41;&#34;;
} # end subroutine _read_binary definition
########################################################################

=head2 save

  $stl-&gt;save&#40;&#34;filename.stl&#34;&#41;;

  $stl-&gt;save&#40;binary =&gt; &#34;filename.stl&#34;&#41;;

=cut

sub save {
  my $self = shift;
  my &#40;$file, @and&#41; = @_;

  my $mode;
  if&#40;@and&#41; {
    &#40;@and &gt; 1&#41; and croak&#40;&#39;too many arguments to save&#40;&#41;&#39;&#41;;
    $mode = $file;
    &#40;$file&#41; = @and;
  }

  # allow filehandle
  unless&#40;&#40;ref&#40;$file&#41; || &#39;&#39;&#41; eq &#39;GLOB&#39;&#41; {
    open&#40;my $fh, &#39;&gt;&#39;, $file&#41; or
      die &#34;cannot open &#39;$file&#39; for writing $!&#34;;
    $file = $fh;
  }

  $mode = &#39;ascii&#39; unless&#40;$mode&#41;;

  my $method = &#39;_write_&#39; . lc&#40;$mode&#41;;
  $self-&gt;can&#40;$method&#41; or croak&#40;&#34;invalid write mode &#39;$mode&#39;&#34;&#41;;

  $self-&gt;$method&#40;$file&#41;;
} # end subroutine save definition
########################################################################

=head2 _write_binary

  $self-&gt;_write_binary&#40;$filehandle&#41;;

=cut

sub _write_binary {
  my $self = shift;
  my &#40;$fh&#41; = @_;

  my &#40;$part, @and&#41; = $self-&gt;parts;
  @and and die &#39;cannot write binary files with multiple parts&#39;;

  my $name = $part-&gt;name; # utf8 is ok
  print $fh $name, &#34;\0&#34; x &#40;80 - do {use bytes; length&#40;$name&#41;}&#41;;
  my @facets = $part-&gt;facets;
  print $fh pack&#40;&#39;L&#39;, scalar&#40;@facets&#41;&#41;;
  foreach my $facet &#40;@facets&#41; {
    print $fh map&#40;{map&#40;{pack&#40;&#39;f&#39;, $_&#41;} @$_&#41;} @$facet&#41;;
    print $fh &#34;\0&#34; x 2;
  }

} # end subroutine _write_binary definition
########################################################################

=head2 _write_ascii

  $self-&gt;_write_ascii&#40;$filehandle&#41;;

=cut

sub _write_ascii {
  my $self = shift;
  my &#40;$fh&#41; = @_;

  my $spaces = &#39;&#39;;
  my $print = sub {print $fh $spaces, @_, &#34;\n&#34;};
  my @parts = $self-&gt;parts or croak&#40;&#34;no parts to write&#34;&#41;;
  foreach my $part &#40;@parts&#41; {
    $print-&gt;&#40;&#39;solid &#39;, $part-&gt;name&#41;;
    $spaces = &#39; &#39;x2;
    foreach my $facet &#40;$part-&gt;facets&#41; {
      my &#40;$n, @pts&#41; = @$facet;
      $print-&gt;&#40;join&#40;&#39; &#39;, &#39;facet normal&#39;, @$n&#41;&#41;;
      $spaces = &#39; &#39;x4;
      $print-&gt;&#40;&#39;outer loop&#39;&#41;;
      $spaces = &#39; &#39;x6;
      &#40;@pts == 3&#41; or die &#34;invalid facet&#34;;
      foreach my $pt &#40;@pts&#41; {
        $print-&gt;&#40;join&#40;&#39; &#39;, &#39;vertex&#39;, @$pt&#41;&#41;;
      }
      $spaces = &#39; &#39;x4;
      $print-&gt;&#40;&#39;endloop&#39;&#41;;
      $spaces = &#39; &#39;x2;
      $print-&gt;&#40;&#39;endfacet&#39;&#41;;
    }
    $spaces = &#39;&#39;;
    print $fh &#39;endsolid &#39;, $part-&gt;name, &#34;\n&#34;;
  }
} # end subroutine _write_ascii definition
########################################################################

=head1 AUTHOR

Eric Wilhelm @ &lt;ewilhelm at cpan dot org&gt;

<span class="clickylink"><a target="new" rel="nofollow" href="http://scratchcomputing.com/">http://scratchcomputing.com/</a></span>

=head1 BUGS

If you found this module on CPAN, please report any bugs or feature
requests through the web interface at L&lt;<span class="clickylink"><a target="new" rel="nofollow" href="/">http://rt.cpan.org</a></span>&gt;.  I will be
notified, and then you&#39;ll automatically be notified of progress on your
bug as I make changes.

If you pulled this development version from my /svn/, please contact me
directly.

=head1 COPYRIGHT

Copyright &#40;C&#41; 2007 Eric L. Wilhelm, All Rights Reserved.

=head1 NO WARRANTY

Absolutely, positively NO WARRANTY, neither express or implied, is
offered with this software.  You use this software at your own risk.  In
case of loss, no person or entity owes you anything whatsoever.  You
have been warned.

=head1 LICENSE

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

# vi:ts=2:sw=2:et:sta
1;
</div></div>
<table>
  <tr>
    <td align="right" class="message-header-key">Subject:</td>
    <td class="message-header-value"> onetri.stl</td>
  </tr>
</table>
<div class="downloadattachment">
<a href="/Ticket/Attachment/1184972/625117/onetri.stl">Download onetri.stl</a><br />
<span class="downloadcontenttype">application/vnd.ms-pki.stl 184b</span>
</div>
<div class="messagebody">
<p>Message body not shown because it is not plain text.</p></div>
</div>
    </div>
</div>
</div>
<div class="ticket-transaction message Correspond even">
<div class="ticket-transaction">
  <div class="metadata">
    <span class="type">
      &nbsp;      
    </span>
    <span class="date">Sun&nbsp;Feb&nbsp;24&nbsp;08:55:58&nbsp;2013</span>
    <span class="description">b [...] bathsheba.com -  Correspondence added</span>
    <span class="time-taken"></span>    <span class="actions hidden"></span>
  </div>
    <div class="content">
      
<table>
  <tr>
    <td align="right" class="message-header-key">From:</td>
    <td class="message-header-value"> b [...] bathsheba.com</td>
  </tr>
</table>

<div class="messagebody">
<div class="message-stanza plain-text-white-space">On Sun Feb 24 08:30:07 2013, bathsheba wrote:
<span
    class="message-stanza-folder closed"
    onclick="fold_message_stanza(this, 'Show\x20quoted\x20text', 'Hide\x20quoted\x20text');">Show quoted text</span><br /><div class="message-stanza closed">&gt; Thanks for writing this module!  
&gt; 
&gt; I was using it in Windows 7 with ActivePerl to import a lot of STL
&gt; files, and I saw it fail intermittently with binary format.  I tracked
&gt; this down and found that when bytes 0x0D, i.e. a carriage return, occur
&gt; in such a file, it fails.  Drops the character, reads a lot of gibberish
&gt; numbers, and eventually fails with an unexpected EOF.  Attached is a
&gt; small STL, 2 triangles, that shows this behavior.
&gt; 
&gt; I think it&#39;s because the perl read function is, in systems that
&gt; distinguish binary from text files, a text read: it strips carriage
&gt; returns.  Unfortunately Windows is such a system.  
&gt; 
&gt; I found that by calling binmode on the file handle, this is fixed. 
&gt; In STL.pm at line 348 I inserted &#39;binmode $fh;&#39;.  Attached is this file
&gt; with that change.
&gt; 
&gt; This is probably not the right place to add that, because it could fail
&gt; earlier during format detection.  But I didn&#39;t understand that part very
&gt; well and I only need to read binary files, so this is the best I could
&gt; do right now.
&gt; 
&gt; I&#39;m not a developer and don&#39;t feel up to putting a patch on CPAN,
&gt; especially when I don&#39;t think it&#39;s quite right.  But it would be awesome
&gt; if this got fixed properly.
&gt; 
&gt; Thanks for your consideration!
</div></div></div>
    </div>
</div>
</div>
<div class="ticket-transaction message Correspond odd">
<div class="ticket-transaction">
  <div class="metadata">
    <span class="type">
      &nbsp;      
    </span>
    <span class="date">Sun&nbsp;Feb&nbsp;24&nbsp;08:59:23&nbsp;2013</span>
    <span class="description">b [...] bathsheba.com -  Correspondence added</span>
    <span class="time-taken"></span>    <span class="actions hidden"></span>
  </div>
    <div class="content">
      
<table>
  <tr>
    <td align="right" class="message-header-key">From:</td>
    <td class="message-header-value"> b [...] bathsheba.com</td>
  </tr>
</table>
<div class="messageattachments">

<div class="messagebody">
<div class="message-stanza plain-text-white-space">PS added binmode again at line 423, in the _write_binary function, to
get rid of the same problem when writing.
</div></div>
<table>
  <tr>
    <td align="right" class="message-header-key">Subject:</td>
    <td class="message-header-value"> STL.pm</td>
  </tr>
</table>

<div class="messagebody">
<div class="message-stanza plain-text-white-space">package CAD::Format::STL;
$VERSION = v0.2.1;

use warnings;
use strict;
use Carp;

use CAD::Format::STL::part;

=head1 NAME

CAD::Format::STL - read/write 3D stereolithography files

=head1 SYNOPSIS

Reading:

  my $stl = CAD::Format::STL-&gt;new-&gt;load&#40;&#34;foo.stl&#34;&#41;;
  # what about the part/multipart?
  my @facets = $stl-&gt;part-&gt;facets;

Writing:

  my $stl = CAD::Format::STL-&gt;new;
  my $part = $stl-&gt;add_part&#40;&#34;my part&#34;&#41;;
  $part-&gt;add_facets&#40;@faces&#41;;
  $stl-&gt;save&#40;&#34;foo.stl&#34;&#41;;
  # or $stl-&gt;save&#40;binary =&gt; &#34;foo.stl&#34;&#41;;

Streaming read/write:

  my $reader = CAD::Format::STL-&gt;reader&#40;&#34;foo.stl&#34;&#41;;
  my $writer = CAD::Format::STL-&gt;writer&#40;binary =&gt; &#34;bar.stl&#34;&#41;;
  while&#40;my $part = $reader-&gt;next_part&#41; {
    my $part_name = $part-&gt;name;
    $writer-&gt;start_solid&#40;$part_name&#41;;
    while&#40;my @data = $part-&gt;facet&#41; {
      my &#40;$normal, @vertices&#41; = @data;
      my @v1 = @{$vertices[0]};
      my @v2 = @{$vertices[0]};
      my @v3 = @{$vertices[0]};
      # that&#39;s just for illustration
      $writer-&gt;facet&#40;\@v1, \@v2, \@v3&#41;;
      # note the omitted normal
    }
    $writer-&gt;end_solid;
  }

=begin design

The reader auto-detects whether it is binary &#40;but assumes ascii when
seek can&#39;t go backwards.&#41;

The reader and writer both take 1, 2, or {1,2}+2n arguments.

This package and/or the reader/writer are subclassable &#40;though getting
$self-&gt;reader to instantiate a subclass implies that you have subclassed
$self.&#41;

A cached_facet &#40;or raw_facet&#41; method is necessary to ensure uniform
tranformation of shared points &#40;and optimize the computation.&#41;  This
would return the normal and points as a list of scalars rather than
arrays, with a later call to unpack_point&#40;&#41; or something.  The caller
needs to be able to handle the caching &#40;or else there is a callback for
non-cached &#40;or an override for unpack_point&#40;&#41;.&#41;

Maybe $self-&gt;set_writer&#40;&#41; and set_reader&#40;&#41; immutable object methods?

=end design

=head1 ABOUT

This module provides object-oriented methods to read and write the STL
&#40;Stereo Lithography&#41; file format in both binary and ASCII forms.  The
STL format is a simple set of 3D triangles.

=cut

use Class::Accessor::Classy;
lo &#39;parts&#39;;
no  Class::Accessor::Classy;

=head1 Constructor

=head2 new

  my $stl = CAD::Format::STL-&gt;new;

=cut

sub new {
  my $package = shift;
  my $class = ref&#40;$package&#41; || $package;
  my $self = {parts =&gt; []};
  bless&#40;$self, $class&#41;;
  return&#40;$self&#41;;
} # end subroutine new definition
########################################################################

=head2 add_part

Create a new part in the stl.

  my $part = $stl-&gt;add_part&#40;&#34;name&#34;&#41;;

Optionally, add the faces directly:

  my $part = $stl-&gt;add_part&#40;&#34;name&#34;, @faces&#41;;

=cut

sub add_part {
  my $self = shift;
  my &#40;$name, @faces&#41; = @_;

  my $part = CAD::Format::STL::part-&gt;new&#40;$name, @faces&#41;;
  push&#40;@{$self-&gt;{parts}}, $part&#41;;
  return&#40;$part&#41;;
} # end subroutine add_part definition
########################################################################

=head2 part

Get the part at $index.  Negative indices are valid.

  my $part = $stl-&gt;part&#40;$index&#41;;

Throws an error if there is no such part.

=cut

sub part {
  my $self = shift;
  my &#40;$index&#41; = @_;

  @{$self-&gt;{parts}} or croak&#40;&#34;file has no parts&#34;&#41;;

  $index ||= 0;
  exists&#40;$self-&gt;{parts}[$index]&#41; or croak&#40;&#34;no part $index&#34;&#41;;
  return&#40;$self-&gt;{parts}[$index]&#41;;
} # end subroutine part definition
########################################################################

=head1 I/O Methods

=head2 load

Load an STL file &#40;auto-detects binary/ascii&#41;

  $stl = $stl-&gt;load&#40;&#34;filename.stl&#34;&#41;;

Optionally, explicitly declare binary mode:

  $stl = $stl-&gt;load&#40;binary =&gt; &#34;filename.stl&#34;&#41;;

The $self object is returned to allow e.g. chaining to C&lt;new&#40;&#41;&gt;.

The filename may also be a filehandle.

=cut

sub load {
  my $self = shift;
  my &#40;$file, @and&#41; = @_;

  my $mode;
  if&#40;@and&#41; {
    &#40;@and &gt; 1&#41; and croak&#40;&#39;too many arguments to load&#40;&#41;&#39;&#41;;
    $mode = $file;
    &#40;$file&#41; = @and;
  }

  # allow filehandle
  unless&#40;&#40;ref&#40;$file&#41; || &#39;&#39;&#41; eq &#39;GLOB&#39;&#41; {
    open&#40;my $fh, &#39;&lt;&#39;, $file&#41; or
      die &#34;cannot open &#39;$file&#39; for reading $!&#34;;
    $file = $fh;
  }

  # detection
  unless&#40;$mode&#41; {
    unless&#40;seek&#40;$file, 0,0&#41;&#41; {
      croak&#40;&#39;must have explicit mode for non-seekable filehandle&#39;&#41;;
    }
    # now, detection...
    $mode = sub {
      my $fh = shift;

      seek&#40;$fh, 80, 0&#41;;
      my $count = eval {
        my $buf; read&#40;$fh, $buf, 4&#41; or die;
        unpack&#40;&#39;L&#39;, $buf&#41;;
      };
      $@ and return &#39;ascii&#39;; # if we hit eof, it can&#39;t be binary
      $count or die &#34;detection failed - no facets?&#34;;
      my $size = &#40;stat&#40;$fh&#41;&#41;[7];
      # calculate the expected file size
      my $expect =
        + 80 # header
        +  4 # count
        + $count * &#40;
          + 4 # normal, pt,pt,pt &#40;vectors&#41;
          * 4 # bytes per value
          * 3 # values per vector
          + 2 # the trailing &#39;short&#39;
        &#41;;
      return &#40;$size == $expect&#41; ? &#39;binary&#39; : &#39;ascii&#39;;
    }-&gt;&#40;$file&#41;;
    seek&#40;$file, 0, 0&#41; or die &#34;cannot reset filehandle&#34;;
  }

  my $method = &#39;_read_&#39; . lc&#40;$mode&#41;;
  $self-&gt;can&#40;$method&#41; or croak&#40;&#34;invalid read mode &#39;$mode&#39;&#34;&#41;;

  $self-&gt;$method&#40;$file&#41;;
  return&#40;$self&#41;;
} # end subroutine load definition
########################################################################

=head2 _read_ascii

  $self-&gt;_read_ascii&#40;$filehandle&#41;;

=cut

sub _read_ascii {
  my $self = shift;
  my &#40;$fh&#41; = @_;

  my $getline = sub {
    while&#40;my $line = &lt;$fh&gt;&#41; {
      $line =~ s/\s*$//; # allow any eol
      length&#40;$line&#41; or next;
      return&#40;$line&#41;;
    }
    return;
  };
  my $p_re = qr/&#40;[^ ]+&#41;\s+&#40;[^ ]+&#41;\s+&#40;[^ ]+&#41;$/;

  my $part;
  while&#40;my $line = $getline-&gt;&#40;&#41;&#41; {

    if&#40;$line =~ m/^\s*solid &#40;.*&#41;/&#41; {
      $part = $self-&gt;add_part&#40;$1&#41;;
    }
    elsif&#40;$line =~ m/^\s*endsolid &#40;.*&#41;/&#41; {
      my $name = $1;
      $part or die &#34;invalid &#39;endsolid&#39; entry with no current part&#34;;
      &#40;$name eq $part-&gt;name&#41; or
        die &#34;end of part &#39;$name&#39; should have been &#39;&#34;,
          $part-&gt;name, &#34;&#39;&#34;;
      $part = undef;
    }
    elsif&#40;$part&#41; {
      my @n = &#40;$line =~ m/^\s*facet\s+normal\s+$p_re/&#41; or
        die &#34;how did that happen? &#40;$line&#41;&#34;;
      #warn &#34;got &#34;, join&#40;&#39;|&#39;, @n&#41;;
      my @facet = &#40;\@n&#41;;

      my $next = $getline-&gt;&#40;&#41;;
      unless&#40;$next and &#40;$next =~ m/^\s*outer\s+loop$/&#41;&#41; {
        die &#34;facet doesn&#39;t start with &#39;outer loop&#39; &#40;$next&#41;&#34;;
      }
      push&#40;@facet, do {
        my @got;
        while&#40;my $line = $getline-&gt;&#40;&#41;&#41; {
          &#40;$line =~ m/^\s*endloop$/&#41; and last;
          if&#40;$line =~ m/^\s*vertex\s+$p_re/&#41; {
            push&#40;@got, [$1, $2, $3]&#41;;
          }
        }
        @got;
      }&#41;;
      &#40;scalar&#40;@facet&#41; == 4&#41; or
        die &#34;need three vertices per facet &#40;not $#facet&#41;&#34;;
      my $end = $getline-&gt;&#40;&#41;;
      &#40;$end and &#40;$end =~ m/^\s*endfacet/&#41;&#41; or
        die &#34;bad endfacet $line&#34;;
      $part-&gt;add_facets&#40;[@facet]&#41;;
    }
    else {
      die &#34;what? &#40;$line&#41;&#34;;
    }
  }
  $part and die &#34;part &#39;&#34;, $part-&gt;name, &#34;&#39; was left open&#34;;
} # end subroutine _read_ascii definition
########################################################################

=head2 get_&lt;something&gt;

These functions are currently only used internally.

=over

=item get_triangle

=item get_ulong

=item get_float32

=item get_short

=back

=cut

sub get_triangle {
  my &#40;$fh&#41; = @_;

  my &#40;$n, $x, $y, $z&#41; = map&#40;{[map&#40;{get_float32&#40;$fh&#41;} 1..3&#41;]} 1..4&#41;;
  my $scrap = get_short&#40;$fh&#41;;
  return&#40;$n, $x, $y, $z&#41;;
}

sub get_ulong {
  my &#40;$fh&#41; = @_;

  my $buf;
  read&#40;$fh, $buf, 4&#41; or warn &#34;EOF?&#34;;
  return&#40;unpack&#40;&#39;L&#39;, $buf&#41;&#41;;
}

sub get_float32 {
  my &#40;$fh&#41; = @_;

  my $buf;
  read&#40;$fh, $buf, 4&#41; or warn &#34;EOF?&#34;;
  return&#40;unpack&#40;&#39;f&#39;, $buf&#41;&#41;;
}

sub get_short {
  my &#40;$fh&#41; = @_;

  my $buf;
  read&#40;$fh, $buf, 2&#41; or warn &#34;EOF?&#34;;
  return&#40;unpack&#40;&#39;S&#39;, $buf&#41;&#41;;
}

=head2 _read_binary

  $self-&gt;_read_binary&#40;$filehandle&#41;;

=cut

sub _read_binary {
  my $self = shift;
  my &#40;$fh&#41; = @_;

  binmode $fh;

  $self-&gt;parts and die &#34;binary STL files must have only one part&#34;;

  die &#34;bigfloat&#34; unless&#40;length&#40;pack&#40;&#34;f&#34;, 1&#41;&#41; == 4&#41;;
  # TODO try to read part name from header &#40;up to \0&#41;
  my $name = &#39;a part&#39;;
  seek&#40;$fh, 80, 0&#41;;

  my $triangles = get_ulong&#40;$fh&#41;;
  my $part = $self-&gt;add_part&#40;$name&#41;;

  my $count = 0;
  while&#40;1&#41; {
    my @tr = get_triangle&#40;$fh&#41;;
    # TODO check that the unit normal is within a thousandth of a radian
    # &#40;0.001 rad is ~0.06deg&#41;
    $part-&gt;add_facets&#40;[@tr]&#41;;
    $count++;
    eof&#40;$fh&#41; and last;
  }
  &#40;$count == $triangles&#41; or
    die &#34;ERROR: got $count facets &#40;expected $triangles&#41;&#34;;
} # end subroutine _read_binary definition
########################################################################

=head2 save

  $stl-&gt;save&#40;&#34;filename.stl&#34;&#41;;

  $stl-&gt;save&#40;binary =&gt; &#34;filename.stl&#34;&#41;;

=cut

sub save {
  my $self = shift;
  my &#40;$file, @and&#41; = @_;

  my $mode;
  if&#40;@and&#41; {
    &#40;@and &gt; 1&#41; and croak&#40;&#39;too many arguments to save&#40;&#41;&#39;&#41;;
    $mode = $file;
    &#40;$file&#41; = @and;
  }

  # allow filehandle
  unless&#40;&#40;ref&#40;$file&#41; || &#39;&#39;&#41; eq &#39;GLOB&#39;&#41; {
    open&#40;my $fh, &#39;&gt;&#39;, $file&#41; or
      die &#34;cannot open &#39;$file&#39; for writing $!&#34;;
    $file = $fh;
  }

  $mode = &#39;ascii&#39; unless&#40;$mode&#41;;

  my $method = &#39;_write_&#39; . lc&#40;$mode&#41;;
  $self-&gt;can&#40;$method&#41; or croak&#40;&#34;invalid write mode &#39;$mode&#39;&#34;&#41;;

  $self-&gt;$method&#40;$file&#41;;
} # end subroutine save definition
########################################################################

=head2 _write_binary

  $self-&gt;_write_binary&#40;$filehandle&#41;;

=cut

sub _write_binary {
  my $self = shift;
  my &#40;$fh&#41; = @_;

  my &#40;$part, @and&#41; = $self-&gt;parts;
  @and and die &#39;cannot write binary files with multiple parts&#39;;

  binmode $fh;

  my $name = $part-&gt;name; # utf8 is ok
  print $fh $name, &#34;\0&#34; x &#40;80 - do {use bytes; length&#40;$name&#41;}&#41;;
  my @facets = $part-&gt;facets;
  print $fh pack&#40;&#39;L&#39;, scalar&#40;@facets&#41;&#41;;
  foreach my $facet &#40;@facets&#41; {
    print $fh map&#40;{map&#40;{pack&#40;&#39;f&#39;, $_&#41;} @$_&#41;} @$facet&#41;;
    print $fh &#34;\0&#34; x 2;
  }

} # end subroutine _write_binary definition
########################################################################

=head2 _write_ascii

  $self-&gt;_write_ascii&#40;$filehandle&#41;;

=cut

sub _write_ascii {
  my $self = shift;
  my &#40;$fh&#41; = @_;

  my $spaces = &#39;&#39;;
  my $print = sub {print $fh $spaces, @_, &#34;\n&#34;};
  my @parts = $self-&gt;parts or croak&#40;&#34;no parts to write&#34;&#41;;
  foreach my $part &#40;@parts&#41; {
    $print-&gt;&#40;&#39;solid &#39;, $part-&gt;name&#41;;
    $spaces = &#39; &#39;x2;
    foreach my $facet &#40;$part-&gt;facets&#41; {
      my &#40;$n, @pts&#41; = @$facet;
      $print-&gt;&#40;join&#40;&#39; &#39;, &#39;facet normal&#39;, @$n&#41;&#41;;
      $spaces = &#39; &#39;x4;
      $print-&gt;&#40;&#39;outer loop&#39;&#41;;
      $spaces = &#39; &#39;x6;
      &#40;@pts == 3&#41; or die &#34;invalid facet&#34;;
      foreach my $pt &#40;@pts&#41; {
        $print-&gt;&#40;join&#40;&#39; &#39;, &#39;vertex&#39;, @$pt&#41;&#41;;
      }
      $spaces = &#39; &#39;x4;
      $print-&gt;&#40;&#39;endloop&#39;&#41;;
      $spaces = &#39; &#39;x2;
      $print-&gt;&#40;&#39;endfacet&#39;&#41;;
    }
    $spaces = &#39;&#39;;
    print $fh &#39;endsolid &#39;, $part-&gt;name, &#34;\n&#34;;
  }
} # end subroutine _write_ascii definition
########################################################################

=head1 AUTHOR

Eric Wilhelm @ &lt;ewilhelm at cpan dot org&gt;

<span class="clickylink"><a target="new" rel="nofollow" href="http://scratchcomputing.com/">http://scratchcomputing.com/</a></span>

=head1 BUGS

If you found this module on CPAN, please report any bugs or feature
requests through the web interface at L&lt;<span class="clickylink"><a target="new" rel="nofollow" href="/">http://rt.cpan.org</a></span>&gt;.  I will be
notified, and then you&#39;ll automatically be notified of progress on your
bug as I make changes.

If you pulled this development version from my /svn/, please contact me
directly.

=head1 COPYRIGHT

Copyright &#40;C&#41; 2007 Eric L. Wilhelm, All Rights Reserved.

=head1 NO WARRANTY

Absolutely, positively NO WARRANTY, neither express or implied, is
offered with this software.  You use this software at your own risk.  In
case of loss, no person or entity owes you anything whatsoever.  You
have been warned.

=head1 LICENSE

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

# vi:ts=2:sw=2:et:sta
1;
</div></div>
</div>
    </div>
</div>
</div>
</div>
    <hr class="clear" />
  </div>
</div>




</div>
 


  <hr class="clear" />
</div>
</body>
</html>
