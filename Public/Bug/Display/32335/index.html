<!DOCTYPE html>

<html lang="en">
  <head>
    <title>Bug #32335 for Sub-Uplevel: Problem when stacking calls to uplevel</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <!-- The X-UA-Compatible <meta> tag above must be very early in <head> -->

    <script>
if (window.top !== window.self) {
    document.write = "";

    window.top.location = window.self.location;

    setTimeout(function(){
        document.body.innerHTML = "";
    }, 1);

    window.self.onload = function(){
        document.body.innerHTML = "";
    };
}
</script>



<link rel="shortcut icon" href="/NoAuth/images/favicon.png" type="image/png" />
<link rel="stylesheet" href="/NoAuth/css/aileron-squished-00f758259152f8b6670ee485f462e6b8.css" type="text/css" media="all" />
<link rel="stylesheet" href="/NoAuth/css/print.css" type="text/css" media="print" />




<script type="text/javascript" src="/NoAuth/js/squished-42167f2409ce368da2d31038e5cb2a57.js"></script>

<script type="text/javascript"><!--
	jQuery( loadTitleBoxStates );

--></script>


<!--[if lt IE 8]>
<link rel="stylesheet" href="/NoAuth/css/aileron/msie.css" type="text/css" media="all" />
<![endif]-->
<!--[if lt IE 7]>
<link rel="stylesheet" href="/NoAuth/css/aileron/msie6.css" type="text/css" media="all" />
<![endif]-->
<script type="text/javascript">
jQuery(document).ready(function(){
    jQuery.fn.supersubs.defaults = {
        maxWidth: 30,
        extraWidth: 2
    };

    jQuery("#app-nav.toplevel").addClass('sf-menu sf-js-enabled sf-shadow').supersubs().superfish({ speed: 'fast' });
    jQuery("#page-menu.toplevel").addClass('sf-menu sf-js-enabled').supersubs().superfish({ dropShadows: false, speed: 'fast' }).supposition();
});
</script>


<!-- Site CSS from theme editor -->
<style type="text/css" media="all" id="sitecss">
</style>

<meta name="google-site-verification" content="kD3-uEJK1AkTqaC-rckcSt_HPkAj674DPPuEN6i-y0g" />

</head>
  <body class="aileron sidebyside" id="comp-Public-Bug-Display">

<div id="logo">
<a href="/"><img
    src="/NoAuth/images/cpan.png"
    alt="CPAN"
    width="181"
    height="38" /></a>
    <span class="rtname">RT for rt.cpan.org</span>
</div>


<div id="quickbar">
  <div id="quick-personal">
    <span class="hide"><a href="#skipnav">Skip Menu</a> | </span>
</div>

</div>
<div id="header"><h1>Bug #32335 for Sub-Uplevel: Problem when stacking calls to uplevel</h1></div>



<div id="page-navigation"><ul id="page-menu" class="toplevel">
 <li id="li-page-active_bugs"><a id="page-active_bugs" class="menu-item " href="/Public/Dist/Sub-Uplevel/Active/">Active bugs</a></li>
 <li id="li-page-resolved_bugs"><a id="page-resolved_bugs" class="menu-item " href="/Public/Dist/Sub-Uplevel/Resolved/">Resolved bugs</a></li>
 <li id="li-page-rejected_bugs"><a id="page-rejected_bugs" class="menu-item " href="/Public/Dist/Sub-Uplevel/Rejected/">Rejected bugs</a></li>
 <li id="li-page-report"><a id="page-report" class="menu-item " href="/Public/Dist/Sub-Uplevel/Active/"></a></li>
</ul></div>
<div id="topactions">



</div>
<div id="body">


<a name="skipnav" id="skipnav" accesskey="8"></a>




<div id="external_bugtracker">
<h3>Preferred bug tracker</h3>
<p>
<div>Please visit the <a href="https://github.com/Perl-Toolchain-Gang/Sub-Uplevel/issues">preferred bug tracker</a> to report your issue.</div>
</p>
</div>

<p>This queue is for tickets about the <a href="https://metacpan.org/release/Sub-Uplevel">Sub-Uplevel CPAN distribution</a>.</p>





<div class="">
  <div class="titlebox" id="">
  <div class="titlebox-title">
    <span class="widget"><a href="#" onclick="return rollup('TitleBox\x2D\x2D\x5FPublic\x5FBug\x5FDisplay\x5Fhtml\x2D\x2D\x2D\x2D\x2D\x2DUmVwb3J0IGluZm9ybWF0aW9u\x2D\x2D\x2D0');" title="Toggle visibility"></a></span>
    <span class="left">Report information</span>
    <span class="right-empty">		    </span>
  </div>
  <div class="titlebox-content " id="TitleBox--_Public_Bug_Display_html------UmVwb3J0IGluZm9ybWF0aW9u---0">


<table width="100%" class="ticket-summary">
<tr>
  <td valign="top" class="boxcontainer">
    <div class="ticket-info-basics">
  <div class="titlebox ticket-info-basics " id="">
  <div class="titlebox-title">
    <span class="widget"><a href="#" onclick="return rollup('TitleBox\x2D\x2D\x5FPublic\x5FBug\x5FDisplay\x5Fhtml\x2D\x2Dticket\x2Dinfo\x2Dbasics\x2D\x2D\x2D\x2DVGhlIEJhc2ljcw\x5F\x5F\x2D\x2D\x2D0');" title="Toggle visibility"></a></span>
    <span class="left">The Basics</span>
    <span class="right-empty">		    </span>
  </div>
  <div class="titlebox-content " id="TitleBox--_Public_Bug_Display_html--ticket-info-basics----VGhlIEJhc2ljcw__---0">


        <table>
  <tr class="id">
    <td class="label">Id:</td>
    <td class="value">32335</td>
  </tr>
  <tr class="status">
    <td class="label">Status:</td>
    <td class="value">resolved</td>
  </tr>
  <tr class="priority">
    <td class="label">Priority:</td>
    <td class="value">0/
</td>
  </tr>
  <tr class="queue">
    <td class="label">Queue:</td>
    <td class="value"><a href="/Public/Dist/Sub-Uplevel/Active/">Sub-Uplevel</a>
</td>
  </tr>
</table>

        <hr class="clear" />
  </div>
</div>




</div>


    <div class="ticket-info-people">
  <div class="titlebox ticket-info-people " id="">
  <div class="titlebox-title">
    <span class="widget"><a href="#" onclick="return rollup('TitleBox\x2D\x2D\x5FPublic\x5FBug\x5FDisplay\x5Fhtml\x2D\x2Dticket\x2Dinfo\x2Dpeople\x2D\x2D\x2D\x2DUGVvcGxl\x2D\x2D\x2D0');" title="Toggle visibility"></a></span>
    <span class="left">People</span>
    <span class="right-empty">		    </span>
  </div>
  <div class="titlebox-content " id="TitleBox--_Public_Bug_Display_html--ticket-info-people----UGVvcGxl---0">


        <table>
  <tr>
    <td class="label">Owner:</td>
    <td class="value">Nobody in particular
    
    </td>
  </tr>
  <tr>
    <td class="labeltop">Requestors:</td>
    <td class="value">
abc159abc [...] hotmail.com

<br />

</td>
  </tr>
  <tr>
    <td class="labeltop">Cc:</td>
    <td class="value">

</td>
  </tr>
  <tr>
    <td class="labeltop">AdminCc:</td>
    <td class="value">

</td>
  </tr>
</table>

        <hr class="clear" />
  </div>
</div>




</div>



  </td>
  <td valign="top" class="boxcontainer">
    
    <div class="ticket-info-cfs">
  <div class="titlebox ticket-info-cfs " id="">
  <div class="titlebox-title">
    <span class="widget"><a href="#" onclick="return rollup('TitleBox\x2D\x2D\x5FPublic\x5FBug\x5FDisplay\x5Fhtml\x2D\x2Dticket\x2Dinfo\x2Dcfs\x2D\x2D\x2D\x2DQnVnIEluZm9ybWF0aW9u\x2D\x2D\x2D0');" title="Toggle visibility"></a></span>
    <span class="left">Bug Information</span>
    <span class="right-empty">		    </span>
  </div>
  <div class="titlebox-content " id="TitleBox--_Public_Bug_Display_html--ticket-info-cfs----QnVnIEluZm9ybWF0aW9u---0">

 
        <table>
  <tr id="CF-1-ShowRow">
    <td class="label">Severity:</td>
    <td class="value">
Important    </td>
  </tr>
  <tr id="CF-30160-ShowRow">
    <td class="label">Broken in:</td>
    <td class="value">
<i>(no value)</i>
    </td>
  </tr>
  <tr id="CF-30161-ShowRow">
    <td class="label">Fixed in:</td>
    <td class="value">
<i>(no value)</i>
    </td>
  </tr>
</table>


        <hr class="clear" />
  </div>
</div>




</div>


    
</div>




</div>







  </td>
</tr>
</table>

    <hr class="clear" />
  </div>
</div>




</div>


<br />


<div class="history">
<div class="titlebox" id="">
  <div class="titlebox-title">
    <span class="widget"><a href="#" onclick="return rollup('TitleBox\x2D\x2D\x5FPublic\x5FBug\x5FDisplay\x5Fhtml\x2D\x2D\x2D\x2D\x2D\x2DSGlzdG9yeQ\x5F\x5F\x2D\x2D\x2D0');" title="Toggle visibility"></a></span>
    <span class="left">History</span>
    <span class="right">		<a href="#" data-direction="open" onclick="return toggle_all_folds(this, 'Show\x20all\x20quoted\x20text', 'Hide\x20all\x20quoted\x20text');">Show all quoted text</a>    </span>
  </div>
  <div class="titlebox-content " id="TitleBox--_Public_Bug_Display_html------SGlzdG9yeQ__---0">


<div id="ticket-history">
<div class="ticket-transaction message Create odd">
<div class="ticket-transaction">
  <div class="metadata">
    <span class="type">
      &nbsp;      
    </span>
    <span class="date">Tue&nbsp;Jan&nbsp;15&nbsp;13:43:54&nbsp;2008</span>
    <span class="description">abc159abc [...] hotmail.com -  Ticket created</span>
    <span class="time-taken"></span>    <span class="actions hidden"></span>
  </div>
    <div class="content">
      
<table>
  <tr>
    <td align="right" class="message-header-key">Subject:</td>
    <td class="message-header-value"> Problem when stacking calls to uplevel</td>
  </tr>
</table>
<div class="messageattachments">

<div class="messagebody">
<div class="message-stanza plain-text-white-space">Hello,

I use perl v5.6.1 and Sub-Uplevel-0.18 under Windows XP sp2.

When successive calls to uplevel are made, the _normal_caller is not
called by _uplevel_caller with the good frame number.

It returns the following errors when the caller&#40;&#41; function is called:
Use of uninitialized value in join or string at error_demo.pl line 45.
Use of uninitialized value in join or string at error_demo.pl line 45.
Use of uninitialized value in join or string at error_demo.pl line 45.

This is due to line 189 where you compute the adjustment you&#39;ll use to
go up in the stack.
The problems comes from the fact that you sum all the offsets stored in
@Up_Frames instead of just summing the differences between the offset of
the current uplevel call and the offset of the next call. This causes
the index $up to go out of bounds and makes the caller&#40;&#41; function return
undef.

To fix this I propose you replace line 189 by:
$adjust += 1 + abs&#40;&#40;&#40;$saw_uplevel &lt; scalar&#40;@Up_Frames&#41; - 1&#41; ?
$Up_Frames[$saw_uplevel + 1] : 0&#41; - $Up_Frames[$saw_uplevel]&#41; ;

This compute the offset value as:
offset = &#40;&#40;next element inboud&#41; ? next element : 0&#41; - current element

I hope it is clear enough.
</div></div>
</div>
<table>
  <tr>
    <td align="right" class="message-header-key">Subject:</td>
    <td class="message-header-value"> error_demo.pl</td>
  </tr>
</table>
<div class="messageattachments">
<div class="messagebody">
<div class="message-stanza plain-text-white-space">
</div></div>

<div class="messagebody">
<div class="message-stanza plain-text-white-space">use strict;
use warnings;
use mod::test ;

use Sub::Uplevel ;

# subroutine A calls subroutine B with uplevel&#40;&#41;, so when
# subroutine B queries caller&#40;&#41;, it gets main as the caller &#40;just
# like subroutine A&#41; instead of getting subroutine A

sub sub_a 
{
    warn &#34;Entering Subroutine A\n&#34; ;
    warn &#34;caller&#40;&#41; says: &#34;, join&#40;&#34;, &#34;, &#40;caller&#40;&#41;&#41;[0 .. 2]&#41;, &#34;\n\n\n&#34; ;
    warn &#34;Calling B\n&#34; ;
	
	#~ sub_b&#40;&#41;;
	uplevel 1, \&#38;sub_b ;
}

sub sub_b 
{
    warn &#34;Entering Subroutine B\n&#34; ;
    warn &#34;caller&#40;&#41; says: &#34;, join&#40;&#34;, &#34;, &#40;caller&#40;&#41;&#41;[0 .. 2]&#41;, &#34;\n\n\n&#34; ;
	warn &#34;Calling C\n&#34; ;
	
	sub_c&#40;&#41;;
	#~ uplevel 2, \&#38;sub_c ;
}

sub sub_c 
{
    warn &#34;Entering Subroutine C\n&#34; ;
    warn &#34;caller&#40;&#41; says: &#34;, join&#40;&#34;, &#34;, &#40;caller&#40;&#41;&#41;[0 .. 2]&#41;, &#34;\n\n\n&#34; ;
	warn &#34;Calling D with uplevel\n&#34; ;
	
	uplevel 3, \&#38;sub_d ;
	#~ sub_d&#40;&#41; ;
}


sub sub_d 
{
    warn &#34;Entering Subroutine D\n&#34; ;
    warn &#34;caller&#40;&#41; says: &#34;, join&#40;&#34;, &#34;, &#40;caller&#40;&#41;&#41;[0 .. 2]&#41;, &#34;\n\n\n&#34; ;
}


sub_a&#40;&#41; ;

</div></div>
</div>
<table>
  <tr>
    <td align="right" class="message-header-key">Subject:</td>
    <td class="message-header-value"> fixed_Uplevel.pm</td>
  </tr>
</table>
<div class="messageattachments">
<div class="messagebody">
<div class="message-stanza plain-text-white-space">
</div></div>

<div class="messagebody">
<div class="message-stanza plain-text-white-space">package Sub::Uplevel;

use strict;
use vars qw&#40;$VERSION @ISA @EXPORT&#41;;
$VERSION = &#39;0.18&#39;;

# We must override *CORE::GLOBAL::caller if it hasn&#39;t already been 
# overridden or else Perl won&#39;t see our local override later.

if &#40; not defined *CORE::GLOBAL::caller{CODE} &#41; {
    *CORE::GLOBAL::caller = \&#38;_normal_caller;
}

require Exporter;
@ISA = qw&#40;Exporter&#41;;
@EXPORT = qw&#40;uplevel&#41;;

=head1 NAME

Sub::Uplevel - apparently run a function in a higher stack frame

=head1 VERSION

This documentation describes version 0.18

=head1 SYNOPSIS

  use Sub::Uplevel;

  sub foo {
      print join &#34; - &#34;, caller;
  }

  sub bar {
      uplevel 1, \&#38;foo;
  }

  #line 11
  bar&#40;&#41;;    # main - foo.plx - 11

=head1 DESCRIPTION

Like Tcl&#39;s uplevel&#40;&#41; function, but not quite so dangerous.  The idea
is just to fool caller&#40;&#41;.  All the really naughty bits of Tcl&#39;s
uplevel&#40;&#41; are avoided.

B&lt;THIS IS NOT THE SORT OF THING YOU WANT TO DO EVERYDAY&gt;

=over 4

=item B&lt;uplevel&gt;

  uplevel $num_frames, \&#38;func, @args;

Makes the given function think it&#39;s being executed $num_frames higher
than the current stack level.  So when they use caller&#40;$frames&#41; it
will actually give caller&#40;$frames + $num_frames&#41; for them.

C&lt;uplevel&#40;1, \&#38;some_func, @_&#41;&gt; is effectively C&lt;goto &#38;some_func&gt; but
you don&#39;t immediately exit the current subroutine.  So while you can&#39;t
do this:

    sub wrapper {
        print &#34;Before\n&#34;;
        goto &#38;some_func;
        print &#34;After\n&#34;;
    }

you can do this:

    sub wrapper {
        print &#34;Before\n&#34;;
        my @out = uplevel 1, &#38;some_func;
        print &#34;After\n&#34;;
        return @out;
    }


=cut

use vars qw/@Up_Frames $Caller_Proxy/;
# @Up_Frames -- uplevel stack
# $Caller_Proxy -- whatever caller&#40;&#41; override was in effect before uplevel

sub uplevel {
    my&#40;$num_frames, $func, @args&#41; = @_;
    
    local @Up_Frames = &#40;$num_frames, @Up_Frames &#41;;
    
    # backwards compatible version of &#34;no warnings &#39;redefine&#39;&#34;
    my $old_W = $^W;
    $^W = 0;

    # Update the caller proxy if the uplevel override isn&#39;t in effect
    local $Caller_Proxy = *CORE::GLOBAL::caller{CODE}
        if *CORE::GLOBAL::caller{CODE} != \&#38;_uplevel_caller;
    local *CORE::GLOBAL::caller = \&#38;_uplevel_caller;
    
    # restore old warnings state
    $^W = $old_W;

    return $func-&gt;&#40;@args&#41;;
}

sub _normal_caller &#40;;$&#41; {
    my $height = $_[0];
    $height++;
    if&#40; wantarray and !@_ &#41; {
        return &#40;CORE::caller&#40;$height&#41;&#41;[0..2];
    }
    else {
        return CORE::caller&#40;$height&#41;;
    }
}

sub _uplevel_caller &#40;;$&#41; {
    my $height = $_[0] || 0;

    # shortcut if no uplevels have been called
    # always add +1 to CORE::caller &#40;proxy caller function&#41;
    # to skip this function&#39;s caller
    return $Caller_Proxy-&gt;&#40; $height + 1 &#41; if ! @Up_Frames;

=begin _private

So it has to work like this:

    Call stack               Actual     uplevel 1
CORE::GLOBAL::caller
Carp::short_error_loc           0
Carp::shortmess_heavy           1           0
Carp::croak                     2           1
try_croak                       3           2
uplevel                         4            
function_that_called_uplevel    5            
caller_we_want_to_see           6           3
its_caller                      7           4

So when caller&#40;X&#41; winds up below uplevel&#40;&#41;, it only has to use  
CORE::caller&#40;X+1&#41; &#40;to skip CORE::GLOBAL::caller&#41;.  But when caller&#40;X&#41;
winds up no or above uplevel&#40;&#41;, it&#39;s CORE::caller&#40;X+1+uplevel+1&#41;.

Which means I&#39;m probably going to have to do something nasty like walk
up the call stack on each caller&#40;&#41; to see if I&#39;m going to wind up   
before or after Sub::Uplevel::uplevel&#40;&#41;.

=end _private

=begin _dagolden

I found the description above a bit confusing.  Instead, this is the logic
that I found clearer when CORE::GLOBAL::caller is invoked and we have to
walk up the call stack:

* if searching up to the requested height in the real call stack doesn&#39;t find
a call to uplevel, then we can return the result at that height in the
call stack

* if we find a call to uplevel, we need to keep searching upwards beyond the
requested height at least by the amount of upleveling requested for that
call to uplevel &#40;from the Up_Frames stack set during the uplevel call&#41;

* additionally, we need to hide the uplevel subroutine call, too, so we search
upwards one more level for each call to uplevel

* when we&#39;ve reached the top of the search, we want to return that frame
in the call stack, i.e. the requested height plus any uplevel adjustments
found during the search

=end _dagolden
        
=cut

    my $saw_uplevel = 0;
    my $adjust = 0;

    # walk up the call stack to fight the right package level to return;
    # look one higher than requested for each call to uplevel found
    # and adjust by the amount found in the Up_Frames stack for that call.
    # We *must* use CORE::caller here since we need the real stack not what 
    # some other override says the stack looks like, just in case that other
    # override breaks things in some horrible way

    for &#40; my $up = 0; $up &lt;= $height + $adjust; $up++ &#41; {
        my @caller = CORE::caller&#40;$up + 1&#41;; 
        if&#40; defined $caller[0] &#38;&#38; $caller[0] eq __PACKAGE__ &#41; {
            # add one for each uplevel call seen
            # and look into the uplevel stack for the offset
            #~ $adjust += 1 + $Up_Frames[$saw_uplevel];
			$adjust += 1 + abs&#40;&#40;&#40;$saw_uplevel &lt; scalar&#40;@Up_Frames&#41; - 1&#41; ? $Up_Frames[$saw_uplevel + 1] : 0&#41; - $Up_Frames[$saw_uplevel]&#41; ;
            $saw_uplevel++;
        }
    }

    # For returning values, we pass through the call to the proxy caller
    # function, just at a higher stack level
    my @caller = $Caller_Proxy-&gt;&#40;$height + $adjust + 1&#41;;

    if&#40; wantarray &#41; {
        if&#40; !@_ &#41; {
            @caller = @caller[0..2];
        }
        return @caller;
    }
    else {
        return $caller[0];
    }
}

=back

=head1 EXAMPLE

The main reason I wrote this module is so I could write wrappers
around functions and they wouldn&#39;t be aware they&#39;ve been wrapped.

    use Sub::Uplevel;

    my $original_foo = \&#38;foo;

    *foo = sub {
        my @output = uplevel 1, $original_foo;
        print &#34;foo&#40;&#41; returned:  @output&#34;;
        return @output;
    };

If this code frightens you B&lt;you should not use this module.&gt;


=head1 BUGS and CAVEATS

Well, the bad news is uplevel&#40;&#41; is about 5 times slower than a normal
function call.  XS implementation anyone?

Sub::Uplevel overrides CORE::GLOBAL::caller temporarily for the scope of
each uplevel call.  It does its best to work with any previously existing
CORE::GLOBAL::caller &#40;both when Sub::Uplevel is first loaded and within 
each uplevel call&#41; such as from Contextual::Return or Hook::LexWrap.  

However, if you are routinely using multiple modules that override 
CORE::GLOBAL::caller, you are probably asking for trouble.

=head1 HISTORY

Those who do not learn from HISTORY are doomed to repeat it.

The lesson here is simple:  Don&#39;t sit next to a Tcl programmer at the
dinner table.

=head1 THANKS

Thanks to Brent Welch, Damian Conway and Robin Houston.

=head1 AUTHORS

David A Golden E&lt;lt&gt;dagolden@cpan.orgE&lt;gt&gt; &#40;current maintainer&#41;

Michael G Schwern E&lt;lt&gt;schwern@pobox.comE&lt;gt&gt; &#40;original author&#41;

=head1 LICENSE

Original code Copyright &#40;c&#41; 2001 to 2007 by Michael G Schwern.
Additional code Copyright &#40;c&#41; 2006 to 2007 by David A Golden.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

See <span class="clickylink"><a target="new" rel="nofollow" href="http://www.perl.com/perl/misc/Artistic.html">http://www.perl.com/perl/misc/Artistic.html</a></span>

=head1 SEE ALSO

PadWalker &#40;for the similar idea with lexicals&#41;, Hook::LexWrap, 
Tcl&#39;s uplevel&#40;&#41; at <span class="clickylink"><a target="new" rel="nofollow" href="http://www.scriptics.com/man/tcl8.4/TclCmd/uplevel.htm">http://www.scriptics.com/man/tcl8.4/TclCmd/uplevel.htm</a></span>

=cut


1;
</div></div>
</div>
    </div>
</div>
</div>
<div class="ticket-transaction message Correspond even">
<div class="ticket-transaction">
  <div class="metadata">
    <span class="type">
      &nbsp;      
    </span>
    <span class="date">Tue&nbsp;Jan&nbsp;15&nbsp;15:56:02&nbsp;2008</span>
    <span class="description">dagolden [...] cpan.org -  Correspondence added</span>
    <span class="time-taken"></span>    <span class="actions hidden"></span>
  </div>
    <div class="content">
      
<table>
  <tr>
    <td align="right" class="message-header-key">Subject:</td>
    <td class="message-header-value"> Re: [rt.cpan.org #32335] Problem when stacking calls to uplevel</td>
  </tr>
  <tr>
    <td align="right" class="message-header-key">Date:</td>
    <td class="message-header-value"> Tue, 15 Jan 2008 15:55:40 -0500</td>
  </tr>
  <tr>
    <td align="right" class="message-header-key">To:</td>
    <td class="message-header-value"> bug-Sub-Uplevel [...] rt.cpan.org</td>
  </tr>
  <tr>
    <td align="right" class="message-header-key">From:</td>
    <td class="message-header-value"> &#34;David Golden&#34; &lt;dagolden [...] cpan.org&gt;</td>
  </tr>
</table>

<div class="messagebody">
<div class="message-stanza plain-text-white-space"><span
    class="message-stanza-folder closed"
    onclick="fold_message_stanza(this, 'Show\x20quoted\x20text', 'Hide\x20quoted\x20text');">Show quoted text</span><br /><div class="message-stanza closed">&gt; The problems comes from the fact that you sum all the offsets stored in
&gt; @Up_Frames instead of just summing the differences between the offset of
&gt; the current uplevel call and the offset of the next call. This causes
&gt; the index $up to go out of bounds and makes the caller&#40;&#41; function return
&gt; undef.
&gt;
&gt; To fix this I propose you replace line 189 by:
&gt; $adjust += 1 + abs&#40;&#40;&#40;$saw_uplevel &lt; scalar&#40;@Up_Frames&#41; - 1&#41; ?
&gt; $Up_Frames[$saw_uplevel + 1] : 0&#41; - $Up_Frames[$saw_uplevel]&#41; ;
&gt;
&gt; This compute the offset value as:
&gt; offset = &#40;&#40;next element inboud&#41; ? next element : 0&#41; - current element
&gt;
&gt; I hope it is clear enough.
</div>
Thank you very much for the bug report -- particularly with the demo
file.  I&#39;ll take a look and make sure I understand the fix.  &#40;Every
time I work I Sub::Uplevel it takes me a bit to figure out  again
what&#39;s going on -- nested uplevels were tricky in the first place.&#41;
On the surface, it seems to make sense.

David
</div></div>
    </div>
</div>
</div>
<div class="ticket-transaction basics Status odd">
<div class="ticket-transaction">
  <div class="metadata">
    <span class="type">
      &nbsp;      
    </span>
    <span class="date">Tue&nbsp;Jan&nbsp;15&nbsp;15:56:04&nbsp;2008</span>
    <span class="description">The RT System itself -  Status changed from &#39;new&#39; to &#39;open&#39;</span>
    <span class="time-taken"></span>    <span class="actions hidden"></span>
  </div>
    <div class="content">
    </div>
</div>
</div>
<div class="ticket-transaction message Correspond even">
<div class="ticket-transaction">
  <div class="metadata">
    <span class="type">
      &nbsp;      
    </span>
    <span class="date">Tue&nbsp;Jan&nbsp;15&nbsp;16:55:20&nbsp;2008</span>
    <span class="description">dagolden [...] cpan.org -  Correspondence added</span>
    <span class="time-taken"></span>    <span class="actions hidden"></span>
  </div>
    <div class="content">
      
<table>
  <tr>
    <td align="right" class="message-header-key">Subject:</td>
    <td class="message-header-value"> Re: [rt.cpan.org #32335] Problem when stacking calls to uplevel</td>
  </tr>
  <tr>
    <td align="right" class="message-header-key">Date:</td>
    <td class="message-header-value"> Tue, 15 Jan 2008 16:55:02 -0500</td>
  </tr>
  <tr>
    <td align="right" class="message-header-key">To:</td>
    <td class="message-header-value"> bug-Sub-Uplevel [...] rt.cpan.org</td>
  </tr>
  <tr>
    <td align="right" class="message-header-key">From:</td>
    <td class="message-header-value"> &#34;David Golden&#34; &lt;dagolden [...] cpan.org&gt;</td>
  </tr>
</table>
<div class="messageattachments">

<div class="messagebody">
<div class="message-stanza plain-text-white-space">On Jan 15, 2008 1:43 PM, vive via RT &lt;bug-Sub-Uplevel@rt.cpan.org&gt; wrote:
<span
    class="message-stanza-folder closed"
    onclick="fold_message_stanza(this, 'Show\x20quoted\x20text', 'Hide\x20quoted\x20text');">Show quoted text</span><br /><div class="message-stanza closed">&gt; It returns the following errors when the caller&#40;&#41; function is called:
&gt; Use of uninitialized value in join or string at error_demo.pl line 45.
&gt; Use of uninitialized value in join or string at error_demo.pl line 45.
&gt; Use of uninitialized value in join or string at error_demo.pl line 45.
</div>
I&#39;ve looked more closely at this and I don&#39;t think it&#39;s a bug.  Your
demo program calls uplevel 3 when the apparent call stack isn&#39;t that
deep &#40;taking into account the prior uplevel call, which hides
subroutine B&#41;.  Therefore, you get undefined from caller&#40;&#41;.

Maybe uplevel should warn if someone attempts to call uplevel for more
than the height of the apparent call stack.

Here&#39;s a revised version of your demo program that shows what&#39;s
happening.  I use &#34;cluck&#34; to show the stack trace.  Notice after
entering subroutine C, the uplevel call of 3 happens when the call
stack only has two entries.  If you change the uplevel in C to 2, it
works fine.

If I&#39;m missing something, please let me know.  I&#39;m not sure why you
think that the uplevel of 3 in that situation shouldn&#39;t give undef.

David
</div></div>

<div class="messagebody">
<p>Message body is not shown because sender requested not to inline it.</p></div>
</div>
    </div>
</div>
</div>
<div class="ticket-transaction message Correspond odd">
<div class="ticket-transaction">
  <div class="metadata">
    <span class="type">
      &nbsp;      
    </span>
    <span class="date">Tue&nbsp;Jan&nbsp;15&nbsp;19:56:06&nbsp;2008</span>
    <span class="description">abc159abc [...] hotmail.com -  Correspondence added</span>
    <span class="time-taken"></span>    <span class="actions hidden"></span>
  </div>
    <div class="content">
      
<table>
  <tr>
    <td align="right" class="message-header-key">From:</td>
    <td class="message-header-value"> abc159abc [...] hotmail.com</td>
  </tr>
</table>
<div class="messageattachments">

<div class="messagebody">
<div class="message-stanza plain-text-white-space">On Tue Jan 15 16:55:20 2008, DAGOLDEN wrote:
<span
    class="message-stanza-folder closed"
    onclick="fold_message_stanza(this, 'Show\x20quoted\x20text', 'Hide\x20quoted\x20text');">Show quoted text</span><br /><div class="message-stanza closed">&gt; On Jan 15, 2008 1:43 PM, vive via RT &lt;bug-Sub-Uplevel@rt.cpan.org&gt; wrote:
<div class="message-stanza open">&gt; &gt; It returns the following errors when the caller&#40;&#41; function is called:
&gt; &gt; Use of uninitialized value in join or string at error_demo.pl line 45.
&gt; &gt; Use of uninitialized value in join or string at error_demo.pl line 45.
&gt; &gt; Use of uninitialized value in join or string at error_demo.pl line 45.
</div>&gt; 
&gt; I&#39;ve looked more closely at this and I don&#39;t think it&#39;s a bug.  Your
&gt; demo program calls uplevel 3 when the apparent call stack isn&#39;t that
&gt; deep &#40;taking into account the prior uplevel call, which hides
&gt; subroutine B&#41;.  Therefore, you get undefined from caller&#40;&#41;.
&gt; 
&gt; Maybe uplevel should warn if someone attempts to call uplevel for more
&gt; than the height of the apparent call stack.
&gt; 
&gt; Here&#39;s a revised version of your demo program that shows what&#39;s
&gt; happening.  I use &#34;cluck&#34; to show the stack trace.  Notice after
&gt; entering subroutine C, the uplevel call of 3 happens when the call
&gt; stack only has two entries.  If you change the uplevel in C to 2, it
&gt; works fine.
&gt; 
&gt; If I&#39;m missing something, please let me know.  I&#39;m not sure why you
&gt; think that the uplevel of 3 in that situation shouldn&#39;t give undef.
&gt; 
&gt; David
</div>

Hello,

I tried you code with the original library and with the fixed library &#40;I
just added a caller in each function to see the same output as in my
initial code&#41;.

Here is the original output:

<span
    class="message-stanza-folder closed"
    onclick="fold_message_stanza(this, 'Show\x20quoted\x20text', 'Hide\x20quoted\x20text');">Show quoted text</span><br /><div class="message-stanza closed">&gt;perl error_demo_stack.pl
</div>
Entering Subroutine A
Calling B with uplevel 1 at error_demo_stack.pl line 16
        main::sub_a&#40;&#41; called at error_demo_stack.pl line 54
caller&#40;&#41; says: main, error_demo_stack.pl, 54

Entering Subroutine B
Calling C at error_demo_stack.pl line 26
        main::sub_a&#40;&#41; called at error_demo_stack.pl line 54
caller&#40;&#41; says: main, error_demo_stack.pl, 54

Entering Subroutine C
Calling D with uplevel 3 at error_demo_stack.pl line 37
        main::sub_c&#40;&#41; called at error_demo_stack.pl line 30
        main::sub_a&#40;&#41; called at error_demo_stack.pl line 54
caller&#40;&#41; says: main, error_demo_stack.pl, 30

Entering Subroutine D
Inside D at error_demo_stack.pl line 48
caller&#40;&#41; says: undef, undef, undef


You can see that the last call to caller returns undef.
However the call stack is:
main 4-&gt; sub_a 3-&gt; &#40;uplevel&#40;1&#41; -&gt; sub_b&#41; 2-&gt; sub_c 1-&gt; &#40;uplevel&#40;3&#41; -&gt; sub_d&#41;
&#40;We see 4 levels but in fact we have 7 levels&#41;

So if I say uplevel 3, \&#38;sub_d context should be main.
It looks like the call stack is not deep because we called uplevel. If
we hadn&#39;t we would have had a longer stack.

Here is what the fixed library returns:
<span
    class="message-stanza-folder closed"
    onclick="fold_message_stanza(this, 'Show\x20quoted\x20text', 'Hide\x20quoted\x20text');">Show quoted text</span><br /><div class="message-stanza closed">&gt;perl error_call.pl
</div>
Entering Subroutine A
Calling B with uplevel 1 at error_call.pl line 16
        main::sub_a&#40;&#41; called at error_call.pl line 54
caller&#40;&#41; says: main, error_call.pl, 54

Entering Subroutine B
Calling C at error_call.pl line 26
        main::sub_a&#40;&#41; called at error_call.pl line 54
caller&#40;&#41; says: main, error_call.pl, 54

Entering Subroutine C
Calling D with uplevel 3 at error_call.pl line 37
        main::sub_c&#40;&#41; called at error_call.pl line 30
        main::sub_a&#40;&#41; called at error_call.pl line 54
caller&#40;&#41; says: main, error_call.pl, 30

Entering Subroutine D
Inside D at error_call.pl line 48
        main::sub_a&#40;&#41; called at error_call.pl line 54
caller&#40;&#41; says: main, error_call.pl, 54


This exactly reflects the call stack I think we should have.
main 4-&gt; sub_a 3-&gt; &#40;uplevel&#40;1&#41; -&gt; sub_b&#41; 2-&gt; sub_c 1-&gt; &#40;uplevel&#40;3&#41; -&gt; sub_d&#41;
If I call uplevel 3 i want my context to be 3 levels above my caller
which is main in sub_d. Don&#39;t you think ?
</div></div>
</div>
<div class="messageattachments">
<div class="messagebody">
<div class="message-stanza plain-text-white-space">
</div></div>

<div class="messagebody">
<div class="message-stanza plain-text-white-space">use strict;
use warnings;
#use mod::test ;
use Carp qw/cluck/;

use Sub::Uplevel ;

# subroutine A calls subroutine B with uplevel&#40;&#41;, so when
# subroutine B queries caller&#40;&#41;, it gets main as the caller &#40;just
# like subroutine A&#41; instead of getting subroutine A

sub sub_a 
{
    my $uplevel = 1;
    warn &#34;\nEntering Subroutine A\n&#34; ;
    cluck &#34;Calling B with uplevel $uplevel&#34; ;
	warn &#34;caller&#40;&#41; says: &#34;, join&#40;&#34;, &#34;, map { defined $_ ? $_ : &#39;undef&#39; } 
        &#40;caller&#40;&#41;&#41;[0 .. 2]&#41;, &#34;\n&#34; ;

	uplevel $uplevel, \&#38;sub_b ;
}

sub sub_b 
{
    warn &#34;\nEntering Subroutine B\n&#34; ;
	cluck &#34;Calling C&#34; ;
	warn &#34;caller&#40;&#41; says: &#34;, join&#40;&#34;, &#34;, map { defined $_ ? $_ : &#39;undef&#39; } 
        &#40;caller&#40;&#41;&#41;[0 .. 2]&#41;, &#34;\n&#34; ;
	
	sub_c&#40;&#41;;
}

sub sub_c 
{
    my $uplevel = 3;
    warn &#34;\nEntering Subroutine C\n&#34; ;
	cluck &#34;Calling D with uplevel $uplevel&#34; ;
	warn &#34;caller&#40;&#41; says: &#34;, join&#40;&#34;, &#34;, map { defined $_ ? $_ : &#39;undef&#39; } 
        &#40;caller&#40;&#41;&#41;[0 .. 2]&#41;, &#34;\n&#34; ;
	
	uplevel $uplevel, \&#38;sub_d ;
}


sub sub_d 
{
    warn &#34;\nEntering Subroutine D\n&#34; ;
    cluck &#34;Inside D&#34;;
    warn &#34;caller&#40;&#41; says: &#34;, join&#40;&#34;, &#34;, map { defined $_ ? $_ : &#39;undef&#39; } 
        &#40;caller&#40;&#41;&#41;[0 .. 2]&#41;, &#34;\n&#34; ;
}


sub_a&#40;&#41; ;

</div></div>
</div>
<div class="messageattachments">
<div class="messagebody">
<div class="message-stanza plain-text-white-space">
</div></div>

<div class="messagebody">
<div class="message-stanza plain-text-white-space">package Sub::Uplevel;

use strict;
use vars qw&#40;$VERSION @ISA @EXPORT&#41;;
$VERSION = &#39;0.18&#39;;

# We must override *CORE::GLOBAL::caller if it hasn&#39;t already been 
# overridden or else Perl won&#39;t see our local override later.

if &#40; not defined *CORE::GLOBAL::caller{CODE} &#41; {
    *CORE::GLOBAL::caller = \&#38;_normal_caller;
}

require Exporter;
@ISA = qw&#40;Exporter&#41;;
@EXPORT = qw&#40;uplevel&#41;;

=head1 NAME

Sub::Uplevel - apparently run a function in a higher stack frame

=head1 VERSION

This documentation describes version 0.18

=head1 SYNOPSIS

  use Sub::Uplevel;

  sub foo {
      print join &#34; - &#34;, caller;
  }

  sub bar {
      uplevel 1, \&#38;foo;
  }

  #line 11
  bar&#40;&#41;;    # main - foo.plx - 11

=head1 DESCRIPTION

Like Tcl&#39;s uplevel&#40;&#41; function, but not quite so dangerous.  The idea
is just to fool caller&#40;&#41;.  All the really naughty bits of Tcl&#39;s
uplevel&#40;&#41; are avoided.

B&lt;THIS IS NOT THE SORT OF THING YOU WANT TO DO EVERYDAY&gt;

=over 4

=item B&lt;uplevel&gt;

  uplevel $num_frames, \&#38;func, @args;

Makes the given function think it&#39;s being executed $num_frames higher
than the current stack level.  So when they use caller&#40;$frames&#41; it
will actually give caller&#40;$frames + $num_frames&#41; for them.

C&lt;uplevel&#40;1, \&#38;some_func, @_&#41;&gt; is effectively C&lt;goto &#38;some_func&gt; but
you don&#39;t immediately exit the current subroutine.  So while you can&#39;t
do this:

    sub wrapper {
        print &#34;Before\n&#34;;
        goto &#38;some_func;
        print &#34;After\n&#34;;
    }

you can do this:

    sub wrapper {
        print &#34;Before\n&#34;;
        my @out = uplevel 1, &#38;some_func;
        print &#34;After\n&#34;;
        return @out;
    }


=cut

use vars qw/@Up_Frames $Caller_Proxy/;
# @Up_Frames -- uplevel stack
# $Caller_Proxy -- whatever caller&#40;&#41; override was in effect before uplevel

sub uplevel {
    my&#40;$num_frames, $func, @args&#41; = @_;
    
    local @Up_Frames = &#40;$num_frames, @Up_Frames &#41;;
    
    # backwards compatible version of &#34;no warnings &#39;redefine&#39;&#34;
    my $old_W = $^W;
    $^W = 0;

    # Update the caller proxy if the uplevel override isn&#39;t in effect
    local $Caller_Proxy = *CORE::GLOBAL::caller{CODE}
        if *CORE::GLOBAL::caller{CODE} != \&#38;_uplevel_caller;
    local *CORE::GLOBAL::caller = \&#38;_uplevel_caller;
    
    # restore old warnings state
    $^W = $old_W;

    return $func-&gt;&#40;@args&#41;;
}

sub _normal_caller &#40;;$&#41; {
    my $height = $_[0];
    $height++;
    if&#40; wantarray and !@_ &#41; {
        return &#40;CORE::caller&#40;$height&#41;&#41;[0..2];
    }
    else {
        return CORE::caller&#40;$height&#41;;
    }
}

sub _uplevel_caller &#40;;$&#41; {
    my $height = $_[0] || 0;

    # shortcut if no uplevels have been called
    # always add +1 to CORE::caller &#40;proxy caller function&#41;
    # to skip this function&#39;s caller
    return $Caller_Proxy-&gt;&#40; $height + 1 &#41; if ! @Up_Frames;

=begin _private

So it has to work like this:

    Call stack               Actual     uplevel 1
CORE::GLOBAL::caller
Carp::short_error_loc           0
Carp::shortmess_heavy           1           0
Carp::croak                     2           1
try_croak                       3           2
uplevel                         4            
function_that_called_uplevel    5            
caller_we_want_to_see           6           3
its_caller                      7           4

So when caller&#40;X&#41; winds up below uplevel&#40;&#41;, it only has to use  
CORE::caller&#40;X+1&#41; &#40;to skip CORE::GLOBAL::caller&#41;.  But when caller&#40;X&#41;
winds up no or above uplevel&#40;&#41;, it&#39;s CORE::caller&#40;X+1+uplevel+1&#41;.

Which means I&#39;m probably going to have to do something nasty like walk
up the call stack on each caller&#40;&#41; to see if I&#39;m going to wind up   
before or after Sub::Uplevel::uplevel&#40;&#41;.

=end _private

=begin _dagolden

I found the description above a bit confusing.  Instead, this is the logic
that I found clearer when CORE::GLOBAL::caller is invoked and we have to
walk up the call stack:

* if searching up to the requested height in the real call stack doesn&#39;t find
a call to uplevel, then we can return the result at that height in the
call stack

* if we find a call to uplevel, we need to keep searching upwards beyond the
requested height at least by the amount of upleveling requested for that
call to uplevel &#40;from the Up_Frames stack set during the uplevel call&#41;

* additionally, we need to hide the uplevel subroutine call, too, so we search
upwards one more level for each call to uplevel

* when we&#39;ve reached the top of the search, we want to return that frame
in the call stack, i.e. the requested height plus any uplevel adjustments
found during the search

=end _dagolden
        
=cut

    my $saw_uplevel = 0;
    my $adjust = 0;

    # walk up the call stack to fight the right package level to return;
    # look one higher than requested for each call to uplevel found
    # and adjust by the amount found in the Up_Frames stack for that call.
    # We *must* use CORE::caller here since we need the real stack not what 
    # some other override says the stack looks like, just in case that other
    # override breaks things in some horrible way

    for &#40; my $up = 0; $up &lt;= $height + $adjust; $up++ &#41; {
        my @caller = CORE::caller&#40;$up + 1&#41;; 
        if&#40; defined $caller[0] &#38;&#38; $caller[0] eq __PACKAGE__ &#41; {
            # add one for each uplevel call seen
            # and look into the uplevel stack for the offset
            $adjust += 1 + $Up_Frames[$saw_uplevel];
            $saw_uplevel++;
        }
    }

    # For returning values, we pass through the call to the proxy caller
    # function, just at a higher stack level
    my @caller = $Caller_Proxy-&gt;&#40;$height + $adjust + 1&#41;;

    if&#40; wantarray &#41; {
        if&#40; !@_ &#41; {
            @caller = @caller[0..2];
        }
        return @caller;
    }
    else {
        return $caller[0];
    }
}

=back

=head1 EXAMPLE

The main reason I wrote this module is so I could write wrappers
around functions and they wouldn&#39;t be aware they&#39;ve been wrapped.

    use Sub::Uplevel;

    my $original_foo = \&#38;foo;

    *foo = sub {
        my @output = uplevel 1, $original_foo;
        print &#34;foo&#40;&#41; returned:  @output&#34;;
        return @output;
    };

If this code frightens you B&lt;you should not use this module.&gt;


=head1 BUGS and CAVEATS

Well, the bad news is uplevel&#40;&#41; is about 5 times slower than a normal
function call.  XS implementation anyone?

Sub::Uplevel overrides CORE::GLOBAL::caller temporarily for the scope of
each uplevel call.  It does its best to work with any previously existing
CORE::GLOBAL::caller &#40;both when Sub::Uplevel is first loaded and within 
each uplevel call&#41; such as from Contextual::Return or Hook::LexWrap.  

However, if you are routinely using multiple modules that override 
CORE::GLOBAL::caller, you are probably asking for trouble.

=head1 HISTORY

Those who do not learn from HISTORY are doomed to repeat it.

The lesson here is simple:  Don&#39;t sit next to a Tcl programmer at the
dinner table.

=head1 THANKS

Thanks to Brent Welch, Damian Conway and Robin Houston.

=head1 AUTHORS

David A Golden E&lt;lt&gt;dagolden@cpan.orgE&lt;gt&gt; &#40;current maintainer&#41;

Michael G Schwern E&lt;lt&gt;schwern@pobox.comE&lt;gt&gt; &#40;original author&#41;

=head1 LICENSE

Original code Copyright &#40;c&#41; 2001 to 2007 by Michael G Schwern.
Additional code Copyright &#40;c&#41; 2006 to 2007 by David A Golden.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

See <span class="clickylink"><a target="new" rel="nofollow" href="http://www.perl.com/perl/misc/Artistic.html">http://www.perl.com/perl/misc/Artistic.html</a></span>

=head1 SEE ALSO

PadWalker &#40;for the similar idea with lexicals&#41;, Hook::LexWrap, 
Tcl&#39;s uplevel&#40;&#41; at <span class="clickylink"><a target="new" rel="nofollow" href="http://www.scriptics.com/man/tcl8.4/TclCmd/uplevel.htm">http://www.scriptics.com/man/tcl8.4/TclCmd/uplevel.htm</a></span>

=cut


1;
</div></div>
</div>
<div class="messageattachments">
<div class="messagebody">
<div class="message-stanza plain-text-white-space">
</div></div>

<div class="messagebody">
<div class="message-stanza plain-text-white-space">package Sub::UplevelFix;

use strict;
use vars qw&#40;$VERSION @ISA @EXPORT&#41;;
$VERSION = &#39;0.18&#39;;

# We must override *CORE::GLOBAL::caller if it hasn&#39;t already been 
# overridden or else Perl won&#39;t see our local override later.

if &#40; not defined *CORE::GLOBAL::caller{CODE} &#41; {
    *CORE::GLOBAL::caller = \&#38;_normal_caller;
}

require Exporter;
@ISA = qw&#40;Exporter&#41;;
@EXPORT = qw&#40;uplevel&#41;;

=head1 NAME

Sub::Uplevel - apparently run a function in a higher stack frame

=head1 VERSION

This documentation describes version 0.18

=head1 SYNOPSIS

  use Sub::Uplevel;

  sub foo {
      print join &#34; - &#34;, caller;
  }

  sub bar {
      uplevel 1, \&#38;foo;
  }

  #line 11
  bar&#40;&#41;;    # main - foo.plx - 11

=head1 DESCRIPTION

Like Tcl&#39;s uplevel&#40;&#41; function, but not quite so dangerous.  The idea
is just to fool caller&#40;&#41;.  All the really naughty bits of Tcl&#39;s
uplevel&#40;&#41; are avoided.

B&lt;THIS IS NOT THE SORT OF THING YOU WANT TO DO EVERYDAY&gt;

=over 4

=item B&lt;uplevel&gt;

  uplevel $num_frames, \&#38;func, @args;

Makes the given function think it&#39;s being executed $num_frames higher
than the current stack level.  So when they use caller&#40;$frames&#41; it
will actually give caller&#40;$frames + $num_frames&#41; for them.

C&lt;uplevel&#40;1, \&#38;some_func, @_&#41;&gt; is effectively C&lt;goto &#38;some_func&gt; but
you don&#39;t immediately exit the current subroutine.  So while you can&#39;t
do this:

    sub wrapper {
        print &#34;Before\n&#34;;
        goto &#38;some_func;
        print &#34;After\n&#34;;
    }

you can do this:

    sub wrapper {
        print &#34;Before\n&#34;;
        my @out = uplevel 1, &#38;some_func;
        print &#34;After\n&#34;;
        return @out;
    }


=cut

use vars qw/@Up_Frames $Caller_Proxy/;
# @Up_Frames -- uplevel stack
# $Caller_Proxy -- whatever caller&#40;&#41; override was in effect before uplevel

sub uplevel {
    my&#40;$num_frames, $func, @args&#41; = @_;
    
    local @Up_Frames = &#40;$num_frames, @Up_Frames &#41;;
    
    # backwards compatible version of &#34;no warnings &#39;redefine&#39;&#34;
    my $old_W = $^W;
    $^W = 0;

    # Update the caller proxy if the uplevel override isn&#39;t in effect
    local $Caller_Proxy = *CORE::GLOBAL::caller{CODE}
        if *CORE::GLOBAL::caller{CODE} != \&#38;_uplevel_caller;
    local *CORE::GLOBAL::caller = \&#38;_uplevel_caller;
    
    # restore old warnings state
    $^W = $old_W;

    return $func-&gt;&#40;@args&#41;;
}

sub _normal_caller &#40;;$&#41; {
    my $height = $_[0];
    $height++;
    if&#40; wantarray and !@_ &#41; {
        return &#40;CORE::caller&#40;$height&#41;&#41;[0..2];
    }
    else {
        return CORE::caller&#40;$height&#41;;
    }
}

sub _uplevel_caller &#40;;$&#41; {
    my $height = $_[0] || 0;

    # shortcut if no uplevels have been called
    # always add +1 to CORE::caller &#40;proxy caller function&#41;
    # to skip this function&#39;s caller
    return $Caller_Proxy-&gt;&#40; $height + 1 &#41; if ! @Up_Frames;

=begin _private

So it has to work like this:

    Call stack               Actual     uplevel 1
CORE::GLOBAL::caller
Carp::short_error_loc           0
Carp::shortmess_heavy           1           0
Carp::croak                     2           1
try_croak                       3           2
uplevel                         4            
function_that_called_uplevel    5            
caller_we_want_to_see           6           3
its_caller                      7           4

So when caller&#40;X&#41; winds up below uplevel&#40;&#41;, it only has to use  
CORE::caller&#40;X+1&#41; &#40;to skip CORE::GLOBAL::caller&#41;.  But when caller&#40;X&#41;
winds up no or above uplevel&#40;&#41;, it&#39;s CORE::caller&#40;X+1+uplevel+1&#41;.

Which means I&#39;m probably going to have to do something nasty like walk
up the call stack on each caller&#40;&#41; to see if I&#39;m going to wind up   
before or after Sub::Uplevel::uplevel&#40;&#41;.

=end _private

=begin _dagolden

I found the description above a bit confusing.  Instead, this is the logic
that I found clearer when CORE::GLOBAL::caller is invoked and we have to
walk up the call stack:

* if searching up to the requested height in the real call stack doesn&#39;t find
a call to uplevel, then we can return the result at that height in the
call stack

* if we find a call to uplevel, we need to keep searching upwards beyond the
requested height at least by the amount of upleveling requested for that
call to uplevel &#40;from the Up_Frames stack set during the uplevel call&#41;

* additionally, we need to hide the uplevel subroutine call, too, so we search
upwards one more level for each call to uplevel

* when we&#39;ve reached the top of the search, we want to return that frame
in the call stack, i.e. the requested height plus any uplevel adjustments
found during the search

=end _dagolden
        
=cut

    my $saw_uplevel = 0;
    my $adjust = 0;

    # walk up the call stack to fight the right package level to return;
    # look one higher than requested for each call to uplevel found
    # and adjust by the amount found in the Up_Frames stack for that call.
    # We *must* use CORE::caller here since we need the real stack not what 
    # some other override says the stack looks like, just in case that other
    # override breaks things in some horrible way

    for &#40; my $up = 0; $up &lt;= $height + $adjust; $up++ &#41; {
        my @caller = CORE::caller&#40;$up + 1&#41;; 
        if&#40; defined $caller[0] &#38;&#38; $caller[0] eq __PACKAGE__ &#41; {
            # add one for each uplevel call seen
            # and look into the uplevel stack for the offset
            #~ $adjust += 1 + $Up_Frames[$saw_uplevel];
			$adjust += 1 + abs&#40;&#40;&#40;$saw_uplevel &lt; scalar&#40;@Up_Frames&#41; - 1&#41; ? $Up_Frames[$saw_uplevel + 1] : 0&#41; - $Up_Frames[$saw_uplevel]&#41; ;
            $saw_uplevel++;
        }
    }

    # For returning values, we pass through the call to the proxy caller
    # function, just at a higher stack level
    my @caller = $Caller_Proxy-&gt;&#40;$height + $adjust + 1&#41;;

    if&#40; wantarray &#41; {
        if&#40; !@_ &#41; {
            @caller = @caller[0..2];
        }
        return @caller;
    }
    else {
        return $caller[0];
    }
}

=back

=head1 EXAMPLE

The main reason I wrote this module is so I could write wrappers
around functions and they wouldn&#39;t be aware they&#39;ve been wrapped.

    use Sub::Uplevel;

    my $original_foo = \&#38;foo;

    *foo = sub {
        my @output = uplevel 1, $original_foo;
        print &#34;foo&#40;&#41; returned:  @output&#34;;
        return @output;
    };

If this code frightens you B&lt;you should not use this module.&gt;


=head1 BUGS and CAVEATS

Well, the bad news is uplevel&#40;&#41; is about 5 times slower than a normal
function call.  XS implementation anyone?

Sub::Uplevel overrides CORE::GLOBAL::caller temporarily for the scope of
each uplevel call.  It does its best to work with any previously existing
CORE::GLOBAL::caller &#40;both when Sub::Uplevel is first loaded and within 
each uplevel call&#41; such as from Contextual::Return or Hook::LexWrap.  

However, if you are routinely using multiple modules that override 
CORE::GLOBAL::caller, you are probably asking for trouble.

=head1 HISTORY

Those who do not learn from HISTORY are doomed to repeat it.

The lesson here is simple:  Don&#39;t sit next to a Tcl programmer at the
dinner table.

=head1 THANKS

Thanks to Brent Welch, Damian Conway and Robin Houston.

=head1 AUTHORS

David A Golden E&lt;lt&gt;dagolden@cpan.orgE&lt;gt&gt; &#40;current maintainer&#41;

Michael G Schwern E&lt;lt&gt;schwern@pobox.comE&lt;gt&gt; &#40;original author&#41;

=head1 LICENSE

Original code Copyright &#40;c&#41; 2001 to 2007 by Michael G Schwern.
Additional code Copyright &#40;c&#41; 2006 to 2007 by David A Golden.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

See <span class="clickylink"><a target="new" rel="nofollow" href="http://www.perl.com/perl/misc/Artistic.html">http://www.perl.com/perl/misc/Artistic.html</a></span>

=head1 SEE ALSO

PadWalker &#40;for the similar idea with lexicals&#41;, Hook::LexWrap, 
Tcl&#39;s uplevel&#40;&#41; at <span class="clickylink"><a target="new" rel="nofollow" href="http://www.scriptics.com/man/tcl8.4/TclCmd/uplevel.htm">http://www.scriptics.com/man/tcl8.4/TclCmd/uplevel.htm</a></span>

=cut


1;
</div></div>
</div>
<div class="messageattachments">
<div class="messagebody">
<div class="message-stanza plain-text-white-space">
</div></div>

<div class="messagebody">
<div class="message-stanza plain-text-white-space">use strict;
use warnings;
#use mod::test ;
use Carp qw/cluck/;

use Sub::UplevelFix ;

# subroutine A calls subroutine B with uplevel&#40;&#41;, so when
# subroutine B queries caller&#40;&#41;, it gets main as the caller &#40;just
# like subroutine A&#41; instead of getting subroutine A

sub sub_a 
{
    my $uplevel = 1;
    warn &#34;\nEntering Subroutine A\n&#34; ;
    cluck &#34;Calling B with uplevel $uplevel&#34; ;
	warn &#34;caller&#40;&#41; says: &#34;, join&#40;&#34;, &#34;, map { defined $_ ? $_ : &#39;undef&#39; } 
        &#40;caller&#40;&#41;&#41;[0 .. 2]&#41;, &#34;\n&#34; ;

	uplevel $uplevel, \&#38;sub_b ;
}

sub sub_b 
{
    warn &#34;\nEntering Subroutine B\n&#34; ;
	cluck &#34;Calling C&#34; ;
	warn &#34;caller&#40;&#41; says: &#34;, join&#40;&#34;, &#34;, map { defined $_ ? $_ : &#39;undef&#39; } 
        &#40;caller&#40;&#41;&#41;[0 .. 2]&#41;, &#34;\n&#34; ;
	
	sub_c&#40;&#41;;
}

sub sub_c 
{
    my $uplevel = 3;
    warn &#34;\nEntering Subroutine C\n&#34; ;
	cluck &#34;Calling D with uplevel $uplevel&#34; ;
	warn &#34;caller&#40;&#41; says: &#34;, join&#40;&#34;, &#34;, map { defined $_ ? $_ : &#39;undef&#39; } 
        &#40;caller&#40;&#41;&#41;[0 .. 2]&#41;, &#34;\n&#34; ;
	
	uplevel $uplevel, \&#38;sub_d ;
}


sub sub_d 
{
    warn &#34;\nEntering Subroutine D\n&#34; ;
    cluck &#34;Inside D&#34;;
    warn &#34;caller&#40;&#41; says: &#34;, join&#40;&#34;, &#34;, map { defined $_ ? $_ : &#39;undef&#39; } 
        &#40;caller&#40;&#41;&#41;[0 .. 2]&#41;, &#34;\n&#34; ;
}


sub_a&#40;&#41; ;

</div></div>
</div>
    </div>
</div>
</div>
<div class="ticket-transaction message Correspond even">
<div class="ticket-transaction">
  <div class="metadata">
    <span class="type">
      &nbsp;      
    </span>
    <span class="date">Tue&nbsp;Jan&nbsp;15&nbsp;21:54:57&nbsp;2008</span>
    <span class="description">xdaveg [...] gmail.com -  Correspondence added</span>
    <span class="time-taken"></span>    <span class="actions hidden"></span>
  </div>
    <div class="content">
      
<table>
  <tr>
    <td align="right" class="message-header-key">Subject:</td>
    <td class="message-header-value"> Re: [rt.cpan.org #32335] Problem when stacking calls to uplevel</td>
  </tr>
  <tr>
    <td align="right" class="message-header-key">Date:</td>
    <td class="message-header-value"> Tue, 15 Jan 2008 21:54:34 -0500</td>
  </tr>
  <tr>
    <td align="right" class="message-header-key">To:</td>
    <td class="message-header-value"> bug-Sub-Uplevel [...] rt.cpan.org</td>
  </tr>
  <tr>
    <td align="right" class="message-header-key">From:</td>
    <td class="message-header-value"> &#34;David Golden&#34; &lt;xdaveg [...] gmail.com&gt;</td>
  </tr>
</table>

<div class="messagebody">
<div class="message-stanza plain-text-white-space"><span
    class="message-stanza-folder closed"
    onclick="fold_message_stanza(this, 'Show\x20quoted\x20text', 'Hide\x20quoted\x20text');">Show quoted text</span><br /><div class="message-stanza closed">&gt; This exactly reflects the call stack I think we should have.
&gt; main 4-&gt; sub_a 3-&gt; &#40;uplevel&#40;1&#41; -&gt; sub_b&#41; 2-&gt; sub_c 1-&gt; &#40;uplevel&#40;3&#41; -&gt; sub_d&#41;
&gt; If I call uplevel 3 i want my context to be 3 levels above my caller
&gt; which is main in sub_d. Don&#39;t you think ?
</div>
You have to remember that each call to uplevel subtracts an extra
frame from the call stack -- i.e. uplevel always hides itself.  So you
call for 4 frames up from 2 separate uplevel calls -- or 6 levels up.
That takes you to the top context, which is main in your diagram above
as you say.

But caller&#40;&#41; from the top context returns undef -- i.e. the frame
*above* the context.

From sub_b, CORE::caller is the uplevel call.  With the effects of the
uplevel&#40;1&#41;, caller&#40;&#41; in sub_b  returns the caller of the context one
frame above the uplevel.  And the caller of sub_a is main.

So consider sub_d -- CORE::caller is the uplevel call.  Consider the
effects of different levels of upleveling on the value of caller&#40;&#41; in
sub_d:

uplevel&#40;1&#41; -- return caller&#40;&#41; of sub_c =&gt; sub_b
uplevel&#40;2&#41; -- return caller&#40;&#41; of sub_b =&gt; main &#40;as per the example above&#41;
uplevel&#40;3&#41; -- return caller&#40;&#41; of main =&gt; undef

David
</div></div>
    </div>
</div>
</div>
<div class="ticket-transaction message Correspond odd">
<div class="ticket-transaction">
  <div class="metadata">
    <span class="type">
      &nbsp;      
    </span>
    <span class="date">Wed&nbsp;Jan&nbsp;16&nbsp;09:04:33&nbsp;2008</span>
    <span class="description">abc159abc [...] hotmail.com -  Correspondence added</span>
    <span class="time-taken"></span>    <span class="actions hidden"></span>
  </div>
    <div class="content">
      
<table>
  <tr>
    <td align="right" class="message-header-key">From:</td>
    <td class="message-header-value"> abc159abc [...] hotmail.com</td>
  </tr>
</table>

<div class="messagebody">
<div class="message-stanza plain-text-white-space">On Tue Jan 15 21:54:57 2008, xdaveg@gmail.com wrote:
<span
    class="message-stanza-folder closed"
    onclick="fold_message_stanza(this, 'Show\x20quoted\x20text', 'Hide\x20quoted\x20text');">Show quoted text</span><br /><div class="message-stanza closed"><div class="message-stanza open">&gt; &gt; This exactly reflects the call stack I think we should have.
&gt; &gt; main 4-&gt; sub_a 3-&gt; &#40;uplevel&#40;1&#41; -&gt; sub_b&#41; 2-&gt; sub_c 1-&gt; &#40;uplevel&#40;3&#41;
</div>&gt; -&gt; sub_d&#41;
<div class="message-stanza open">&gt; &gt; If I call uplevel 3 i want my context to be 3 levels above my caller
&gt; &gt; which is main in sub_d. Don&#39;t you think ?
</div>&gt; 
&gt; You have to remember that each call to uplevel subtracts an extra
&gt; frame from the call stack -- i.e. uplevel always hides itself.  So you
&gt; call for 4 frames up from 2 separate uplevel calls -- or 6 levels up.
&gt; That takes you to the top context, which is main in your diagram above
&gt; as you say.
&gt; 
&gt; But caller&#40;&#41; from the top context returns undef -- i.e. the frame
&gt; *above* the context.
&gt; 
&gt; From sub_b, CORE::caller is the uplevel call.  With the effects of the
&gt; uplevel&#40;1&#41;, caller&#40;&#41; in sub_b  returns the caller of the context one
&gt; frame above the uplevel.  And the caller of sub_a is main.
&gt; 
&gt; So consider sub_d -- CORE::caller is the uplevel call.  Consider the
&gt; effects of different levels of upleveling on the value of caller&#40;&#41; in
&gt; sub_d:
&gt; 
&gt; uplevel&#40;1&#41; -- return caller&#40;&#41; of sub_c =&gt; sub_b
&gt; uplevel&#40;2&#41; -- return caller&#40;&#41; of sub_b =&gt; main &#40;as per the example
&gt; above&#41;
&gt; uplevel&#40;3&#41; -- return caller&#40;&#41; of main =&gt; undef
&gt; 
&gt; David
</div>
I understand that uplevel hides itself, that&#39;s why I grouped it with the
level where it is called in:
main 4-&gt; sub_a 3-&gt; &#40;uplevel&#40;1&#41; -&gt; sub_b&#41; 2-&gt; sub_c 1-&gt; &#40;uplevel&#40;3&#41; -&gt; sub_d&#41;

If I understood correctly, the point of uplevel if to fool the function
we call by making it believe that its context is not the one just above
but a certain number of frames above its normal context &#40;that&#39;s what is
written in the doc also&#41;.

The original library returns fine until the call in sub_c. If you debug
the lib you&#39;ll see that it is not only one level above main but
sometimes more which I think is wrong. We want the caller function to
believe it is n levels above the real caller so the real caller called
in sub_d would return sub_c. Then overridden one will return as if we
had called caller&#40;n&#41;. in sub_d case if we remove all reference to
uplevel caller&#40;3&#41; brings us in main.


So if in sub_a you call uplevel 1 you want to go one level above sub_a
which is main. Which means that calling caller&#40;&#41; in sub_b will return
main &#40;the current level above sub_a&#41;.
sub_b does not call uplevel so the caller&#40;&#41; of sub_c is the normal one
so it returns the level just above &#40;sub_b&#41;.
sub_c calls uplevel 3 so it wants sub_d to think that it is 3 levels
above sub_c &#40;1st level is sub_b, 2nd level is sub_a and 3rd level is main&#41;.

That way it is consistent with the caller function which returns the
contect n level above the immediate parent frame. Truly, If I had caller
caller with any number other than zero I would surely have had undef.

Does it makes sense ?
</div></div>
    </div>
</div>
</div>
<div class="ticket-transaction message Correspond even">
<div class="ticket-transaction">
  <div class="metadata">
    <span class="type">
      &nbsp;      
    </span>
    <span class="date">Wed&nbsp;Jan&nbsp;16&nbsp;20:30:40&nbsp;2008</span>
    <span class="description">dagolden [...] cpan.org -  Correspondence added</span>
    <span class="time-taken"></span>    <span class="actions hidden"></span>
  </div>
    <div class="content">
      
<table>
  <tr>
    <td align="right" class="message-header-key">Subject:</td>
    <td class="message-header-value"> Re: [rt.cpan.org #32335] Problem when stacking calls to uplevel</td>
  </tr>
  <tr>
    <td align="right" class="message-header-key">Date:</td>
    <td class="message-header-value"> Wed, 16 Jan 2008 20:30:22 -0500</td>
  </tr>
  <tr>
    <td align="right" class="message-header-key">To:</td>
    <td class="message-header-value"> bug-Sub-Uplevel [...] rt.cpan.org</td>
  </tr>
  <tr>
    <td align="right" class="message-header-key">From:</td>
    <td class="message-header-value"> &#34;David Golden&#34; &lt;dagolden [...] cpan.org&gt;</td>
  </tr>
</table>

<div class="messagebody">
<div class="message-stanza plain-text-white-space">On Jan 16, 2008 9:04 AM, vive via RT &lt;bug-Sub-Uplevel@rt.cpan.org&gt; wrote:
<span
    class="message-stanza-folder closed"
    onclick="fold_message_stanza(this, 'Show\x20quoted\x20text', 'Hide\x20quoted\x20text');">Show quoted text</span><br /><div class="message-stanza closed">&gt; The original library returns fine until the call in sub_c. If you debug
&gt; the lib you&#39;ll see that it is not only one level above main but
&gt; sometimes more which I think is wrong.
</div>
Can you give me an example?

<span
    class="message-stanza-folder closed"
    onclick="fold_message_stanza(this, 'Show\x20quoted\x20text', 'Hide\x20quoted\x20text');">Show quoted text</span><br /><div class="message-stanza closed">&gt; So if in sub_a you call uplevel 1 you want to go one level above sub_a
&gt; which is main. Which means that calling caller&#40;&#41; in sub_b will return
&gt; main &#40;the current level above sub_a&#41;.
&gt; sub_b does not call uplevel so the caller&#40;&#41; of sub_c is the normal one
&gt; so it returns the level just above &#40;sub_b&#41;.
&gt; sub_c calls uplevel 3 so it wants sub_d to think that it is 3 levels
&gt; above sub_c &#40;1st level is sub_b, 2nd level is sub_a and 3rd level is main&#41;.
</div>
What I think you are neglecting is that you&#39;ve already called uplevel
to invoke sub_b, so the level above sub_b is main, not sub_a.  &#40;As you
say above, caller&#40;&#41; in sub_b will return main&#41;  Until the uplevel
invocation of sub_b completes, sub_a is hidden from attempts to
examine the call stack.  So in your terms, the 2nd level is main and
the 3rd level is undef.

In your other example, without any uplevel calls, caller&#40;3&#41; in sub_d
returns main -- that&#39;s because the call stack looks like this:

&#40;4&#41; main -- caller&#40;0&#41; gives undef
&#40;3&#41; sub_a -- caller&#40;0&#41; gives main
&#40;2&#41; sub_b -- caller&#40;0&#41; gives sub_a
&#40;1&#41; sub_c -- caller&#40;0&#41; gives sub_b
&#40;0&#41; sub_d -- caller&#40;0&#41; gives sub_c

So caller&#40;3&#41; gives the same result as caller&#40;0&#41; in sub_a which is main.

If you called uplevel 3 in sub_c to invoke sub_d, but didn&#39;t call
uplevel in sub_a, you&#39;d get this, which sub_d appearing to be 3 frames
higher than the uplevel call:

&#40;1&#41; main -- caller&#40;0&#41; gives undef
&#40;0&#41; sub_d -- caller&#40;0&#41; gives main

But now if you start with uplevel 1 in sub_a to invoke sub_b, you
first get this:

&#40;1&#41; main -- caller&#40;0&#41; gives undef
&#40;0&#41; sub_b -- caller&#40;0&#41; gives main

Then, if you proceeded to sub_d *without* uplevel you would get this:

&#40;3&#41; main -- caller&#40;0&#41; gives undef
&#40;2&#41; sub_b -- caller&#40;0&#41; gives main
&#40;1&#41; sub_c -- caller&#40;0&#41; gives sub_b
&#40;0&#41; sub_d -- caller&#40;0&#41; gives sub_c

Then, if you add uplevel 3, sub_d appears to be three frames higher,
or just this:

&#40;0&#41; sub_d -- caller&#40;0&#41; gives undef

Does that help clarify?

David
</div></div>
    </div>
</div>
</div>
<div class="ticket-transaction message Correspond odd">
<div class="ticket-transaction">
  <div class="metadata">
    <span class="type">
      &nbsp;      
    </span>
    <span class="date">Thu&nbsp;Jan&nbsp;17&nbsp;12:06:41&nbsp;2008</span>
    <span class="description">abc159abc [...] hotmail.com -  Correspondence added</span>
    <span class="time-taken"></span>    <span class="actions hidden"></span>
  </div>
    <div class="content">
      
<table>
  <tr>
    <td align="right" class="message-header-key">From:</td>
    <td class="message-header-value"> abc159abc [...] hotmail.com</td>
  </tr>
</table>

<div class="messagebody">
<div class="message-stanza plain-text-white-space">On Wed Jan 16 20:30:40 2008, DAGOLDEN wrote:
<span
    class="message-stanza-folder closed"
    onclick="fold_message_stanza(this, 'Show\x20quoted\x20text', 'Hide\x20quoted\x20text');">Show quoted text</span><br /><div class="message-stanza closed">&gt; On Jan 16, 2008 9:04 AM, vive via RT &lt;bug-Sub-Uplevel@rt.cpan.org&gt;
&gt; wrote:
<div class="message-stanza open">&gt; &gt; The original library returns fine until the call in sub_c. If you
</div>&gt; debug
<div class="message-stanza open">&gt; &gt; the lib you&#39;ll see that it is not only one level above main but
&gt; &gt; sometimes more which I think is wrong.
</div>&gt; 
&gt; Can you give me an example?
&gt; 
<div class="message-stanza open">&gt; &gt; So if in sub_a you call uplevel 1 you want to go one level above
</div>&gt; sub_a
<div class="message-stanza open">&gt; &gt; which is main. Which means that calling caller&#40;&#41; in sub_b will
</div>&gt; return
<div class="message-stanza open">&gt; &gt; main &#40;the current level above sub_a&#41;.
&gt; &gt; sub_b does not call uplevel so the caller&#40;&#41; of sub_c is the normal
</div>&gt; one
<div class="message-stanza open">&gt; &gt; so it returns the level just above &#40;sub_b&#41;.
&gt; &gt; sub_c calls uplevel 3 so it wants sub_d to think that it is 3 levels
&gt; &gt; above sub_c &#40;1st level is sub_b, 2nd level is sub_a and 3rd level is
</div>&gt; main&#41;.
&gt; 
&gt; What I think you are neglecting is that you&#39;ve already called uplevel
&gt; to invoke sub_b, so the level above sub_b is main, not sub_a.  &#40;As you
&gt; say above, caller&#40;&#41; in sub_b will return main&#41;  Until the uplevel
&gt; invocation of sub_b completes, sub_a is hidden from attempts to
&gt; examine the call stack.  So in your terms, the 2nd level is main and
&gt; the 3rd level is undef.
&gt; 
&gt; In your other example, without any uplevel calls, caller&#40;3&#41; in sub_d
&gt; returns main -- that&#39;s because the call stack looks like this:
&gt; 
&gt; &#40;4&#41; main -- caller&#40;0&#41; gives undef
&gt; &#40;3&#41; sub_a -- caller&#40;0&#41; gives main
&gt; &#40;2&#41; sub_b -- caller&#40;0&#41; gives sub_a
&gt; &#40;1&#41; sub_c -- caller&#40;0&#41; gives sub_b
&gt; &#40;0&#41; sub_d -- caller&#40;0&#41; gives sub_c
&gt; 
&gt; So caller&#40;3&#41; gives the same result as caller&#40;0&#41; in sub_a which is
&gt; main.
&gt; 
&gt; If you called uplevel 3 in sub_c to invoke sub_d, but didn&#39;t call
&gt; uplevel in sub_a, you&#39;d get this, which sub_d appearing to be 3 frames
&gt; higher than the uplevel call:
&gt; 
&gt; &#40;1&#41; main -- caller&#40;0&#41; gives undef
&gt; &#40;0&#41; sub_d -- caller&#40;0&#41; gives main
&gt; 
&gt; But now if you start with uplevel 1 in sub_a to invoke sub_b, you
&gt; first get this:
&gt; 
&gt; &#40;1&#41; main -- caller&#40;0&#41; gives undef
&gt; &#40;0&#41; sub_b -- caller&#40;0&#41; gives main
&gt; 
&gt; Then, if you proceeded to sub_d *without* uplevel you would get this:
&gt; 
&gt; &#40;3&#41; main -- caller&#40;0&#41; gives undef
&gt; &#40;2&#41; sub_b -- caller&#40;0&#41; gives main
&gt; &#40;1&#41; sub_c -- caller&#40;0&#41; gives sub_b
&gt; &#40;0&#41; sub_d -- caller&#40;0&#41; gives sub_c
&gt; 
&gt; Then, if you add uplevel 3, sub_d appears to be three frames higher,
&gt; or just this:
&gt; 
&gt; &#40;0&#41; sub_d -- caller&#40;0&#41; gives undef
&gt; 
&gt; Does that help clarify?
&gt; 
&gt; David
</div>


OMG, I just saw I am completely stupid.
Actually I was more focused on what I wanted to get than what you wanted
to give in your package :&#41;

I wanted to change the context relatively to the original call stack
where you propose to change the context in the call stack after the
modifications operated by the previous call to uplevel.

Sorry to have wasted your time ...

Maybe one comment. I know that if you call caller &#40;the original one&#41;
with a stack frame number higher than the highest one it returns undef.
However in uplevel we want to change the context of a function call and
I don&#39;t think it is valid, event if it is fake, to say that the context
is undef &#40;caller in sub_d&#41;. So I suggest either you force the level to
main if it is to big or you just don&#39;t execute the function in that case.
</div></div>
    </div>
</div>
</div>
<div class="ticket-transaction message Correspond even">
<div class="ticket-transaction">
  <div class="metadata">
    <span class="type">
      &nbsp;      
    </span>
    <span class="date">Thu&nbsp;Jan&nbsp;17&nbsp;13:32:32&nbsp;2008</span>
    <span class="description">dagolden [...] cpan.org -  Correspondence added</span>
    <span class="time-taken"></span>    <span class="actions hidden"></span>
  </div>
    <div class="content">
      
<table>
  <tr>
    <td align="right" class="message-header-key">Subject:</td>
    <td class="message-header-value"> Re: [rt.cpan.org #32335] Problem when stacking calls to uplevel</td>
  </tr>
  <tr>
    <td align="right" class="message-header-key">Date:</td>
    <td class="message-header-value"> Thu, 17 Jan 2008 13:32:02 -0500</td>
  </tr>
  <tr>
    <td align="right" class="message-header-key">To:</td>
    <td class="message-header-value"> bug-Sub-Uplevel [...] rt.cpan.org</td>
  </tr>
  <tr>
    <td align="right" class="message-header-key">From:</td>
    <td class="message-header-value"> &#34;David Golden&#34; &lt;dagolden [...] cpan.org&gt;</td>
  </tr>
</table>

<div class="messagebody">
<div class="message-stanza plain-text-white-space">On Jan 17, 2008 12:06 PM, vive via RT &lt;bug-Sub-Uplevel@rt.cpan.org&gt; wrote:
<span
    class="message-stanza-folder closed"
    onclick="fold_message_stanza(this, 'Show\x20quoted\x20text', 'Hide\x20quoted\x20text');">Show quoted text</span><br /><div class="message-stanza closed">&gt; I wanted to change the context relatively to the original call stack
&gt; where you propose to change the context in the call stack after the
&gt; modifications operated by the previous call to uplevel.
&gt;
&gt; Sorry to have wasted your time ...
</div>
Not at all!  Uplevel is a really weird, hacky thing.  It&#39;s helpful to
me to work through the edge cases from time to time and make sure it&#39;s
doing what I think it should be doing.

<span
    class="message-stanza-folder closed"
    onclick="fold_message_stanza(this, 'Show\x20quoted\x20text', 'Hide\x20quoted\x20text');">Show quoted text</span><br /><div class="message-stanza closed">&gt; Maybe one comment. I know that if you call caller &#40;the original one&#41;
&gt; with a stack frame number higher than the highest one it returns undef.
&gt; However in uplevel we want to change the context of a function call and
&gt; I don&#39;t think it is valid, event if it is fake, to say that the context
&gt; is undef &#40;caller in sub_d&#41;. So I suggest either you force the level to
&gt; main if it is to big or you just don&#39;t execute the function in that case.
</div>
There&#39;s no reason someone couldn&#39;t uplevel a function from main -- to
make a function look like it&#39;s running at the top level.  So I&#39;m
reluctant to make the behavior change at some levels and not others.

However, I am inclined to issue a warning if the uplevel would take
someone *beyond* main -- the stack should never look negative.  Empty
is OK, but not negative.

David
</div></div>
    </div>
</div>
</div>
<div class="ticket-transaction message Correspond odd">
<div class="ticket-transaction">
  <div class="metadata">
    <span class="type">
      &nbsp;      
    </span>
    <span class="date">Thu&nbsp;Jan&nbsp;17&nbsp;15:00:29&nbsp;2008</span>
    <span class="description">abc159abc [...] hotmail.com -  Correspondence added</span>
    <span class="time-taken"></span>    <span class="actions hidden"></span>
  </div>
    <div class="content">
      
<table>
  <tr>
    <td align="right" class="message-header-key">From:</td>
    <td class="message-header-value"> abc159abc [...] hotmail.com</td>
  </tr>
</table>

<div class="messagebody">
<div class="message-stanza plain-text-white-space">On Thu Jan 17 13:32:32 2008, DAGOLDEN wrote:
<span
    class="message-stanza-folder closed"
    onclick="fold_message_stanza(this, 'Show\x20quoted\x20text', 'Hide\x20quoted\x20text');">Show quoted text</span><br /><div class="message-stanza closed">&gt; On Jan 17, 2008 12:06 PM, vive via RT &lt;bug-Sub-Uplevel@rt.cpan.org&gt; wrote:
<div class="message-stanza open">&gt; &gt; I wanted to change the context relatively to the original call stack
&gt; &gt; where you propose to change the context in the call stack after the
&gt; &gt; modifications operated by the previous call to uplevel.
&gt; &gt;
&gt; &gt; Sorry to have wasted your time ...
</div>&gt; 
&gt; Not at all!  Uplevel is a really weird, hacky thing.  It&#39;s helpful to
&gt; me to work through the edge cases from time to time and make sure it&#39;s
&gt; doing what I think it should be doing.
&gt; 
<div class="message-stanza open">&gt; &gt; Maybe one comment. I know that if you call caller &#40;the original one&#41;
&gt; &gt; with a stack frame number higher than the highest one it returns undef.
&gt; &gt; However in uplevel we want to change the context of a function call and
&gt; &gt; I don&#39;t think it is valid, event if it is fake, to say that the context
&gt; &gt; is undef &#40;caller in sub_d&#41;. So I suggest either you force the level to
&gt; &gt; main if it is to big or you just don&#39;t execute the function in that
</div></div>case.
<span
    class="message-stanza-folder closed"
    onclick="fold_message_stanza(this, 'Show\x20quoted\x20text', 'Hide\x20quoted\x20text');">Show quoted text</span><br /><div class="message-stanza closed">&gt; 
&gt; There&#39;s no reason someone couldn&#39;t uplevel a function from main -- to
&gt; make a function look like it&#39;s running at the top level.  So I&#39;m
&gt; reluctant to make the behavior change at some levels and not others.
&gt; 
&gt; However, I am inclined to issue a warning if the uplevel would take
&gt; someone *beyond* main -- the stack should never look negative.  Empty
&gt; is OK, but not negative.
&gt; 
&gt; David
</div>
Ok, it&#39;s fine for me.
The warning is really as you wish. I&#39;ll just keep my little modification
locally and test for undef and it should be ok.

Thank you!
</div></div>
    </div>
</div>
</div>
<div class="ticket-transaction message Correspond even">
<div class="ticket-transaction">
  <div class="metadata">
    <span class="type">
      &nbsp;      
    </span>
    <span class="date">Thu&nbsp;Feb&nbsp;21&nbsp;14:59:46&nbsp;2008</span>
    <span class="description">dagolden [...] cpan.org -  Correspondence added</span>
    <span class="time-taken"></span>    <span class="actions hidden"></span>
  </div>
    <div class="content">
      

<div class="messagebody">
<div class="message-stanza plain-text-white-space">Patched repository to include a warning if uplevel call is for more than
the stack depth.  Will be in the next release.

David
</div></div>
    </div>
</div>
</div>
<div class="ticket-transaction basics Status odd">
<div class="ticket-transaction">
  <div class="metadata">
    <span class="type">
      &nbsp;      
    </span>
    <span class="date">Thu&nbsp;Feb&nbsp;21&nbsp;14:59:48&nbsp;2008</span>
    <span class="description">dagolden [...] cpan.org -  Status changed from &#39;open&#39; to &#39;resolved&#39;</span>
    <span class="time-taken"></span>    <span class="actions hidden"></span>
  </div>
    <div class="content">
    </div>
</div>
</div>
</div>
    <hr class="clear" />
  </div>
</div>




</div>
 


  <hr class="clear" />
</div>
</body>
</html>
