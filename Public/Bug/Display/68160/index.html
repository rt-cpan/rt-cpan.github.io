<!DOCTYPE html>

<html lang="en">
  <head>
    <title>Bug #68160 for Net-Stomp: Improvements in the face of broker disconnects</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <!-- The X-UA-Compatible <meta> tag above must be very early in <head> -->

    <script>
if (window.top !== window.self) {
    document.write = "";

    window.top.location = window.self.location;

    setTimeout(function(){
        document.body.innerHTML = "";
    }, 1);

    window.self.onload = function(){
        document.body.innerHTML = "";
    };
}
</script>



<link rel="shortcut icon" href="/NoAuth/images/favicon.png" type="image/png" />
<link rel="stylesheet" href="/NoAuth/css/aileron-squished-00f758259152f8b6670ee485f462e6b8.css" type="text/css" media="all" />
<link rel="stylesheet" href="/NoAuth/css/print.css" type="text/css" media="print" />




<script type="text/javascript" src="/NoAuth/js/squished-42167f2409ce368da2d31038e5cb2a57.js"></script>

<script type="text/javascript"><!--
	jQuery( loadTitleBoxStates );

--></script>


<!--[if lt IE 8]>
<link rel="stylesheet" href="/NoAuth/css/aileron/msie.css" type="text/css" media="all" />
<![endif]-->
<!--[if lt IE 7]>
<link rel="stylesheet" href="/NoAuth/css/aileron/msie6.css" type="text/css" media="all" />
<![endif]-->
<script type="text/javascript">
jQuery(document).ready(function(){
    jQuery.fn.supersubs.defaults = {
        maxWidth: 30,
        extraWidth: 2
    };

    jQuery("#app-nav.toplevel").addClass('sf-menu sf-js-enabled sf-shadow').supersubs().superfish({ speed: 'fast' });
    jQuery("#page-menu.toplevel").addClass('sf-menu sf-js-enabled').supersubs().superfish({ dropShadows: false, speed: 'fast' }).supposition();
});
</script>


<!-- Site CSS from theme editor -->
<style type="text/css" media="all" id="sitecss">
</style>

<meta name="google-site-verification" content="kD3-uEJK1AkTqaC-rckcSt_HPkAj674DPPuEN6i-y0g" />

</head>
  <body class="aileron sidebyside" id="comp-Public-Bug-Display">

<div id="logo">
<a href="/"><img
    src="/NoAuth/images/cpan.png"
    alt="CPAN"
    width="181"
    height="38" /></a>
    <span class="rtname">RT for rt.cpan.org</span>
</div>


<div id="quickbar">
  <div id="quick-personal">
    <span class="hide"><a href="#skipnav">Skip Menu</a> | </span>
</div>

</div>
<div id="header"><h1>Bug #68160 for Net-Stomp: Improvements in the face of broker disconnects</h1></div>



<div id="page-navigation"><ul id="page-menu" class="toplevel">
 <li id="li-page-active_bugs"><a id="page-active_bugs" class="menu-item " href="/Public/Dist/Net-Stomp/Active/">Active bugs</a></li>
 <li id="li-page-resolved_bugs"><a id="page-resolved_bugs" class="menu-item " href="/Public/Dist/Net-Stomp/Resolved/">Resolved bugs</a></li>
 <li id="li-page-rejected_bugs"><a id="page-rejected_bugs" class="menu-item " href="/Public/Dist/Net-Stomp/Rejected/">Rejected bugs</a></li>
 <li id="li-page-report"><a id="page-report" class="menu-item " href="/Public/Dist/Net-Stomp/Active/"></a></li>
</ul></div>
<div id="topactions">



</div>
<div id="body">


<a name="skipnav" id="skipnav" accesskey="8"></a>





<p>This queue is for tickets about the <a href="https://metacpan.org/release/Net-Stomp">Net-Stomp CPAN distribution</a>.</p>





<div class="">
  <div class="titlebox" id="">
  <div class="titlebox-title">
    <span class="widget"><a href="#" onclick="return rollup('TitleBox\x2D\x2D\x5FPublic\x5FBug\x5FDisplay\x5Fhtml\x2D\x2D\x2D\x2D\x2D\x2DUmVwb3J0IGluZm9ybWF0aW9u\x2D\x2D\x2D0');" title="Toggle visibility"></a></span>
    <span class="left">Report information</span>
    <span class="right-empty">		    </span>
  </div>
  <div class="titlebox-content " id="TitleBox--_Public_Bug_Display_html------UmVwb3J0IGluZm9ybWF0aW9u---0">


<table width="100%" class="ticket-summary">
<tr>
  <td valign="top" class="boxcontainer">
    <div class="ticket-info-basics">
  <div class="titlebox ticket-info-basics " id="">
  <div class="titlebox-title">
    <span class="widget"><a href="#" onclick="return rollup('TitleBox\x2D\x2D\x5FPublic\x5FBug\x5FDisplay\x5Fhtml\x2D\x2Dticket\x2Dinfo\x2Dbasics\x2D\x2D\x2D\x2DVGhlIEJhc2ljcw\x5F\x5F\x2D\x2D\x2D0');" title="Toggle visibility"></a></span>
    <span class="left">The Basics</span>
    <span class="right-empty">		    </span>
  </div>
  <div class="titlebox-content " id="TitleBox--_Public_Bug_Display_html--ticket-info-basics----VGhlIEJhc2ljcw__---0">


        <table>
  <tr class="id">
    <td class="label">Id:</td>
    <td class="value">68160</td>
  </tr>
  <tr class="status">
    <td class="label">Status:</td>
    <td class="value">resolved</td>
  </tr>
  <tr class="priority">
    <td class="label">Priority:</td>
    <td class="value">0/
</td>
  </tr>
  <tr class="queue">
    <td class="label">Queue:</td>
    <td class="value"><a href="/Public/Dist/Net-Stomp/Active/">Net-Stomp</a>
</td>
  </tr>
</table>

        <hr class="clear" />
  </div>
</div>




</div>


    <div class="ticket-info-people">
  <div class="titlebox ticket-info-people " id="">
  <div class="titlebox-title">
    <span class="widget"><a href="#" onclick="return rollup('TitleBox\x2D\x2D\x5FPublic\x5FBug\x5FDisplay\x5Fhtml\x2D\x2Dticket\x2Dinfo\x2Dpeople\x2D\x2D\x2D\x2DUGVvcGxl\x2D\x2D\x2D0');" title="Toggle visibility"></a></span>
    <span class="left">People</span>
    <span class="right-empty">		    </span>
  </div>
  <div class="titlebox-content " id="TitleBox--_Public_Bug_Display_html--ticket-info-people----UGVvcGxl---0">


        <table>
  <tr>
    <td class="label">Owner:</td>
    <td class="value">Nobody in particular
    
    </td>
  </tr>
  <tr>
    <td class="labeltop">Requestors:</td>
    <td class="value">
mstemm [...] cloudmark.com

<br />

</td>
  </tr>
  <tr>
    <td class="labeltop">Cc:</td>
    <td class="value">

</td>
  </tr>
  <tr>
    <td class="labeltop">AdminCc:</td>
    <td class="value">

</td>
  </tr>
</table>

        <hr class="clear" />
  </div>
</div>




</div>



  </td>
  <td valign="top" class="boxcontainer">
    
    <div class="ticket-info-cfs">
  <div class="titlebox ticket-info-cfs " id="">
  <div class="titlebox-title">
    <span class="widget"><a href="#" onclick="return rollup('TitleBox\x2D\x2D\x5FPublic\x5FBug\x5FDisplay\x5Fhtml\x2D\x2Dticket\x2Dinfo\x2Dcfs\x2D\x2D\x2D\x2DQnVnIEluZm9ybWF0aW9u\x2D\x2D\x2D0');" title="Toggle visibility"></a></span>
    <span class="left">Bug Information</span>
    <span class="right-empty">		    </span>
  </div>
  <div class="titlebox-content " id="TitleBox--_Public_Bug_Display_html--ticket-info-cfs----QnVnIEluZm9ybWF0aW9u---0">

 
        <table>
  <tr id="CF-1-ShowRow">
    <td class="label">Severity:</td>
    <td class="value">
Normal    </td>
  </tr>
  <tr id="CF-41200-ShowRow">
    <td class="label">Broken in:</td>
    <td class="value">
0.41    </td>
  </tr>
  <tr id="CF-41201-ShowRow">
    <td class="label">Fixed in:</td>
    <td class="value">
<i>(no value)</i>
    </td>
  </tr>
</table>


        <hr class="clear" />
  </div>
</div>




</div>


    
</div>




</div>







  </td>
</tr>
</table>

    <hr class="clear" />
  </div>
</div>




</div>


<br />


<div class="history">
<div class="titlebox" id="">
  <div class="titlebox-title">
    <span class="widget"><a href="#" onclick="return rollup('TitleBox\x2D\x2D\x5FPublic\x5FBug\x5FDisplay\x5Fhtml\x2D\x2D\x2D\x2D\x2D\x2DSGlzdG9yeQ\x5F\x5F\x2D\x2D\x2D0');" title="Toggle visibility"></a></span>
    <span class="left">History</span>
    <span class="right">		<a href="#" data-direction="open" onclick="return toggle_all_folds(this, 'Show\x20all\x20quoted\x20text', 'Hide\x20all\x20quoted\x20text');">Show all quoted text</a>    </span>
  </div>
  <div class="titlebox-content " id="TitleBox--_Public_Bug_Display_html------SGlzdG9yeQ__---0">


<div id="ticket-history">
<div class="ticket-transaction message Create odd">
<div class="ticket-transaction">
  <div class="metadata">
    <span class="type">
      &nbsp;      
    </span>
    <span class="date">Thu&nbsp;May&nbsp;12&nbsp;20:32:31&nbsp;2011</span>
    <span class="description">mstemm [...] cloudmark.com -  Ticket created</span>
    <span class="time-taken"></span>    <span class="actions hidden"></span>
  </div>
    <div class="content">
      
<table>
  <tr>
    <td align="right" class="message-header-key">Subject:</td>
    <td class="message-header-value"> Improvements in the face of broker disconnects</td>
  </tr>
</table>
<div class="messageattachments">

<div class="messagebody">
<div class="message-stanza plain-text-white-space">Hi, thanks for writing the useful Net::Stomp library. We at Cloudmark
have made some improvements to the library to gracefully handle
sending/receiving messages in the face of brokers going down and coming
back up.

I&#39;ve attached a summary of the changes and a patch file based on the
0.41 tarball that incorporates the changes.

If you have further improvements or refinements you&#39;d like to see, we&#39;d
be happy to make them. Otherwise, enjoy the changes.
</div></div>
<table>
  <tr>
    <td align="right" class="message-header-key">Subject:</td>
    <td class="message-header-value"> 01-cloudmark-disconnect-improvements-README.txt</td>
  </tr>
</table>

<div class="messagebody">
<div class="message-stanza plain-text-white-space">We made the following improvements to the Net::Stomp library to be
more robust and return more concrete errors in the face of broker
disconnects:

 - Many functions didn&#39;t have a clearly documented return
   value. Updated all functions to have a return value. Generally 1
   implies success and 0 implies failure. See the perl docs for more
   details on the return values from each function.

 - Add a new option to the constructor &#39;ignore_sigpipe&#39;. If provided
   and set to 1, it will ignore SIGPIPE so writes to closed sockets
   don&#39;t result in killing the process.

 - Add a new option to the constructor &#39;reconnect_attempts&#39;. If
   provided and set to non-zero, when sending/receiving messages, the
   library will only attempt to reconnect this many times before
   giving up and returning an error. By default, this is set to 0,
   which retains the old behavior of attempting to reconnect forever
   on any failure.

 - In connect&#40;&#41;, verify that a response frame was actually read and
   actually had a CONNECTED response.

 - Whenever calling functions like send/send_frame internally, check
   the return value and stop if the action does not succeed.

 - Add new functions send_with_receipt/send_frame_with_receipt that
   send messages with a receipt header, which forces the server to
   reply with a RECEIPT message.

 - Modify higher-level functions like subscribe/send_transactional to
   always use send_with_receipt/send_frame_with_receipt, to avoid
   problems where an ERROR response from a message that would
   otherwise not return anything ends up being accidentally read as
   the response to a later message.

 - Monitor the value of syswrite when writing messages to the socket
   to ensure that all of the message was written.


</div></div>
<table>
  <tr>
    <td align="right" class="message-header-key">Subject:</td>
    <td class="message-header-value"> 01-cloudmark-disconnect-improvements.patch</td>
  </tr>
</table>

<div class="messagebody">
<div class="message-stanza plain-text-white-space">Index: lib/Net/Stomp.pm
===================================================================
13c13
&lt;     ssl_options subscriptions _connect_headers bufsize
---
&gt;     ssl_options subscriptions _connect_headers bufsize reconnect_attempts ignore_sigpipe
29a30,40
&gt;     # Make the number of reconnection attempts per send/receive
&gt;     # attempt configurable. The default is 0 &#40;retry forever&#41;.
&gt;     if &#40;! defined $self-&gt;reconnect_attempts&#41; {
&gt;         $self-&gt;reconnect_attempts&#40;0&#41;;
&gt;     }
&gt; 
&gt;     # If configured to do so, ignore SIGPIPE.
&gt;     if &#40;defined $self-&gt;ignore_sigpipe &#38;&#38; $self-&gt;ignore_sigpipe == 1&#41; {
&gt;         $SIG{PIPE} = &#39;IGNORE&#39;;
&gt;     }
&gt; 
111c122
&lt;     my &#40; $self, $conf &#41; = @_;
---
&gt;     my &#40; $self, $conf, $response_frame_ref &#41; = @_;
115c126,129
&lt;     $self-&gt;send_frame&#40;$frame&#41;;
---
&gt;     if &#40;$self-&gt;send_frame&#40;$frame&#41; == 0&#41; {
&gt;         return undef;
&gt;     }
&gt; 
117a132,148
&gt;     # If response_frame_ref is defined, set it to the response.
&gt;     if &#40;defined $response_frame_ref&#41; {
&gt;         $$response_frame_ref = $frame;
&gt;     }
&gt; 
&gt;     # If receive_frame didn&#39;t actually return anything, we can return
&gt;     # failure immediately.
&gt;     if &#40;! defined $frame&#41; {
&gt;         return 0;
&gt;     }
&gt; 
&gt;     # If receive_frame didn&#39;t return a CONNECTED response, return
&gt;     # failure.
&gt;     if &#40;$frame-&gt;command ne &#34;CONNECTED&#34;&#41; {
&gt;         return 0;
&gt;     }
&gt; 
123c154
&lt;     return $frame;
---
&gt;     return 1;
128a160,161
&gt; 
&gt;     # Note: ignoring result from send_frame.
135a169
&gt; 
140,142c174,175
&lt;     while &#40;$@&#41; {
&lt;         sleep&#40;5&#41;;
&lt;         eval { $self-&gt;_get_connection };
---
&gt;     if &#40;$@&#41; {
&gt;         return;
144c177,182
&lt;     $self-&gt;connect&#40; $self-&gt;_connect_headers &#41;;
---
&gt; 
&gt;     if &#40;$self-&gt;connect&#40; $self-&gt;_connect_headers &#41; == 0&#41; {
&gt;         $self-&gt;socket-&gt;close;
&gt;         return;
&gt;     }
&gt; 
146c184,187
&lt;         $self-&gt;subscribe&#40;$self-&gt;subscriptions-&gt;{$sub}&#41;;
---
&gt;         if &#40;$self-&gt;subscribe&#40;$self-&gt;subscriptions-&gt;{$sub}&#41; == 0&#41; {
&gt;             $self-&gt;socket-&gt;close;
&gt;             return;
&gt;         }
173c214,225
&lt;     $self-&gt;send_frame&#40;$frame&#41;;
---
&gt;     return $self-&gt;send_frame&#40;$frame&#41;;
&gt; }
&gt; 
&gt; sub send_with_receipt {
&gt;     my &#40;$self, $conf, $send_response_ref&#41; = @_;
&gt; 
&gt;     my $body = $conf-&gt;{body};
&gt;     delete $conf-&gt;{body};
&gt;     my $frame = Net::Stomp::Frame-&gt;new&#40;
&gt;         { command =&gt; &#39;SEND&#39;, headers =&gt; $conf, body =&gt; $body } &#41;;
&gt; 
&gt;     return $self-&gt;send_frame_with_receipt&#40;$frame, $send_response_ref&#41;;
180a233,239
&gt;     # Note: as this function depends on a sequence of messages, any of
&gt;     # which *may* return an error from the broker on failure, we send
&gt;     # all messages using send_with_receipt/send_frame_with_receipt. If
&gt;     # we didn&#39;t include receipt ids, one of these messages could
&gt;     # return 0 or 1 responses back, which throws off the pipeline for
&gt;     # subsequent messages or subsequent calls to send_transactional.
&gt; 
182a242
&gt; 
187c247,249
&lt;     $self-&gt;send_frame&#40;$begin_frame&#41;;
---
&gt;     if &#40;$self-&gt;send_frame_with_receipt&#40;$begin_frame&#41; == 0&#41; {
&gt;         return 0;
&gt;     }
190,200d251
&lt;     my $receipt_id = $self-&gt;_get_next_transaction;
&lt;     $conf-&gt;{receipt} = $receipt_id;
&lt;     my $message_frame = Net::Stomp::Frame-&gt;new&#40;
&lt;         { command =&gt; &#39;SEND&#39;, headers =&gt; $conf, body =&gt; $body } &#41;;
&lt;     $self-&gt;send_frame&#40;$message_frame&#41;;
&lt; 
&lt;     # check the receipt
&lt;     my $receipt_frame = $self-&gt;receive_frame;
&lt;     if &#40;   $receipt_frame-&gt;command eq &#39;RECEIPT&#39;
&lt;         &#38;&#38; $receipt_frame-&gt;headers-&gt;{&#39;receipt-id&#39;} eq $receipt_id &#41;
&lt;     {
202,209c253,254
&lt;         # success, commit the transaction
&lt;         my $frame_commit = Net::Stomp::Frame-&gt;new&#40;
&lt;             {   command =&gt; &#39;COMMIT&#39;,
&lt;                 headers =&gt; { transaction =&gt; $transaction_id }
&lt;             }
&lt;         &#41;;
&lt;         return $self-&gt;send_frame&#40;$frame_commit&#41;;
&lt;     } else {
---
&gt;     if &#40;$self-&gt;send_with_receipt&#40;$conf, undef&#41; == 0&#41; {
&gt;         # The send wasn&#39;t acknowledged. ABORT the transaction.
211d255
&lt;         # some failure, abort transaction
217c261,264
&lt;         $self-&gt;send_frame&#40;$frame_abort&#41;;
---
&gt; 
&gt;         # Note: ignoring result from send_frame_with_receipt, as we&#39;re
&gt;         # going to return an error anyway.
&gt;         $self-&gt;send_frame_with_receipt&#40;$frame_abort&#41;;
219a267,274
&gt; 
&gt;     # success, commit the transaction
&gt;     my $frame_commit = Net::Stomp::Frame-&gt;new&#40;
&gt;         {   command =&gt; &#39;COMMIT&#39;,
&gt;             headers =&gt; { transaction =&gt; $transaction_id }
&gt;         }
&gt;         &#41;;
&gt;     return $self-&gt;send_frame_with_receipt&#40;$frame_commit&#41;;
226c281,283
&lt;     $self-&gt;send_frame&#40;$frame&#41;;
---
&gt;     if &#40;$self-&gt;send_frame_with_receipt&#40;$frame&#41; == 0&#41; {
&gt;         return 0;
&gt;     }
228a286,287
&gt; 
&gt;     return 1;
235c294,296
&lt;     $self-&gt;send_frame&#40;$frame&#41;;
---
&gt;     if &#40;$self-&gt;send_frame_with_receipt&#40;$frame&#41; == 0&#41; {
&gt;         return 0;
&gt;     }
237a299,300
&gt; 
&gt;     return 1;
245c308
&lt;     $self-&gt;send_frame&#40;$frame&#41;;
---
&gt;     return $self-&gt;send_frame_with_receipt&#40;$frame&#41;;
251,254c314,331
&lt;     #     warn &#34;send [&#34; . $frame-&gt;as_string . &#34;]\n&#34;;
&lt;     $self-&gt;socket-&gt;syswrite&#40; $frame-&gt;as_string &#41;;
&lt;     my $connected = $self-&gt;socket-&gt;connected;
&lt;     unless &#40;defined $connected&#41; {
---
&gt;     # Try up to reconnect_attempts times to send the frame &#40;or
&gt;     # forever, if reconnect_attempts is 0&#41;.
&gt; 
&gt;     for&#40;my $attempts = $self-&gt;reconnect_attempts;
&gt;         $self-&gt;reconnect_attempts == 0 || $attempts &gt; 0;
&gt;         $attempts--&#41; {
&gt; 
&gt; #       warn &#34;send [&#34; . $frame-&gt;as_string . &#34;]\n&#34;;
&gt;         my $written = $self-&gt;socket-&gt;syswrite&#40; $frame-&gt;as_string &#41;;
&gt; 
&gt;         if &#40;defined $written &#38;&#38; $written == length&#40;$frame-&gt;as_string&#41;&#41; {
&gt;             return 1;
&gt;         }
&gt; 
&gt;         # If here, we couldn&#39;t send the frame, which was either due to a
&gt;         # short write or due to an inability to write at all. In either
&gt;         # case, try to reconnect.
&gt;         sleep&#40;5&#41;;
256d332
&lt;         $self-&gt;send_frame&#40;$frame&#41;;
257a334,371
&gt; 
&gt;     # If here, we couldn&#39;t send. Give up.
&gt;     return 0;
&gt; }
&gt; 
&gt; sub send_frame_with_receipt {
&gt;     my &#40;$self, $frame, $send_response_ref&#41; = @_;
&gt; 
&gt;     if &#40;defined $send_response_ref&#41; {
&gt;         $$send_response_ref = undef;
&gt;     }
&gt; 
&gt;     my $receipt_id = $self-&gt;_get_next_transaction;
&gt;     $frame-&gt;headers-&gt;{receipt} = $receipt_id;
&gt; 
&gt;     if &#40;$self-&gt;send_frame&#40;$frame&#41; == 0&#41; {
&gt;         return 0;
&gt;     }
&gt; 
&gt;     # Read the response, which will either be a RECEIPT or some
&gt;     # ERROR. Always wait up to 30 seconds for a response.
&gt; 
&gt;     my $response = $self-&gt;receive_frame&#40;{timeout =&gt; 30}&#41;;
&gt; 
&gt;     if &#40;! defined $response&#41; {
&gt;         return 0;
&gt;     }
&gt; 
&gt;     if &#40;defined $send_response_ref&#41; {
&gt;         $$send_response_ref = $response;
&gt;     }
&gt; 
&gt;     if &#40;$response-&gt;command ne &#39;RECEIPT&#39; ||
&gt;         $response-&gt;headers-&gt;{&#39;receipt-id&#39;} ne $receipt_id&#41; {
&gt;         return 0;
&gt;     }
&gt; 
&gt;     return 1;
339c453,460
&lt;     unless &#40;defined $connected&#41; {
---
&gt; 
&gt;     # Try up to reconnect_attempts times to connect &#40;or
&gt;     # forever, if reconnect_attempts is 0&#41;.
&gt;     for&#40;my $attempts = $self-&gt;reconnect_attempts;
&gt;         &#40;! defined $connected &#38;&#38; &#40;$self-&gt;reconnect_attempts == 0 || $attempts &gt; 0&#41;&#41;;
&gt;         $attempts--&#41; {
&gt; 
&gt;         sleep&#40;5&#41;;
340a462
&gt;         $connected = $self-&gt;socket-&gt;connected;
342a465,467
&gt;     # If we still can&#39;t connect, give up.
&gt;     return undef if &#40;! defined $connected&#41;;
&gt; 
467a593,615
&gt; By default, if the broker goes away, socket writes could result in a
&gt; SIGPIPE signal, terminating the process. If you pass the option
&gt; ignore_sigpipe to new with value 1, the library will set up a signal
&gt; handler for SIGPIPE that ignores the signal:
&gt; 
&gt;   my $stomp = Net::Stomp-&gt;new&#40; {
&gt;     hostname             =&gt; &#39;localhost&#39;,
&gt;     port                 =&gt; &#39;61612&#39;,
&gt;     ignore_sigpipe       =&gt;  1
&gt;   } &#41;;
&gt; 
&gt; By default, when sending/receiving a message, if the library is not
&gt; currently connected to the broker, it will attempt to reconnect
&gt; &#40;forever&#41; before sending/receiving the message. If you want to limit
&gt; the number of reconnection attempts that occur before giving up and
&gt; returning an error, pass the option reconnect_attempts in new&#40;&#41;:
&gt; 
&gt;   my $stomp = Net::Stomp-&gt;new&#40; {
&gt;     hostname             =&gt; &#39;localhost&#39;,
&gt;     port                 =&gt; &#39;61612&#39;,
&gt;     reconnect_attempts   =&gt; 5
&gt;   } &#41;;
&gt; 
481,482c629,631
&lt; This connects to the Stomp server. You may pass in a C&lt;login&gt; and
&lt; C&lt;passcode&gt; options.
---
&gt; This connects to the Stomp server. The first argument is a hash of
&gt; headers to include along with the CONNECT message. In that hash, you
&gt; may pass in a C&lt;login&gt; and C&lt;passcode&gt; options.
488c637,644
&lt;   $stomp-&gt;connect&#40; { login =&gt; &#39;hello&#39;, passcode =&gt; &#39;there&#39; } &#41;;
---
&gt; The second &#40;optional&#41; argument is a scalar reference which passes back
&gt; the response from the CONNECT message. It will either be set to undef
&gt; if the connect failed, or a Net::Stomp::Frame object containing the
&gt; response.
&gt; 
&gt;   $stomp-&gt;connect&#40; { login =&gt; &#39;hello&#39;, passcode =&gt; &#39;there&#39; }, \$connect_response &#41;;
&gt; 
&gt; connect&#40;&#41; returns 1 on success, 0 on failure.
498c654,678
&lt; To send a BytesMessage, you should set the field &#39;bytes_message&#39; to 1.
---
&gt; To send a BytesMessage, you should set the field &#39;bytes_message&#39; to
&gt; 1.
&gt; 
&gt; This function returns 1 on success, 0 on failure.
&gt; 
&gt; =head2 send_with_receipt
&gt; 
&gt; This sends a message to a queue or topic, and requires a positive
&gt; acknowledgement via a RECEIPT response. You must pass in a destination
&gt; and a body.
&gt; 
&gt; The second &#40;optional&#41; argument is a scalar reference which passes back
&gt; the response from the SEND message. It will either be set to undef if
&gt; the message could not be sent, or a Net::Stomp::Frame object
&gt; containing the response. This response will either be a RECEIPT
&gt; message or some ERROR message.
&gt; 
&gt;   $stomp-&gt;send_with_receipt&#40;
&gt;       { destination =&gt; &#39;/queue/foo&#39;, body =&gt; &#39;test message&#39; }, \$send_response &#41;;
&gt; 
&gt; To send a BytesMessage, you should set the field &#39;bytes_message&#39; to
&gt; 1.
&gt; 
&gt; This function returns 1 on success &#40;i.e. the message was successfully
&gt; sent and a RECEIPT message received&#41;, or 0 on failure.
514a695,697
&gt; This function returns 1 on success &#40;i.e. the message was sent and
&gt; committed&#41;, 0 on failure.
&gt; 
575a759,760
&gt; This function returns 1 on success, 0 on failure.
&gt; 
581a767,768
&gt; This function returns 1 on success, 0 on failure.
&gt; 
596a784,786
&gt; This function returns a Net::Stomp::Frame object on success, undef on
&gt; failure &#40;or timeout&#41;.
&gt; 
624a815,835
&gt; This function returns 1 if the frame could be sent, 0 otherwise.
&gt; 
&gt; =head2 send_frame_with_receipt
&gt; 
&gt; This sends a single frame and requires a positive acknowledgement via
&gt; a RECEIPT response.
&gt; 
&gt; The second &#40;optional&#41; argument is a scalar reference which passes back
&gt; the response from sending the frame. It will either be set to undef if
&gt; the frame could not be sent, or a Net::Stomp::Frame object
&gt; containing the response. This response will either be a RECEIPT
&gt; message or some ERROR message.
&gt; 
&gt;   my $frame = Net::Stomp::Frame-&gt;new&#40;
&gt;        { command =&gt; $command, headers =&gt; $conf, body =&gt; $body } &#41;;
&gt; 
&gt;   $stomp-&gt;send_frame_with_receipt&#40;$frame, \$send_response&#41;;
&gt; 
&gt; This function returns 1 on success &#40;i.e. the message was successfully
&gt; sent and a RECEIPT message received&#41;, or 0 on failure.
&gt; 
635a847
&gt; Mark Stemm &lt;mstemm@cloudmark.com&gt;
</div></div>
</div>
    </div>
</div>
</div>
<div class="ticket-transaction message Correspond even">
<div class="ticket-transaction">
  <div class="metadata">
    <span class="type">
      &nbsp;      
    </span>
    <span class="date">Thu&nbsp;May&nbsp;12&nbsp;21:13:46&nbsp;2011</span>
    <span class="description">mstemm [...] cloudmark.com -  Correspondence added</span>
    <span class="time-taken"></span>    <span class="actions hidden"></span>
  </div>
    <div class="content">
      
<table>
  <tr>
    <td align="right" class="message-header-key">From:</td>
    <td class="message-header-value"> mstemm [...] cloudmark.com</td>
  </tr>
</table>
<div class="messageattachments">

<div class="messagebody">
<div class="message-stanza plain-text-white-space">Whoops, the prior patch had a bug that prevented message bodies from
being included when using send_transactional. Here is an updated version

On Thu May 12 20:32:31 2011, markstemm wrote:
<span
    class="message-stanza-folder closed"
    onclick="fold_message_stanza(this, 'Show\x20quoted\x20text', 'Hide\x20quoted\x20text');">Show quoted text</span><br /><div class="message-stanza closed">&gt; Hi, thanks for writing the useful Net::Stomp library. We at Cloudmark
&gt; have made some improvements to the library to gracefully handle
&gt; sending/receiving messages in the face of brokers going down and coming
&gt; back up.
&gt; 
&gt; I&#39;ve attached a summary of the changes and a patch file based on the
&gt; 0.41 tarball that incorporates the changes.
&gt; 
&gt; If you have further improvements or refinements you&#39;d like to see, we&#39;d
&gt; be happy to make them. Otherwise, enjoy the changes.
</div></div></div>
<table>
  <tr>
    <td align="right" class="message-header-key">Subject:</td>
    <td class="message-header-value"> 01-cloudmark-disconnect-improvements-v2.patch</td>
  </tr>
</table>

<div class="messagebody">
<div class="message-stanza plain-text-white-space">Index: lib/Net/Stomp.pm
===================================================================
13c13
&lt;     ssl_options subscriptions _connect_headers bufsize
---
&gt;     ssl_options subscriptions _connect_headers bufsize reconnect_attempts ignore_sigpipe
29a30,40
&gt;     # Make the number of reconnection attempts per send/receive
&gt;     # attempt configurable. The default is 0 &#40;retry forever&#41;.
&gt;     if &#40;! defined $self-&gt;reconnect_attempts&#41; {
&gt;         $self-&gt;reconnect_attempts&#40;0&#41;;
&gt;     }
&gt; 
&gt;     # If configured to do so, ignore SIGPIPE.
&gt;     if &#40;defined $self-&gt;ignore_sigpipe &#38;&#38; $self-&gt;ignore_sigpipe == 1&#41; {
&gt;         $SIG{PIPE} = &#39;IGNORE&#39;;
&gt;     }
&gt; 
111c122
&lt;     my &#40; $self, $conf &#41; = @_;
---
&gt;     my &#40; $self, $conf, $response_frame_ref &#41; = @_;
115c126,129
&lt;     $self-&gt;send_frame&#40;$frame&#41;;
---
&gt;     if &#40;$self-&gt;send_frame&#40;$frame&#41; == 0&#41; {
&gt;         return undef;
&gt;     }
&gt; 
117a132,148
&gt;     # If response_frame_ref is defined, set it to the response.
&gt;     if &#40;defined $response_frame_ref&#41; {
&gt;         $$response_frame_ref = $frame;
&gt;     }
&gt; 
&gt;     # If receive_frame didn&#39;t actually return anything, we can return
&gt;     # failure immediately.
&gt;     if &#40;! defined $frame&#41; {
&gt;         return 0;
&gt;     }
&gt; 
&gt;     # If receive_frame didn&#39;t return a CONNECTED response, return
&gt;     # failure.
&gt;     if &#40;$frame-&gt;command ne &#34;CONNECTED&#34;&#41; {
&gt;         return 0;
&gt;     }
&gt; 
123c154
&lt;     return $frame;
---
&gt;     return 1;
128a160,161
&gt; 
&gt;     # Note: ignoring result from send_frame.
135a169
&gt; 
140,142c174,175
&lt;     while &#40;$@&#41; {
&lt;         sleep&#40;5&#41;;
&lt;         eval { $self-&gt;_get_connection };
---
&gt;     if &#40;$@&#41; {
&gt;         return;
144c177,182
&lt;     $self-&gt;connect&#40; $self-&gt;_connect_headers &#41;;
---
&gt; 
&gt;     if &#40;$self-&gt;connect&#40; $self-&gt;_connect_headers &#41; == 0&#41; {
&gt;         $self-&gt;socket-&gt;close;
&gt;         return;
&gt;     }
&gt; 
146c184,187
&lt;         $self-&gt;subscribe&#40;$self-&gt;subscriptions-&gt;{$sub}&#41;;
---
&gt;         if &#40;$self-&gt;subscribe&#40;$self-&gt;subscriptions-&gt;{$sub}&#41; == 0&#41; {
&gt;             $self-&gt;socket-&gt;close;
&gt;             return;
&gt;         }
173c214
&lt;     $self-&gt;send_frame&#40;$frame&#41;;
---
&gt;     return $self-&gt;send_frame&#40;$frame&#41;;
176,177c217,219
&lt; sub send_transactional {
&lt;     my &#40; $self, $conf &#41; = @_;
---
&gt; sub send_with_receipt {
&gt;     my &#40;$self, $conf, $send_response_ref&#41; = @_;
&gt; 
179a222,236
&gt;     my $frame = Net::Stomp::Frame-&gt;new&#40;
&gt;         { command =&gt; &#39;SEND&#39;, headers =&gt; $conf, body =&gt; $body } &#41;;
&gt; 
&gt;     return $self-&gt;send_frame_with_receipt&#40;$frame, $send_response_ref&#41;;
&gt; }
&gt; 
&gt; sub send_transactional {
&gt;     my &#40; $self, $conf &#41; = @_;
&gt; 
&gt;     # Note: as this function depends on a sequence of messages, any of
&gt;     # which *may* return an error from the broker on failure, we send
&gt;     # all messages using send_with_receipt/send_frame_with_receipt. If
&gt;     # we didn&#39;t include receipt ids, one of these messages could
&gt;     # return 0 or 1 responses back, which throws off the pipeline for
&gt;     # subsequent messages or subsequent calls to send_transactional.
182a240
&gt; 
187c245,247
&lt;     $self-&gt;send_frame&#40;$begin_frame&#41;;
---
&gt;     if &#40;$self-&gt;send_frame_with_receipt&#40;$begin_frame&#41; == 0&#41; {
&gt;         return 0;
&gt;     }
190,200d249
&lt;     my $receipt_id = $self-&gt;_get_next_transaction;
&lt;     $conf-&gt;{receipt} = $receipt_id;
&lt;     my $message_frame = Net::Stomp::Frame-&gt;new&#40;
&lt;         { command =&gt; &#39;SEND&#39;, headers =&gt; $conf, body =&gt; $body } &#41;;
&lt;     $self-&gt;send_frame&#40;$message_frame&#41;;
&lt; 
&lt;     # check the receipt
&lt;     my $receipt_frame = $self-&gt;receive_frame;
&lt;     if &#40;   $receipt_frame-&gt;command eq &#39;RECEIPT&#39;
&lt;         &#38;&#38; $receipt_frame-&gt;headers-&gt;{&#39;receipt-id&#39;} eq $receipt_id &#41;
&lt;     {
202,209c251,252
&lt;         # success, commit the transaction
&lt;         my $frame_commit = Net::Stomp::Frame-&gt;new&#40;
&lt;             {   command =&gt; &#39;COMMIT&#39;,
&lt;                 headers =&gt; { transaction =&gt; $transaction_id }
&lt;             }
&lt;         &#41;;
&lt;         return $self-&gt;send_frame&#40;$frame_commit&#41;;
&lt;     } else {
---
&gt;     if &#40;$self-&gt;send_with_receipt&#40;$conf, undef&#41; == 0&#41; {
&gt;         # The send wasn&#39;t acknowledged. ABORT the transaction.
211d253
&lt;         # some failure, abort transaction
217c259,262
&lt;         $self-&gt;send_frame&#40;$frame_abort&#41;;
---
&gt; 
&gt;         # Note: ignoring result from send_frame_with_receipt, as we&#39;re
&gt;         # going to return an error anyway.
&gt;         $self-&gt;send_frame_with_receipt&#40;$frame_abort&#41;;
219a265,272
&gt; 
&gt;     # success, commit the transaction
&gt;     my $frame_commit = Net::Stomp::Frame-&gt;new&#40;
&gt;         {   command =&gt; &#39;COMMIT&#39;,
&gt;             headers =&gt; { transaction =&gt; $transaction_id }
&gt;         }
&gt;         &#41;;
&gt;     return $self-&gt;send_frame_with_receipt&#40;$frame_commit&#41;;
226c279,281
&lt;     $self-&gt;send_frame&#40;$frame&#41;;
---
&gt;     if &#40;$self-&gt;send_frame_with_receipt&#40;$frame&#41; == 0&#41; {
&gt;         return 0;
&gt;     }
228a284,285
&gt; 
&gt;     return 1;
235c292,294
&lt;     $self-&gt;send_frame&#40;$frame&#41;;
---
&gt;     if &#40;$self-&gt;send_frame_with_receipt&#40;$frame&#41; == 0&#41; {
&gt;         return 0;
&gt;     }
237a297,298
&gt; 
&gt;     return 1;
245c306
&lt;     $self-&gt;send_frame&#40;$frame&#41;;
---
&gt;     return $self-&gt;send_frame_with_receipt&#40;$frame&#41;;
251,254c312,329
&lt;     #     warn &#34;send [&#34; . $frame-&gt;as_string . &#34;]\n&#34;;
&lt;     $self-&gt;socket-&gt;syswrite&#40; $frame-&gt;as_string &#41;;
&lt;     my $connected = $self-&gt;socket-&gt;connected;
&lt;     unless &#40;defined $connected&#41; {
---
&gt;     # Try up to reconnect_attempts times to send the frame &#40;or
&gt;     # forever, if reconnect_attempts is 0&#41;.
&gt; 
&gt;     for&#40;my $attempts = $self-&gt;reconnect_attempts;
&gt;         $self-&gt;reconnect_attempts == 0 || $attempts &gt; 0;
&gt;         $attempts--&#41; {
&gt; 
&gt; #       warn &#34;send [&#34; . $frame-&gt;as_string . &#34;]\n&#34;;
&gt;         my $written = $self-&gt;socket-&gt;syswrite&#40; $frame-&gt;as_string &#41;;
&gt; 
&gt;         if &#40;defined $written &#38;&#38; $written == length&#40;$frame-&gt;as_string&#41;&#41; {
&gt;             return 1;
&gt;         }
&gt; 
&gt;         # If here, we couldn&#39;t send the frame, which was either due to a
&gt;         # short write or due to an inability to write at all. In either
&gt;         # case, try to reconnect.
&gt;         sleep&#40;5&#41;;
256d330
&lt;         $self-&gt;send_frame&#40;$frame&#41;;
257a332,369
&gt; 
&gt;     # If here, we couldn&#39;t send. Give up.
&gt;     return 0;
&gt; }
&gt; 
&gt; sub send_frame_with_receipt {
&gt;     my &#40;$self, $frame, $send_response_ref&#41; = @_;
&gt; 
&gt;     if &#40;defined $send_response_ref&#41; {
&gt;         $$send_response_ref = undef;
&gt;     }
&gt; 
&gt;     my $receipt_id = $self-&gt;_get_next_transaction;
&gt;     $frame-&gt;headers-&gt;{receipt} = $receipt_id;
&gt; 
&gt;     if &#40;$self-&gt;send_frame&#40;$frame&#41; == 0&#41; {
&gt;         return 0;
&gt;     }
&gt; 
&gt;     # Read the response, which will either be a RECEIPT or some
&gt;     # ERROR. Always wait up to 30 seconds for a response.
&gt; 
&gt;     my $response = $self-&gt;receive_frame&#40;{timeout =&gt; 30}&#41;;
&gt; 
&gt;     if &#40;! defined $response&#41; {
&gt;         return 0;
&gt;     }
&gt; 
&gt;     if &#40;defined $send_response_ref&#41; {
&gt;         $$send_response_ref = $response;
&gt;     }
&gt; 
&gt;     if &#40;$response-&gt;command ne &#39;RECEIPT&#39; ||
&gt;         $response-&gt;headers-&gt;{&#39;receipt-id&#39;} ne $receipt_id&#41; {
&gt;         return 0;
&gt;     }
&gt; 
&gt;     return 1;
339c451,458
&lt;     unless &#40;defined $connected&#41; {
---
&gt; 
&gt;     # Try up to reconnect_attempts times to connect &#40;or
&gt;     # forever, if reconnect_attempts is 0&#41;.
&gt;     for&#40;my $attempts = $self-&gt;reconnect_attempts;
&gt;         &#40;! defined $connected &#38;&#38; &#40;$self-&gt;reconnect_attempts == 0 || $attempts &gt; 0&#41;&#41;;
&gt;         $attempts--&#41; {
&gt; 
&gt;         sleep&#40;5&#41;;
340a460
&gt;         $connected = $self-&gt;socket-&gt;connected;
342a463,465
&gt;     # If we still can&#39;t connect, give up.
&gt;     return undef if &#40;! defined $connected&#41;;
&gt; 
467a591,613
&gt; By default, if the broker goes away, socket writes could result in a
&gt; SIGPIPE signal, terminating the process. If you pass the option
&gt; ignore_sigpipe to new with value 1, the library will set up a signal
&gt; handler for SIGPIPE that ignores the signal:
&gt; 
&gt;   my $stomp = Net::Stomp-&gt;new&#40; {
&gt;     hostname             =&gt; &#39;localhost&#39;,
&gt;     port                 =&gt; &#39;61612&#39;,
&gt;     ignore_sigpipe       =&gt;  1
&gt;   } &#41;;
&gt; 
&gt; By default, when sending/receiving a message, if the library is not
&gt; currently connected to the broker, it will attempt to reconnect
&gt; &#40;forever&#41; before sending/receiving the message. If you want to limit
&gt; the number of reconnection attempts that occur before giving up and
&gt; returning an error, pass the option reconnect_attempts in new&#40;&#41;:
&gt; 
&gt;   my $stomp = Net::Stomp-&gt;new&#40; {
&gt;     hostname             =&gt; &#39;localhost&#39;,
&gt;     port                 =&gt; &#39;61612&#39;,
&gt;     reconnect_attempts   =&gt; 5
&gt;   } &#41;;
&gt; 
481,482c627,629
&lt; This connects to the Stomp server. You may pass in a C&lt;login&gt; and
&lt; C&lt;passcode&gt; options.
---
&gt; This connects to the Stomp server. The first argument is a hash of
&gt; headers to include along with the CONNECT message. In that hash, you
&gt; may pass in a C&lt;login&gt; and C&lt;passcode&gt; options.
488c635,642
&lt;   $stomp-&gt;connect&#40; { login =&gt; &#39;hello&#39;, passcode =&gt; &#39;there&#39; } &#41;;
---
&gt; The second &#40;optional&#41; argument is a scalar reference which passes back
&gt; the response from the CONNECT message. It will either be set to undef
&gt; if the connect failed, or a Net::Stomp::Frame object containing the
&gt; response.
&gt; 
&gt;   $stomp-&gt;connect&#40; { login =&gt; &#39;hello&#39;, passcode =&gt; &#39;there&#39; }, \$connect_response &#41;;
&gt; 
&gt; connect&#40;&#41; returns 1 on success, 0 on failure.
498c652,676
&lt; To send a BytesMessage, you should set the field &#39;bytes_message&#39; to 1.
---
&gt; To send a BytesMessage, you should set the field &#39;bytes_message&#39; to
&gt; 1.
&gt; 
&gt; This function returns 1 on success, 0 on failure.
&gt; 
&gt; =head2 send_with_receipt
&gt; 
&gt; This sends a message to a queue or topic, and requires a positive
&gt; acknowledgement via a RECEIPT response. You must pass in a destination
&gt; and a body.
&gt; 
&gt; The second &#40;optional&#41; argument is a scalar reference which passes back
&gt; the response from the SEND message. It will either be set to undef if
&gt; the message could not be sent, or a Net::Stomp::Frame object
&gt; containing the response. This response will either be a RECEIPT
&gt; message or some ERROR message.
&gt; 
&gt;   $stomp-&gt;send_with_receipt&#40;
&gt;       { destination =&gt; &#39;/queue/foo&#39;, body =&gt; &#39;test message&#39; }, \$send_response &#41;;
&gt; 
&gt; To send a BytesMessage, you should set the field &#39;bytes_message&#39; to
&gt; 1.
&gt; 
&gt; This function returns 1 on success &#40;i.e. the message was successfully
&gt; sent and a RECEIPT message received&#41;, or 0 on failure.
514a693,695
&gt; This function returns 1 on success &#40;i.e. the message was sent and
&gt; committed&#41;, 0 on failure.
&gt; 
575a757,758
&gt; This function returns 1 on success, 0 on failure.
&gt; 
581a765,766
&gt; This function returns 1 on success, 0 on failure.
&gt; 
596a782,784
&gt; This function returns a Net::Stomp::Frame object on success, undef on
&gt; failure &#40;or timeout&#41;.
&gt; 
624a813,833
&gt; This function returns 1 if the frame could be sent, 0 otherwise.
&gt; 
&gt; =head2 send_frame_with_receipt
&gt; 
&gt; This sends a single frame and requires a positive acknowledgement via
&gt; a RECEIPT response.
&gt; 
&gt; The second &#40;optional&#41; argument is a scalar reference which passes back
&gt; the response from sending the frame. It will either be set to undef if
&gt; the frame could not be sent, or a Net::Stomp::Frame object
&gt; containing the response. This response will either be a RECEIPT
&gt; message or some ERROR message.
&gt; 
&gt;   my $frame = Net::Stomp::Frame-&gt;new&#40;
&gt;        { command =&gt; $command, headers =&gt; $conf, body =&gt; $body } &#41;;
&gt; 
&gt;   $stomp-&gt;send_frame_with_receipt&#40;$frame, \$send_response&#41;;
&gt; 
&gt; This function returns 1 on success &#40;i.e. the message was successfully
&gt; sent and a RECEIPT message received&#41;, or 0 on failure.
&gt; 
635a845
&gt; Mark Stemm &lt;mstemm@cloudmark.com&gt;
</div></div>
</div>
    </div>
</div>
</div>
<div class="ticket-transaction message Correspond odd">
<div class="ticket-transaction">
  <div class="metadata">
    <span class="type">
      &nbsp;      
    </span>
    <span class="date">Thu&nbsp;Mar&nbsp;14&nbsp;20:52:42&nbsp;2013</span>
    <span class="description">preaction [...] cpan.org -  Correspondence added</span>
    <span class="time-taken"></span>    <span class="actions hidden"></span>
  </div>
    <div class="content">
      

<div class="messagebody">
<div class="message-stanza plain-text-white-space">I know this is an old ticket, but I like the features here. 

Would it ever be necessary to not ignore SIGPIPE? It seems like Net::Stomp tries very hard to 
reconnect whenever it can, so ignoring SIGPIPE seems like it should be the default.

The number of reconnects logic looks like it can be added as-is.
</div></div>
    </div>
</div>
</div>
<div class="ticket-transaction basics Status even">
<div class="ticket-transaction">
  <div class="metadata">
    <span class="type">
      &nbsp;      
    </span>
    <span class="date">Thu&nbsp;Mar&nbsp;14&nbsp;20:52:43&nbsp;2013</span>
    <span class="description">The RT System itself -  Status changed from &#39;new&#39; to &#39;open&#39;</span>
    <span class="time-taken"></span>    <span class="actions hidden"></span>
  </div>
    <div class="content">
    </div>
</div>
</div>
<div class="ticket-transaction message Correspond odd">
<div class="ticket-transaction">
  <div class="metadata">
    <span class="type">
      &nbsp;      
    </span>
    <span class="date">Fri&nbsp;Jul&nbsp;11&nbsp;06:11:46&nbsp;2014</span>
    <span class="description">DAKKAR [...] cpan.org -  Correspondence added</span>
    <span class="time-taken"></span>    <span class="actions hidden"></span>
  </div>
    <div class="content">
      

<div class="messagebody">
<div class="message-stanza plain-text-white-space">The next release will ignore SIGPIPE locally while writing, so we don&#39;t break whatever signal handling the rest of the process has set up.

I have also implemented a limit on the number of reconnect attempts &#40;separate for the initial socket connection, and for subsequent reconnections, for back-compat&#41;.

I will document the return values of each method, I agree they are confusing.

With all the reconnect logic, send_frame will never need to return &#34;I couldn&#39;t send&#34;, it will either succeed, or throw an exception when the reconnect attempts are exceeded.
</div></div>
    </div>
</div>
</div>
<div class="ticket-transaction message Correspond even">
<div class="ticket-transaction">
  <div class="metadata">
    <span class="type">
      &nbsp;      
    </span>
    <span class="date">Fri&nbsp;Jul&nbsp;11&nbsp;10:52:57&nbsp;2014</span>
    <span class="description">DAKKAR [...] cpan.org -  Correspondence added</span>
    <span class="time-taken"></span>    <span class="actions hidden"></span>
  </div>
    <div class="content">
      

<div class="messagebody">
<div class="message-stanza plain-text-white-space">I think I addressed all your suggestions in 0.47. If I forgot or misunderstood something, please open another ticket.

&#40;Also, please send unified/contextual patches, or GitHub pull requests: they&#39;re easier to read&#41;
</div></div>
    </div>
</div>
</div>
<div class="ticket-transaction basics Status odd">
<div class="ticket-transaction">
  <div class="metadata">
    <span class="type">
      &nbsp;      
    </span>
    <span class="date">Fri&nbsp;Jul&nbsp;11&nbsp;10:52:58&nbsp;2014</span>
    <span class="description">DAKKAR [...] cpan.org -  Status changed from &#39;open&#39; to &#39;resolved&#39;</span>
    <span class="time-taken"></span>    <span class="actions hidden"></span>
  </div>
    <div class="content">
    </div>
</div>
</div>
</div>
    <hr class="clear" />
  </div>
</div>




</div>
 


  <hr class="clear" />
</div>
</body>
</html>
