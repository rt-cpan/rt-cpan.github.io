--- ./Recursive.pm	2014-03-31 18:35:58.000000000 +0200
+++ ./Recursive.pm.new	2014-03-31 18:57:11.000000000 +0200
@@ -421,34 +421,34 @@
 
 This function uses File::Copy's copy() function to copy a file but not a directory. Any directories are recursively created if need be.
 One difference to File::Copy::copy() is that fcopy attempts to preserve the mode (see Preserving Mode below)
-The optional $buf in the synopsis if the same as File::Copy::copy()'s 3rd argument
-returns the same as File::Copy::copy() in scalar context and 1,0,0 in list context to accomidate rcopy()'s list context on regular files. (See below for more info)
+The optional $buf in the synopsis is the same as File::Copy::copy()'s 3rd argument.
+This function returns the same as File::Copy::copy() in scalar context and 1,0,0 in list context to accomodate rcopy()'s list context on regular files. (See below for more info)
 
 =head2 dircopy()
 
 This function recursively traverses the $orig directory's structure and recursively copies it to the $new directory.
-$new is created if necessary (multiple non existant directories is ok (IE foo/bar/baz). The script logically and portably creates all of them if necessary).
+$new is created if necessary (multiple non existant directories is ok (i.e. foo/bar/baz). The script logically and portably creates all of them if necessary).
 It attempts to preserve the mode (see Preserving Mode below) and 
-by default it copies all the way down into the directory, (see Managing Depth) below.
+by default it copies all the way down into the directory (see Managing Depth, below).
 If a directory is not specified it croaks just like fcopy croaks if its not a file that is specified.
 
-returns true or false, for true in scalar context it returns the number of files and directories copied,
-In list context it returns the number of files and directories, number of directories only, depth level traversed.
+This function returns true or false: for true in scalar context it returns the number of files and directories copied,
+whereas in list context it returns the number of files and directories, number of directories only, depth level traversed.
 
   my $num_of_files_and_dirs = dircopy($orig,$new);
   my($num_of_files_and_dirs,$num_of_dirs,$depth_traversed) = dircopy($orig,$new);
   
-Normally it stops and return's if a copy fails, to continue on regardless set $File::Copy::Recursive::SkipFlop to true.
+Normally it stops and returns if a copy fails. To continue on regardless, set $File::Copy::Recursive::SkipFlop to true.
 
     local $File::Copy::Recursive::SkipFlop = 1;
 
-That way it will copy everythgingit can ina directory and won't stop because of permissions, etc...
+That way it will copy everythging it can in a directory and won't stop because of permissions, etc...
 
 =head2 rcopy()
 
-This function will allow you to specify a file *or* directory. It calls fcopy() if its a file and dircopy() if its a directory.
+This function will allow you to specify a file *or* a directory. It calls fcopy() if you passed file and dircopy() if you passed a directory.
 If you call rcopy() (or fcopy() for that matter) on a file in list context, the values will be 1,0,0 since no directories and no depth are used. 
-This is important becasue if its a directory in list context and there is only the initial directory the return value is 1,1,1.
+This is important because if it's a directory in list context and there is only the initial directory the return value is 1,1,1.
 
 =head2 rcopy_glob()
 
@@ -499,13 +499,13 @@
 
 Default is false. If set to true  rmdir(), mkdir(), and pathempty() calls in pathrm() and pathmk() do not return() on failure.
 
-If its set to true they just silently go about their business regardless. This isn't a good idea but its there if you want it.
+If its set to true they just silently go about their business regardless. This isn't a good idea but it's there if you want it.
 
 =head3 $DirPerms
 
 Mode to pass to any mkdir() calls. Defaults to 0777 as per umask()'s POD. Explicitly having this allows older perls to be able to use FCR and might add a bit of flexibility for you.
 
-Any value you set it to should be suitable for oct()
+Any value you set it to should be suitable for oct().
 
 =head3 Path functions
 
@@ -544,7 +544,7 @@
 
 =head4 pathempty()
 
-Recursively removes the given directory's contents so it is empty. returns 2 if argument is not a directory, 1 on successfully emptying the directory.
+Recursively removes the given directory's contents so it is empty. Returns 2 if the given argument is not a directory, 1 on successfully emptying the directory.
 
    File::Copy::Recursive::pathempty($pth) or die $!;
    # $pth is now an empty directory
@@ -560,7 +560,7 @@
 =head4 pathrmdir()
 
 Same as rmdir() but it calls pathempty() first to recursively empty it first since rmdir can not remove a directory with contents.
-Just removes the top directory the path given instead of the entire path like pathrm(). Return 2 if given argument does not exist (IE its already gone). Return false if it exists but is not a directory.
+Just removes the top directory the path given instead of the entire path like pathrm(). Returns 2 if the given argument does not exist (i.e. it's already gone). Returns false if it exists but is not a directory.
 
 =head2 Preserving Mode
 
@@ -578,9 +578,9 @@
 =head2 SymLinks
 
 If your system supports symlinks then symlinks will be copied as symlinks instead of as the target file.
-Perl's symlink() is used instead of File::Copy's copy()
+Perl's symlink() is used instead of File::Copy's copy().
 You can customize this behavior by setting $File::Copy::Recursive::CopyLink to a true or false value.
-It is already set to true or false dending on your system's support of symlinks so you can check it with an if statement to see how it will behave:
+It is already set to true or false depending on your system's support of symlinks so you can check it with an if statement to see how it will behave:
 
     if($File::Copy::Recursive::CopyLink) {
         print "Symlinks will be preserved\n";
@@ -588,7 +588,7 @@
         print "Symlinks will not be preserved because your system does not support it\n";
     }
 
-If symlinks are being copied you can set $File::Copy::Recursive::BdTrgWrn to true to make it carp when it copies a link whose target does not exist. Its false by default.
+If symlinks are being copied you can set $File::Copy::Recursive::BdTrgWrn to true to make it carp when it copies a link whose target does not exist. It's false by default.
 
     local $File::Copy::Recursive::BdTrgWrn  = 1;
 
@@ -610,11 +610,11 @@
     dircopy($orig, $target) or die $!;
     # if it fails it does your "or die"
 
-This should be unnecessary most of the time but its there if you need it :)
+This should be unnecessary most of the time but it's there if you need it :)
 
 =head2 Turning off stat() check
 
-By default the files or directories are checked to see if they are the same (IE linked, or two paths (absolute/relative or different relative paths) to the same file) by comparing the file's stat() info. 
+By default the files or directories are checked to see if they are the same (i.e. linked, or two paths (absolute/relative or different relative paths) to the same file) by comparing the file's stat() info. 
 It's a very efficient check that croaks if they are and shouldn't be turned off but if you must for some weird reason just set $File::Copy::Recursive::PFSCheck to a false value. ("PFS" stands for "Physical File System")
 
 =head2 Emulating cp -rf dir1/ dir2/
@@ -627,7 +627,7 @@
 If you need to do that then use the variables $RMTrgFil and $RMTrgDir described in "Removing existing target file or directory before copying" above.
 
 That means that if $dir2 exists it puts the contents into $dir2/$dir1 instead of $dir2 just like cp -rf.
-If $dir2 does not exist then the contents go into $dir2 like normal (also like cp -rf)
+If $dir2 does not exist then the contents go into $dir2 like normal (also like cp -rf).
 
 So assuming 'foo/file':
 
@@ -651,7 +651,7 @@
     # if bar does not exist the result is bar/file
     # if bar does exist the result is bar/file
 
-NOTE: The '*' is only like cp -rf foo/* and *DOES NOT EXPAND PARTIAL DIRECTORY NAMES LIKE YOUR SHELL DOES* (IE not like cp -rf fo* to copy foo/*)
+NOTE: The '*' is only like cp -rf foo/* and *DOES NOT EXPAND PARTIAL DIRECTORY NAMES LIKE YOUR SHELL DOES* (i.e. not like cp -rf fo* to copy foo/*).
 
 =head2 Allowing Copy Loops
 
@@ -663,9 +663,9 @@
 
 This is false by default so that a check is done to see if the source directory will contain the target directory and croaks to avoid this problem.
 
-If you ever find a situation where $CopyLoop = 1 is desirable let me know (IE its a bad bad idea but is there if you want it)
+If you ever find a situation where $CopyLoop = 1 is desirable let me know. (i.e. it's a bad bad idea but is there if you want it)
 
-(Note: On Windows this was necessary since it uses stat() to detemine samedness and stat() is essencially useless for this on Windows. 
+(Note: On Windows this was necessary since it uses stat() to determine sameness and stat() is essentially useless for this on Windows. 
 The test is now simply skipped on Windows but I'd rather have an actual reliable check if anyone in Microsoft land would care to share)
 
 =head1 SEE ALSO
