Only in Audio-Scan-0.93.5: blib
diff -r Audio-Scan-0.93/Changes Audio-Scan-0.93.5/Changes
4a5,48
> 0.93.5: Mark Overmeer 2012-06-29
> 
> 	Improvements:
> 	- add mp3 support to tools/audioscan.pl
> 
> 0.93.4: Mark Overmeer 2012-06-29
> 
> 	Fixes:
> 	- options of tools/audioscan.pl
> 	- add artwork_offset to flac
> 
> 0.93.3: Mark Overmeer 2012-06-28
> 
> 	Fixes:
> 	- artwork_size and _offset were not reported for formats
> 	  based on id3 (APIC)
> 	- artwork_size and _offset incorrect for mp4
> 
> 	Improvements:
> 	- add tools/audioscan.pl
> 
> 0.93.2  Mark Overmeer 2012-06-26
> 
> 	Fixes:
> 	- skip_art in id3 did not understand artwork_limit
> 	- move artwork_size and artwork_offset from 'tags' into 'info'.
> 
> 0.93.1  Mark Overmeer 2012-06-25
> 
> 	Improvements:
> 	- Audio::Scan::scan() and Scan.xs/_scan() add parameter artwork_limit.
> 	- src/common.c and include/common.h add _artwork_too_large().
> 	- all back-ends return the artwork size as tag artwork_size, also
> 	  when the artwork is taken.
> 	- add 'format' field to the return of scan.
> 
> 	Incompatible change: in 0.93
> 	- the "image_data" (sometimes "image") tag was used as size 
> 	  when AUDIO_SCAN_NO_ARTWORK but to contain the binary image in
> 	  the normal situation.  The first purpose is dropped in favor of
> 	  artwork_size.  This affected some test-scripts.
> 	- for Ogg, the artwork_size is now based on the base64 decoded
> 	  length, not the encoded length as before.
> 
7c51,52
<         - Don't use MAX_PATH because this limits path names to only 260 chars on Win32.
---
>         - Don't use MAX_PATH because this limits path names to only 260
> 	  chars on Win32.
diff -r Audio-Scan-0.93/include/common.h Audio-Scan-0.93.5/include/common.h
80a81,83
> 
> extern uint32_t artwork_limit;
> bool _artwork_too_large(uint32_t size);
diff -r Audio-Scan-0.93/lib/Audio/Scan.pm Audio-Scan-0.93.5/lib/Audio/Scan.pm
5c5
< our $VERSION = '0.93';
---
> our $VERSION = '0.93.5';
11a12
> use constant FILTER_TAKE_ALL  => FILTER_INFO_ONLY|FILTER_TAGS_ONLY;
15c16
<     
---
> 
18c19
<     
---
> 
24c25
<     
---
> 
27c28
<     
---
> 
33,35c34,36
<     
<     my ($filter, $md5_size, $md5_offset);
<       
---
> 
>     my ($filter, $md5_size, $md5_offset, $artwork_limit);
> 
40c41
<     
---
> 
42c43
<     
---
> 
44c45
<     
---
> 
46c47
<     
---
> 
54c55
<             $filter     = $opts->{filter} || FILTER_INFO_ONLY | FILTER_TAGS_ONLY;
---
>             $filter     = $opts->{filter};
56a58
>             $artwork_limit = $opts->{artwork_limit};
59,65c61,67
<     
<     if ( !defined $filter ) {
<         $filter = FILTER_INFO_ONLY | FILTER_TAGS_ONLY;
<     }
<     
<     my $ret = $class->_scan( $suffix, $fh, $path, $filter, $md5_size || 0, $md5_offset || 0 );
<     
---
> 
>     $filter ||= FILTER_TAKE_ALL;
> 
>     my $ret = $class->_scan( $suffix, $fh, $path, $filter,
>         $md5_size || 0, $md5_offset || 0,
>         (defined $artwork_limit ? $artwork_limit : -1));
> 
67c69
<     
---
> 
73,75c75,77
<     
<     my ($filter, $md5_size, $md5_offset);
<     
---
> 
>     my ($filter, $md5_size, $md5_offset, $artwork_limit);
> 
77c79
<     
---
> 
85c87
<             $filter     = $opts->{filter} || FILTER_INFO_ONLY | FILTER_TAGS_ONLY;
---
>             $filter     = $opts->{filter};
87a90
>             $artwork_limit = $opts->{artwork_limit};
90,95c93,98
<     
<     if ( !defined $filter ) {
<         $filter = FILTER_INFO_ONLY | FILTER_TAGS_ONLY;
<     }
<     
<     return $class->_scan( $suffix, $fh, '(filehandle)', $filter, $md5_size || 0, $md5_offset || 0 );
---
> 
>     $filter ||= FILTER_TAKE_ALL;
> 
>     return $class->_scan( $suffix, $fh, '(filehandle)', $filter,
>         $md5_size || 0, $md5_offset || 0,
>         (defined $artwork_limit ? $artwork_limit : -1));
100c103
<     
---
> 
105c108
<     
---
> 
107c110
<     
---
> 
109c112
<     
---
> 
111c114
<     
---
> 
113c116
<     
---
> 
115c118
<     
---
> 
121c124
<     
---
> 
123c126
<     
---
> 
129c132
<     
---
> 
134c137
<     
---
> 
136c139
<     
---
> 
138c141
<     
---
> 
140c143
<     
---
> 
142c145
<     
---
> 
144c147
<     
---
> 
150c153
<     
---
> 
152c155
<     
---
> 
167a171
>     print "$data->{format}\n";
174c178
<     
---
> 
177,178c181
<     {
<         local $ENV{AUDIO_SCAN_NO_ARTWORK} = 1;
---
>     {   local $ENV{AUDIO_SCAN_NO_ARTWORK} = 1;
181c184,188
<     
---
> 
>     # Scan with limited artwork size
>     my $data = Audio::Scan->scan('/path/to/file.mp3',
>         {artwork_limit => 200_000} );
> 
186c193
<     
---
> 
188c195
<     my $data = Audio::Scan->scan( '/path/to/file.mp3', { md5_size => 100 * 1024 } );
---
>     my $data = Audio::Scan->scan( '/path/to/file.mp3', {md5_size => 100*1024} );
193,194c200,202
< Audio::Scan is a C-based scanner for audio file metadata and tag information. It currently
< supports MP3, MP4, Ogg Vorbis, FLAC, ASF, WAV, AIFF, Musepack, Monkey's Audio, and WavPack.
---
> Audio::Scan is a C-based scanner for audio file metadata and tag
> information. It currently supports MP3, MP4, Ogg Vorbis, FLAC, ASF, WAV,
> AIFF, Musepack, Monkey's Audio, and WavPack.
202,218c210,232
< Scans $path for both metadata and tag information.  The type of scan performed is
< determined by the file's extension.  Supported extensions are:
< 
<     MP3:  mp3, mp2
<     MP4:  mp4, m4a, m4b, m4p, m4v, m4r, k3g, skm, 3gp, 3g2, mov
<     AAC (ADTS): aac
<     Ogg:  ogg, oga
<     FLAC: flc, flac, fla
<     ASF:  wma, wmv, asf
<     Musepack:  mpc, mpp, mp+
<     Monkey's Audio:  ape, apl
<     WAV: wav
<     AIFF: aiff, aif
<     WavPack: wv
< 
< This method returns a hashref containing two other hashrefs: info and tags.  The
< contents of the info and tag hashes vary depending on file format, see below for details.
---
> Scans $path for both metadata and tag information.  The type of scan
> performed is determined by the file's extension.  Supported extensions
> are:
> 
>   MP3:  mp3, mp2
>   MP4:  mp4, m4a, m4b, m4p, m4v, m4r, k3g, skm, 3gp, 3g2, mov
>   AAC (ADTS): aac
>   Ogg:  ogg, oga
>   FLAC: flc, flac, fla
>   ASF:  wma, wmv, asf
>   Musepack:  mpc, mpp, mp+
>   Monkey's Audio:  ape, apl
>   WAV: wav
>   AIFF: aiff, aif
>   WavPack: wv
> 
> This method returns a HASH containing three fields: format, info,
> and tags.  The info and tag refer to hashes which vary depending on
> file format, see below for details.
> 
> The C<format> field is a three letter abbreviation of the used backend.
> C<aac>, C<ape>, C<asf>, C<flc>, C<mp3>, C<mp4>, C<mpc>, C<ogg>, C<wav>,
> and C<wvp> and currently defined.
222c236
<     md5_size => $audio_bytes_to_checksum
---
>   md5_size => $audio_bytes_to_checksum
224,227c238,242
< An MD5 will be computed of the first N audio bytes. Any tags in the file are automatically
< skipped, so this is a useful way of determining if a file's audio content is the same even
< if tags may have been changed.  The hex MD5 value is returned in the $info->{audio_md5}
< key.  This option will reduce performance, so choose a small enough size that works for you,
---
> An MD5 will be computed of the first N audio bytes. Any tags in the file
> are automatically skipped, so this is a useful way of determining if
> a file's audio content is the same even if tags may have been changed.
> The hex MD5 value is returned in the $info->{audio_md5} key.  This option
> will reduce performance, so choose a small enough size that works for you,
230,231c245,248
< For FLAC files that already contain an MD5 checksum, this value will be used instead
< of calculating a new one.
---
> For FLAC files that already contain an MD5 checksum, this value will be
> used instead of calculating a new one.
> 
>   md5_offset => $offset
233c250,251
<     md5_offset => $offset
---
> Begin computing the audio_md5 value starting at $offset.  If this value
> is not specified, $offset defaults to a point in the middle of the file.
235,236c253,259
< Begin computing the audio_md5 value starting at $offset.  If this value is not specified,
< $offset defaults to a point in the middle of the file.
---
>   artwork_limit => $size
> 
> Do not take the artwork when it is larger than $size bytes.  $size
> equals -1 means "unlimited".  $size equals 0 will not take anything.
> This option will reduce memory usage and improve performance (measurable
> on small systems), but for that same reason this specified size cannot
> be implemented up to the byte exact.
286c309
<     
---
> 
333c356,357
< embedded artwork.  To do this, set the environment variable AUDIO_SCAN_NO_ARTWORK:
---
> embedded artwork.  To do this, either set the environment variable
> AUDIO_SCAN_NO_ARTWORK or pass a artwork size limit:
338,343c362,373
< This will return the length of the embedded artwork instead of the actual image data.
< In some cases it will also return a byte offset to the image data, which can be used
< to extract the image using more efficient means.  Note that the offset is not always
< returned so if you want to use this data make sure to check for offset.  If offset
< is not present, the only way to get the image data is to perform a normal tag scan
< without the environment variable set.
---
>     my $tags = Audio::Scan->scan_tags($file, {artwork_limit => 100_000});
> 
> The returned $tag structure will always contain the artwork_size value
> in case of any artwork.  The AUDIO_SCAN_NO_ARTWORK set to "1" overrules
> the parameter value.
> 
> In some cases it will also return a byte offset to the image data,
> which can be used to extract the image using more efficient means.
> Note that the offset is not always returned so if you want to use this
> data make sure to check for offset.  If offset is not present, the only
> way to get the image data is to perform a normal tag scan without the
> environment variable set.
345,346c375,376
< One limitation that currently exists is that memory for embedded images is still
< allocated for ASF and Ogg Vorbis files.
---
> One limitation that currently exists is that memory for embedded images
> is still allocated for ASF and Ogg Vorbis files.
350c380
< ID3 (MP3, AAC, WAV, AIFF):
---
> ID3 (MP3, AAC, WAV, AIFF)
352,353c382,383
<     $tags->{APIC}->[3]: image length
<     $tags->{APIC}->[4]: image offset (unless APIC would need unsynchronization)
---
>     $info->{artwork_size}   
>     $info->{artwork_offset}    unless APIC would need unsync
355c385
< MP4:
---
> MP4, APE, Musepack, WavPack, MP3 with APEv2:
357,358c387,388
<     $tags->{COVR}: image length
<     $tags->{COVR_offset}: image offset (always available)
---
>     $info->{artwork_size}
>     $info->{artwork_offset}    always available
360c390,391
< Ogg Vorbis:
---
> Ogg Vorbis: (image offset is not supported with Vorbis because the data
> is always base64-encoded)
362,363c393
<     $tags->{ALLPICTURES}->[0]->{image_data}: image length
<     Image offset is not supported with Vorbis because the data is always base64-encoded.
---
>     $tags->{ALLPICTURES}->[0]->{artwork_size}
367,368c397,398
<     $tags->{ALLPICTURES}->[0]->{image_data}: image length
<     $tags->{ALLPICTURES}->[0]->{offset}: image offset (always available)
---
>     $tags->{ALLPICTURES}->[0]->{artwork_size}
>     $tags->{ALLPICTURES}->[0]->{artwork_offset}
372,378c402,403
<     $tags->{'WM/Picture'}->{image}: image length
<     $tags->{'WM/Picture'}->{offset}: image offset (always available)
< 
< APE, Musepack, WavPack, MP3 with APEv2:
< 
<     $tags->{'COVER ART (FRONT)'}: image length
<     $tags->{'COVER ART (FRONT)_offset'}: image offset (always available)
---
>     $tags->{'WM/Picture'}->{artwork_size}
>     $tags->{'WM/Picture'}->{artwork_offset}   always available
428,431c453,457
< Raw tags are returned as found.  This means older tags such as ID3v1 and ID3v2.2/v2.3
< are converted to ID3v2.4 tag names.  Multiple instances of a tag in a file will be returned
< as arrays.  Complex tags such as APIC and COMM are returned as arrays.  All tag fields are
< converted to upper-case.  All text is converted to UTF-8.
---
> Raw tags are returned as found.  This means older tags such as ID3v1 and
> ID3v2.2/v2.3 are converted to ID3v2.4 tag names.  Multiple instances of a
> tag in a file will be returned as arrays.  Complex tags such as APIC and
> COMM are returned as arrays.  All tag fields are converted to upper-case.
> All text is converted to UTF-8.
487c513
<         
---
> 
499c525
<         
---
> 
502,503c528,530
< Tags are returned in a hash with all keys converted to upper-case.  Keys starting with
< 0xA9 (copyright symbol) will have this character stripped out.  Sample tag data:
---
> Tags are returned in a hash with all keys converted to upper-case.
> Keys starting with 0xA9 (copyright symbol) will have this character
> stripped out.  Sample tag data:
616c643
<     
---
> 
666,668c693,695
< The streams array contains metadata related to an individul stream within the file.
< The following metadata may be returned:
<     
---
> The streams array contains metadata related to an individul stream within
> the file.  The following metadata may be returned:
> 
Only in Audio-Scan-0.93.5: Makefile
diff -r Audio-Scan-0.93/MANIFEST Audio-Scan-0.93.5/MANIFEST
243a244
> tools/audioscan.pl
Only in Audio-Scan-0.93.5: MYMETA.json
Only in Audio-Scan-0.93.5: MYMETA.yml
Only in Audio-Scan-0.93.5: pm_to_blib
Only in Audio-Scan-0.93.5: Scan.bs
Only in Audio-Scan-0.93.5: Scan.c
Only in Audio-Scan-0.93.5: Scan.o
diff -r Audio-Scan-0.93/Scan.xs Audio-Scan-0.93.5/Scan.xs
208c208
< _scan( char *, char *suffix, PerlIO *infile, SV *path, int filter, int md5_size, int md5_offset )
---
> _scan( char *, char *suffix, PerlIO *infile, SV *path, int filter, int md5_size, int md5_offset, unsigned long _artwork_limit )
213c213
<   
---
> 
216a217,218
>   artwork_limit = _artwork_limit;
> 
220a223
>     my_hv_store(RETVAL, "format", newSVpv(hdl->type, 0));
diff -r Audio-Scan-0.93/src/ape.c Audio-Scan-0.93.5/src/ape.c
292c292
<   
---
>  
325,330c325,332
<       if ( _env_true("AUDIO_SCAN_NO_ARTWORK") ) {
<         // Don't read artwork, just return the size
<         value = newSVuv(size - (val_length + 1) );
<         
<         my_hv_store( tag->tags, "COVER ART (FRONT)_offset", newSVuv(tag->offset + val_length + 1) );
<         
---
>       uint32_t art_offset = tag->offset + val_length + 1;
>       uint32_t art_size   = size - val_length - 1;
>       my_hv_store( tag->info, "artwork_size",   newSVuv(art_size) );
>       my_hv_store( tag->info, "artwork_offset", newSVuv(art_offset) );
> 
>       if ( _artwork_too_large(art_size) ) {
>         value = &PL_sv_undef;
>         my_hv_store(tag->tags, "COVER ART (FRONT)_offset", newSVuv(art_offset));
diff -r Audio-Scan-0.93/src/asf.c Audio-Scan-0.93.5/src/asf.c
1480a1481
>   my_hv_store( picture, "artwork_size", newSVuv(image_len) );
1482,1483c1483
<   if ( _env_true("AUDIO_SCAN_NO_ARTWORK") ) {
<     my_hv_store( picture, "image", newSVuv(image_len) );
---
>   if ( _artwork_too_large(image_len) ) {
diff -r Audio-Scan-0.93/src/common.c Audio-Scan-0.93.5/src/common.c
19a20,24
> /* artwork_limit is set as parameter from _scan(), but nearly impossible
>  * to pass around cleanly everywhere.
>  */
> uint32_t artwork_limit = -1;
> 
326a332
>   my_hv_store( picture, "artwork_size", newSVuv(*pic_length) );
328,331c334
<   if ( _env_true("AUDIO_SCAN_NO_ARTWORK") ) {
<     my_hv_store( picture, "image_data", newSVuv(*pic_length) );
<   }
<   else {
---
>   if ( !_artwork_too_large(*pic_length) ) {
336c339
<     my_hv_store( picture, "image_data", newSVpvn( buffer_ptr(buf), *pic_length ) );
---
>     my_hv_store( picture, "image_data", newSVpvn(buffer_ptr(buf), *pic_length));
340a344,351
> 
> bool _artwork_too_large(uint32_t artwork_size)
> {
>     return _env_true("AUDIO_SCAN_NO_ARTWORK") ? 1
>          : artwork_limit == -1                ? 0
>          : artwork_size > artwork_limit;
> }
> 
diff -r Audio-Scan-0.93/src/flac.c Audio-Scan-0.93.5/src/flac.c
902,903c902,903
<   if ( _env_true("AUDIO_SCAN_NO_ARTWORK") ) {
<     my_hv_store( picture, "offset", newSVuv(flac->audio_offset - pic_length) );
---
>   my_hv_store( picture, "artwork_offset", newSVuv(flac->audio_offset - pic_length) );
>   if ( _artwork_too_large(pic_length) ) {
904a905,906
>     // old name, kept for compatibility
>     my_hv_store( picture, "offset", newSVuv(flac->audio_offset - pic_length) );
diff -r Audio-Scan-0.93/src/id3.c Audio-Scan-0.93.5/src/id3.c
583a584
>         my_hv_store( id3->info, "artwork_size", newSVuv(decoded_size) );
585c586
<       
---
>  
589,590c590,592
<         if ( !strcmp(id, "APIC") && _env_true("AUDIO_SCAN_NO_ARTWORK") ) {
<           DEBUG_TRACE("    Would un-synchronize APIC frame, but ignoring because of AUDIO_SCAN_NO_ARTWORK\n");
---
>         if ( !strcmp(id, "APIC") && _artwork_too_large(decoded_size) ) {
> 
>           DEBUG_TRACE("    Would un-synchronize APIC frame, but ignoring because skip of large artwork\n");
593c595,596
<           // XXX this would break if we have a compressed + unsync APIC frame but not very likely in the real world
---
>           // XXX this would break if we have a compressed + unsync APIC frame
>           // but not very likely in the real world
606d608
<           
735,736c737,738
<   uint8_t buffer_art = ( !strcmp(id, "APIC") ) ? 1 : 0;
<   uint8_t skip_art   = ( buffer_art && _env_true("AUDIO_SCAN_NO_ARTWORK") ) ? 1 : 0;
---
>   uint8_t buffer_art = strcmp(id, "APIC")==0;
>   uint8_t skip_art   = buffer_art && _artwork_too_large(size);
748c750
<     DEBUG_TRACE("    partial read due to AUDIO_SCAN_NO_ARTWORK\n");
---
>     DEBUG_TRACE("    partial read due to skipping art\n");
833c835
<         strtol(sptr, &tmp, 0);
---
>         (void)strtol(sptr, &tmp, 0);
1156a1159,1166
>           my_hv_store( id3->info, "artwork_size", newSVuv(size-read));
> 
>           if (id3->tag_data_safe && (size - read) > 0) {
>             // Record offset of APIC image data too, unless the data needs to be unsynchronized or is empty
>             uint32_t offset = id3->offset + id3->size - id3->size_remain + read;
>             my_hv_store(id3->info, "artwork_offset", newSVuv(offset));
>           }
> 
1159,1164d1168
<             av_push( framedata, newSVuv(size - read) );
<             
<             // Record offset of APIC image data too, unless the data needs to be unsynchronized or is empty
<             if (id3->tag_data_safe && (size - read) > 0)
<               av_push( framedata, newSVuv(id3->offset + (id3->size - id3->size_remain) + read) );
<             
1168d1171
<           
diff -r Audio-Scan-0.93/src/mp4.c Audio-Scan-0.93.5/src/mp4.c
1721c1721,1722
<   
---
>   uint32_t art_size   = size - 8;
>   uint32_t art_offset = mp4->audio_offset + (mp4->size - mp4->rsize) + 24;
1723c1724,1730
<   if ( FOURCC_EQ(ckey, "COVR") && _env_true("AUDIO_SCAN_NO_ARTWORK") ) {
---
> 
>   if ( FOURCC_EQ(ckey, "COVR")) {
>     my_hv_store(mp4->info, "artwork_size",   newSVuv(art_size));
>     my_hv_store(mp4->info, "artwork_offset", newSVuv(art_offset));
>   }
> 
>   if ( FOURCC_EQ(ckey, "COVR") && _artwork_too_large(art_size) ) {
1725,1728c1732,1733
<     value = newSVuv(size - 8);
<     
<     my_hv_store( mp4->tags, "COVR_offset", newSVuv(mp4->audio_offset + (mp4->size - mp4->rsize) + 24) );
<     
---
>     value = &PL_sv_undef;
>     my_hv_store( mp4->tags, "COVR_offset", newSVuv(art_offset));
diff -r Audio-Scan-0.93/src/ogg.c Audio-Scan-0.93.5/src/ogg.c
443a444
>       uint32_t pic_length;
454,459c455,458
<       if ( _env_true("AUDIO_SCAN_NO_ARTWORK") ) {
<         my_hv_store( picture, "image_data", newSVuv(len - 9) );
<         buffer_consume(vorbis_buf, len);
<       }
<       else {
<         int pic_length;
---
>       buffer_consume(vorbis_buf, 9);
>       pic_length = _decode_base64(buffer_ptr(vorbis_buf));
>       DEBUG_TRACE("  found picture of length %d\n", pic_length);
>       my_hv_store( picture, "artwork_size", newSVuv(pic_length) );
461,464c460
<         buffer_consume(vorbis_buf, 9);
<         pic_length = _decode_base64( buffer_ptr(vorbis_buf) );
<         DEBUG_TRACE("  found picture of length %d\n", pic_length);
<         
---
>       if ( ! _artwork_too_large(pic_length) ) {
466d461
<         buffer_consume(vorbis_buf, len - 9);
468c463,464
<       
---
>       buffer_consume(vorbis_buf, len - 9);
>  
478d473
< 
480d474
< 
diff -r Audio-Scan-0.93/t/aiff.t Audio-Scan-0.93.5/t/aiff.t
5c5
< use Test::More tests => 31;
---
> use Test::More tests => 32;
9a10
> ok(1, 'loaded');
41,42c42,43
<     is( $tags->{APIC}->[3], 2277, 'APIC length ok' );
<     is( $tags->{APIC}->[4], 2414, 'APIC offset ok' );
---
>     is( $info->{artwork_size}, 2277, 'APIC length ok' );
>     is( $info->{artwork_offset}, 2414, 'APIC offset ok' );
76c77
< }
\ No newline at end of file
---
> }
diff -r Audio-Scan-0.93/t/asf.t Audio-Scan-0.93.5/t/asf.t
5c5
< use Test::More tests => 142;
---
> use Test::More tests => 149;
139c139
<     
---
>     is($s->{format}, 'asf');
141,142c141,143
<     
<     is( $tags->{'WM/Picture'}->{image}, 2103, 'WM/Picture with AUDIO_SCAN_NO_ARTWORK ok' );
---
> 
>     ok( !$tags->{'WM/Picture'}->{image}, 'no image ');
>     is( $tags->{'WM/Picture'}->{artwork_size}, 2103, 'WM/Picture with AUDIO_SCAN_NO_ARTWORK ok' );
145a147,171
> # Test limiting artwork
> {
>     local $ENV{AUDIO_SCAN_NO_ARTWORK} = 0;
>  
>     my $s = Audio::Scan->scan( _f('wma92-vbr.wma')
>       , {artwork_limit => 2200} );
>     my $tags = $s->{tags};
>     ok( $tags->{'WM/Picture'}->{image}, 'yes, image ');
>     is( $tags->{'WM/Picture'}->{artwork_size}, 2103, 'WM/Picture with AUDIO_SCAN_NO_ARTWORK ok' );
> #   is( $tags->{'WM/Picture'}->{offset}, 555, 'WM/Picture with AUDIO_SCAN_NO_ARTWORK offset ok' );
> 
> }
> 
> {
>     local $ENV{AUDIO_SCAN_NO_ARTWORK} = 0;
>  
>     my $s = Audio::Scan->scan( _f('wma92-vbr.wma')
>       , {artwork_limit => 2100} );
>     my $tags = $s->{tags};
>     ok( !$tags->{'WM/Picture'}->{image}, 'no image ');
>     is( $tags->{'WM/Picture'}->{artwork_size}, 2103, 'WM/Picture with AUDIO_SCAN_NO_ARTWORK ok' );
>     is( $tags->{'WM/Picture'}->{offset}, 555, 'WM/Picture with AUDIO_SCAN_NO_ARTWORK offset ok' );
> 
> }
> 
149d174
<     
151d175
<     
154c178
<     is( $tags->{'WM/Picture'}->{image}, 88902, 'WM/Picture in Header Extension/Metadata Library length ok' );
---
>     is( $tags->{'WM/Picture'}->{artwork_size}, 88902, 'WM/Picture in Header Extension/Metadata Library length ok' );
359c383
< }
\ No newline at end of file
---
> }
diff -r Audio-Scan-0.93/t/flac.t Audio-Scan-0.93.5/t/flac.t
116c116
<     is( $pic->{image_data}, 37175, 'JPEG with AUDIO_SCAN_NO_ARTWORK ok ');
---
>     is( $pic->{artwork_size}, 37175, 'JPEG with AUDIO_SCAN_NO_ARTWORK ok ');
diff -r Audio-Scan-0.93/t/mp3.t Audio-Scan-0.93.5/t/mp3.t
632c632
<     my $tags = $s->{tags};
---
>     my $info = $s->{info};
634,635c634,635
<     is( $tags->{APIC}->[3], 2103, 'ID3v2.4 APIC JPEG picture with AUDIO_SCAN_NO_ARTWORK=1 ok ');
<     is( $tags->{APIC}->[4], 351, 'ID3v2.4 APIC JPEG picture with AUDIO_SCAN_NO_ARTWORK=1 offset value ok' );
---
>     is( $info->{artwork_size}, 2103, 'ID3v2.4 APIC JPEG picture with AUDIO_SCAN_NO_ARTWORK=1 ok ');
>     is( $info->{artwork_offset}, 351, 'ID3v2.4 APIC JPEG picture with AUDIO_SCAN_NO_ARTWORK=1 offset value ok' );
1150c1150
<     my $tags = $s->{tags};
---
>     my $info = $s->{info};
1153,1154c1153,1154
<     is( $tags->{APIC}->[3], 46240, 'v2.4 APIC unsync no-artwork length ok' );
<     is( !defined $tags->{APIC}->[4], 1, 'v2.4 APIC unsync no-artwork has no offset ok' );
---
>     is( $info->{artwork_size}, 46240, 'v2.4 APIC unsync no-artwork length ok' );
>     is( $info->{artwork_offset}, 302, 'v2.4 APIC unsync no-artwork has no offset ok' );
diff -r Audio-Scan-0.93/t/mp4.t Audio-Scan-0.93.5/t/mp4.t
5c5
< use Test::More tests => 120;
---
> use Test::More tests => 122;
179,182c179,185
< 	my $tags = $s->{tags};
< 	
< 	is( $tags->{COVR}, 2103, 'COVR with AUDIO_SCAN_NO_ARTWORK ok' );
< 	is( $tags->{COVR_offset}, 1926, 'COVR with AUDIO_SCAN_NO_ARTWORK offset ok' );
---
>     my $tags = $s->{tags};
>     ok( !$tags->{COVR}, 'COVR with AUDIO_SCAN_NO_ARTWORK ok' );
>     is( $tags->{COVR_offset}, 1926, 'COVR with AUDIO_SCAN_NO_ARTWORK offset ok' );
> 
>     my $info = $s->{info};
>     is( $info->{artwork_size}, 2103, 'COVR with AUDIO_SCAN_NO_ARTWORK ok' );
>     is( $info->{artwork_offset}, 1926, 'COVR with AUDIO_SCAN_NO_ARTWORK offset ok' );
303c306
< }
\ No newline at end of file
---
> }
diff -r Audio-Scan-0.93/t/musepack.t Audio-Scan-0.93.5/t/musepack.t
5c5
< use Test::More tests => 34;
---
> use Test::More tests => 36;
73c73
<     is( $tags->{'COVER ART (FRONT)'}, 1761, 'APEv2 AUDIO_SCAN_NO_ARTWORK cover length ok' );
---
>     ok(! $tags->{'COVER ART (FRONT)'}, 'APEv2 AUDIO_SCAN_NO_ARTWORK no coverok' );
74a75,78
> 
>     my $info = $s->{info};
>     is($info->{'artwork_size'}, 1761, 'APEv2 AUDIO_SCAN_NO_ARTWORK cover length ok' );
>     is($info->{'artwork_offset'}, 68925, 'APEv2 AUDIO_SCAN_NO_ARTWORK cover offset ok' );
diff -r Audio-Scan-0.93/t/ogg.t Audio-Scan-0.93.5/t/ogg.t
90c90
<     is( $pic->{image_data}, 104704, 'COVERART length ok' ); # this is the base64-encoded length
---
>     is( $pic->{artwork_size}, 78527, 'COVERART length ok' );
121c121
<     is( $pic->{image_data}, 25078, 'METADATA_BLOCK_PICTURE length ok' );
---
>     is( $pic->{artwork_size}, 25078, 'METADATA_BLOCK_PICTURE length ok' );
126c126
<     is( $pic2->{image_data}, 1761, 'METADATA_BLOCK_PICTURE pic2 length ok' );
---
>     is( $pic2->{artwork_size}, 1761, 'METADATA_BLOCK_PICTURE pic2 length ok' );
diff -r Audio-Scan-0.93/t/wav.t Audio-Scan-0.93.5/t/wav.t
5c5
< use Test::More tests => 55;
---
> use Test::More tests => 56;
46,47c46,49
<     is( $tags->{APIC}->[3], 2103, 'APIC length ok' );
<     is( $tags->{APIC}->[4], 2137, 'APIC offset ok' );
---
>     ok(!$tags->{APIC}->[3], 'no image taken');
> 
>     is( $info->{artwork_size}, 2103, 'APIC length ok' );
>     is( $info->{artwork_offset}, 2137, 'APIC offset ok' );
130c132
< }
\ No newline at end of file
---
> }
Only in Audio-Scan-0.93.5/tools: 1.jpg
Only in Audio-Scan-0.93.5/tools: audioscan.pl
