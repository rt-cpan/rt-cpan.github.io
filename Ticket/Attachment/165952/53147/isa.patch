diff -ur lib/UNIVERSAL/isa.pm~ UNIVERSAL-isa/lib/UNIVERSAL/isa.pm
--- lib/UNIVERSAL/isa.pm~	2005-11-07 00:17:31.000000000 -0800
+++ lib/UNIVERSAL/isa.pm	2006-01-14 01:03:54.000000000 -0800
@@ -22,55 +22,67 @@
 	*{caller() . "::isa"} = \&UNIVERSAL::isa if (@_ > 1 and $_[1] eq "isa");
 }
 
-sub UNIVERSAL::isa {
-	# not an object or a class name, we can skip
-	unless ( blessed($_[0]) )
+sub UNIVERSAL::isa
+{
+	goto &$orig if $recursing;
+	my $type = invocant_type( @_ );
+	$type->( @_ );
+}
+
+sub invocant_type
+{
+	my $invocant = shift;
+	return \&nonsense          unless defined( $invocant );
+	return \&object_or_class   if blessed( $invocant );
+	return \&reference         if ref( $invocant );
+	return \&nonsense          unless $invocant;
+	return \&object_or_class;
+}
+
+sub nonsense
+{
+	report_warning( 'on invalid invocant' );
+	return;
+}
+
+sub object_or_class
+{
+	report_warning();
+
+	local $@;
+	local $recursing = 1;
+
+	if ( my $override = eval { $_[0]->can( 'isa' ) } )
 	{
-		if (not defined $_[0] or length $_[0] == 0) {
-			# it's not a class, either... Retain orig behavior
-			# for garbage as first arg
-			goto &$orig;
-		} else {
-			# it's a string, which means it can be a class
-			my $symtable = \%::;
-			my $found    = 1;
-
-			for my $symbol (split( '::', $_[0] )) {
-				$symbol .= '::';
-				unless (exists $symtable->{$symbol}) {
-					$found = 0;
-					last;
-				}
-				$symtable = $symtable->{$symbol};
-			}
-
-			# if it's not a class then it doesn't have it's own dispatch,
-			# so we retain the original behavior
-			goto &$orig unless $found;
+		unless ( $override == \&UNIVERSAL::isa )
+		{
+			my $obj = shift;
+			return $obj->$override( @_ );
 		}
 	}
 
-	# if the object will *really* run a different 'isa' when we invoke it we
-	# need to invoke it. On the other hand if it's not overridden, we just use
-	# the original behavior
-	goto &$orig if (UNIVERSAL::can($_[0], "isa") == \&UNIVERSAL::isa);
-
-	# if we've been called from an overridden isa that we arranged to call, we
-	# are either SUPER:: or explicitly called. in both cases the original ISA
-	# behavior is expected.
-	goto &$orig if $recursing;
+	goto &$orig;
+}
 
-	# the last possible case is that 'isa' is overridden
-	local $recursing = 1;
-	my $obj = shift;
+sub reference
+{
+	report_warning( "Did you mean to use Scalar::Util::reftype() instead?" );
+	goto &$orig;
+}
 
-	if (warnings::enabled()) {
-		my $calling_sub  = ( caller( 1 ) )[3] || '';
-		warnings::warn( "Called UNIVERSAL::isa() as a function, not a method" )
-			if $calling_sub !~ /::isa$/;
-	}
+sub report_warning
+{
+	my $extra   = shift;
+	$extra      = $extra ? " ($extra)" : '';
 
-	return $obj->isa(@_);
+	if (warnings::enabled())
+	{
+		my $calling_sub  = ( caller( 2 ) )[3] || '';
+		return if $calling_sub =~ /::isa$/;
+		warnings::warn(
+			"Called UNIVERSAL::isa() as a function, not a method$extra"
+		)
+	}
 }
 
 __PACKAGE__;
@@ -125,8 +137,6 @@
 
 =head1 COPYRIGHT & LICENSE
 
-Same as perl, blah blah blah, (c) 2005
+Same as perl, blah blah blah, (c) 2005 - 2006.
 
 =cut
-
-
