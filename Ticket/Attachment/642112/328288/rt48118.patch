diff -ruN Locale-Maketext-1.13_85/ChangeLog Locale-Maketext-1.13_86/ChangeLog
--- Locale-Maketext-1.13_85/ChangeLog	2009-07-30 13:51:44.000000000 -0500
+++ Locale-Maketext-1.13_86/ChangeLog	2009-07-30 14:10:43.000000000 -0500
@@ -1,5 +1,10 @@
 Revision history for Perl suite Locale::Maketext
 
+2009-08-04  Adriano Ferreira
+    * Development release 1.13_86
+    
+    some speedup and efficiency tweaks  (thanks Dan Muey)
+    
 2009-08-03  Adriano Ferreira
     * Development release 1.13_85
     
diff -ruN Locale-Maketext-1.13_85/lib/Locale/Maketext.pm Locale-Maketext-1.13_86/lib/Locale/Maketext.pm
--- Locale-Maketext-1.13_85/lib/Locale/Maketext.pm	2009-07-30 14:00:25.000000000 -0500
+++ Locale-Maketext-1.13_86/lib/Locale/Maketext.pm	2009-07-30 15:04:16.000000000 -0500
@@ -10,7 +10,7 @@
 BEGIN { unless(defined &DEBUG) { *DEBUG = sub () {0} } }
 # define the constant 'DEBUG' at compile-time
 
-$VERSION = '1.13_85';
+$VERSION = '1.13_86';
 $VERSION = eval $VERSION;
 @ISA = ();
 
@@ -132,8 +132,8 @@
 
     $handle->{'failure_lex'} ||= {};
     my $lex = $handle->{'failure_lex'};
-
-    my $value = $lex->{$phrase} ||= $handle->_compile($phrase);
+    # tr/X// is a very fast "does this string have this character" check, so we don't even call _compile if we know it will end up being a SCALAR ref
+    my $value = $lex->{$phrase} ||= ($phrase !~ tr/[// ? \"$phrase" : $handle->_compile($phrase));
 
     # Dumbly copied from sub maketext:
     return ${$value} if ref($value) eq 'SCALAR';
@@ -211,11 +211,13 @@
                     # end $Onesided
                     
                     # Nonref means it's not yet compiled.  Compile and replace.
-                    if ($handle->{'use_external_lex_cache'}) {
-                        $value = $handle->{'_external_lex_cache'}{$phrase} = $handle->_compile($value);
+                    if ($handle->{'use_external_lex_cache'}) {   
+                        # tr/X// is a very fast "does this string have this character" check, so we don't even call _compile if we know it will end up being a SCALAR ref
+                        $handle->{'_external_lex_cache'}{$phrase} = $value = ($value !~ tr/[// ? \"$value" : $handle->_compile($value));
                     }
                     else {
-                        $value = $h_r->{$phrase} = $handle->_compile($value);
+                        # tr/X// is a very fast "does this string have this character" check, so we don't even call _compile if we know it will end up being a SCALAR ref
+                        $h_r->{$phrase} = $value = ($value !~ tr/[// ? \"$value" : $handle->_compile($value));
                     }
                 }
                 last;
@@ -225,11 +227,13 @@
             elsif($phrase !~ m/^_/s and ($handle->{'use_external_lex_cache'} ? ( exists $handle->{'_external_lex_cache'}{'_AUTO'} ? $handle->{'_external_lex_cache'}{'_AUTO'} : $h_r->{'_AUTO'} ) : $h_r->{'_AUTO'})) {
                 # it's an auto lex, and this is an autoable key!
                 DEBUG and warn "  Automaking \"$phrase\" into $h_r\n";
-                if ($handle->{'use_external_lex_cache'}) {
-                    $value = $handle->{'_external_lex_cache'}{$phrase} = $handle->_compile($phrase);
+                if ($handle->{'use_external_lex_cache'}) {   
+                    # tr/X// is a very fast "does this string have this character" check, so we don't even call _compile if we know it will end up being a SCALAR ref
+                    $handle->{'_external_lex_cache'}{$phrase} = $value = ($phrase !~ tr/[// ? \"$phrase" : $handle->_compile($phrase));
                 }
                 else {
-                    $value = $h_r->{$phrase} = $handle->_compile($phrase);
+                    # tr/X// is a very fast "does this string have this character" check, so we don't even call _compile if we know it will end up being a SCALAR ref
+                    $h_r->{$phrase} = $value = ($phrase !~ tr/[// ? \"$phrase" : $handle->_compile($phrase));
                 }
                 last;
             }
@@ -505,16 +509,14 @@
     # This big scary routine compiles an entry.
     # It returns either a coderef if there's brackety bits in this, or
     #  otherwise a ref to a scalar.
-
-    my $target = ref($_[0]) || $_[0];
-
-    my(@code);
-    my(@c) = (''); # "chunks" -- scratch.
-    my $call_count = 0;
-    my $big_pile = '';
+    
+    # tr/X// is a very fast "does this string have this character" check, so we don't need to continue if we know it will end up being a SCALAR ref
+    return \"$_[1]" if $_[1] !~ tr/[//;
+    
+    my ($target,$call_count,$big_pile,@c,@code) = ( (ref($_[0]) || $_[0]), 0, '', '' );
     {
-        my $in_group = 0; # start out outside a group
-        my($m, @params); # scratch
+                                          # start out outside a group
+        my($in_group, $m, @params) = (0); # scratch
 
         while($_[1] =~  # Iterate over chunks.
             m/\G(
