? cvsdiff
? patch
? patch1
? test/s/mounted.pid
Index: Makefile.PL
===================================================================
RCS file: /cvsroot/fuse/perl/Makefile.PL,v
retrieving revision 1.15
diff -u -r1.15 Makefile.PL
--- Makefile.PL	20 Jan 2007 21:02:55 -0000	1.15
+++ Makefile.PL	10 Nov 2007 05:24:16 -0000
@@ -11,7 +11,8 @@
 if (! $ver && ! $ver2 && ! $ver3) {
 	# make CPANPLUS happy and don't report errors if fuse isn't installed
 	die("No support for os: $^O\n",
-		"You need to have fuse-dev (or similar) package installed and have sufficient permissions in order to install this module\n"
+		"You need to have fuse-dev (or similar) package installed and have sufficient permissions in order to install this module\n",
+		$^O eq 'darwin' ? ("One option on Mac is http://code.google.com/p/macfuse/\n") : (),
 	);
 }
 if ($ver && $ver + 0 < 2.5) {
Index: examples/loopback.pl
===================================================================
RCS file: /cvsroot/fuse/perl/examples/loopback.pl,v
retrieving revision 1.5
diff -u -r1.5 loopback.pl
--- examples/loopback.pl	2 Jan 2006 23:49:41 -0000	1.5
+++ examples/loopback.pl	10 Nov 2007 05:24:16 -0000
@@ -6,14 +6,33 @@
 use IO::File;
 use POSIX qw(ENOENT ENOSYS EEXIST EPERM O_RDONLY O_RDWR O_APPEND O_CREAT);
 use Fcntl qw(S_ISBLK S_ISCHR S_ISFIFO SEEK_SET);
-require 'syscall.ph'; # for SYS_mknod and SYS_lchown
+my $can_syscall = eval {
+	require 'syscall.ph'; # for SYS_mknod and SYS_lchown
+};
+if (!$can_syscall && open my $fh, '<', '/usr/include/sys/syscall.h') {
+	local $/ = undef;
+	my %sys = do { local $/ = undef;
+			<$fh> =~ m/\#define \s+ (\w+) \s+ (\d+)/gxms;
+        };
+	close $fh;
+	if ($sys{SYS_mknod} && $sys{SYS_lchown}) {
+		*SYS_mknod  = sub { $sys{SYS_mknod}  };
+		*SYS_lchown = sub { $sys{SYS_lchown} };
+		$can_syscall = 1;
+	}
+}
 
-my $tmp_path = "/tmp/fusetest-" . $ENV{LOGNAME};
+my $tmp = -d '/private' ? '/private/tmp' : '/tmp';
+my $tmp_path = "$tmp/fusetest-" . $ENV{LOGNAME};
 if (! -e $tmp_path) {
 	mkdir($tmp_path) || die "can't create $tmp_path: $!";
 }
 
-sub fixup { return $tmp_path . shift }
+sub fixup { print STDERR "fixup $_[0] from @{[caller]}\n";
+            my ($path) = @_;
+            return $tmp_path if $path eq '/';
+            return $tmp_path . $path;
+}
 
 sub x_getattr {
 	my ($file) = fixup(shift);
@@ -82,6 +101,7 @@
 }
 sub x_link { return link(fixup(shift),fixup(shift)) ? 0 : -$! }
 sub x_chown {
+	return -ENOSYS() if ! $can_syscall;
 	my ($fn) = fixup(shift);
 	print "nonexistent $fn\n" unless -e $fn;
 	my ($uid,$gid) = @_;
@@ -105,6 +125,7 @@
 sub x_rmdir { return 0 if rmdir fixup(shift); return -$!; }
 
 sub x_mknod {
+	return -ENOSYS() if ! $can_syscall;
 	# since this is called for ALL files, not just devices, I'll do some checks
 	# and possibly run the real mknod command.
 	my ($file, $modes, $dev) = @_;
Index: examples/loopback_t.pl
===================================================================
RCS file: /cvsroot/fuse/perl/examples/loopback_t.pl,v
retrieving revision 1.2
diff -u -r1.2 loopback_t.pl
--- examples/loopback_t.pl	2 Jan 2006 23:51:57 -0000	1.2
+++ examples/loopback_t.pl	10 Nov 2007 05:24:16 -0000
@@ -8,7 +8,20 @@
 use IO::File;
 use POSIX qw(ENOENT ENOSYS EEXIST EPERM O_RDONLY O_RDWR O_APPEND O_CREAT);
 use Fcntl qw(S_ISBLK S_ISCHR S_ISFIFO SEEK_SET);
-require 'syscall.ph'; # for SYS_mknod and SYS_lchown
+my $can_syscall = eval {
+	require 'syscall.ph'; # for SYS_mknod and SYS_lchown
+};
+if (!$can_syscall && open my $fh, '<', '/usr/include/sys/syscall.h') {
+	my %sys = do { local $/ = undef;
+			<$fh> =~ m/\#define \s+ (\w+) \s+ (\d+)/gxms;
+        };
+	close $fh;
+	if ($sys{SYS_mknod} && $sys{SYS_lchown}) {
+		*SYS_mknod  = sub { $sys{SYS_mknod}  };
+		*SYS_lchown = sub { $sys{SYS_lchown} };
+		$can_syscall = 1;
+	}
+}
 
 sub fixup { return "/tmp/fusetest-" . $ENV{LOGNAME} . shift }
 
@@ -79,6 +92,7 @@
 }
 sub x_link { return link(fixup(shift),fixup(shift)) ? 0 : -$! }
 sub x_chown {
+	return -ENOSYS() if ! $can_syscall;
 	my ($fn) = fixup(shift);
 	print "nonexistent $fn\n" unless -e $fn;
 	my ($uid,$gid) = @_;
@@ -102,6 +116,7 @@
 sub x_rmdir { return 0 if rmdir fixup(shift); return -$!; }
 
 sub x_mknod {
+	return -ENOSYS() if ! $can_syscall;
 	# since this is called for ALL files, not just devices, I'll do some checks
 	# and possibly run the real mknod command.
 	my ($file, $modes, $dev) = @_;
Index: test/helper.pm
===================================================================
RCS file: /cvsroot/fuse/perl/test/helper.pm,v
retrieving revision 1.4
diff -u -r1.4 helper.pm
--- test/helper.pm	29 Nov 2006 13:28:39 -0000	1.4
+++ test/helper.pm	10 Nov 2007 05:24:16 -0000
@@ -7,16 +7,19 @@
 our ($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);
 @ISA = "Exporter";
 @EXPORT_OK = qw($_loop $_point $_pidfile $_real);
-our($_loop, $_point, $_pidfile, $_real) = ("","/tmp/fusemnt-".$ENV{LOGNAME},"test/s/mounted.pid","/tmp/fusetest-".$ENV{LOGNAME});
-$_loop = $Config{useithreads} ? "examples/loopback_t.pl" : "examples/loopback.pl";
+my $tmp = -d '/private' ? '/private/tmp' : '/tmp';
+our($_loop, $_point, $_pidfile, $_real) = ("","$tmp/fusemnt-".$ENV{LOGNAME},"test/s/mounted.pid","$tmp/fusetest-".$ENV{LOGNAME});
+$_loop = $^O ne 'darwin' && $Config{useithreads} ? "examples/loopback_t.pl" : "examples/loopback.pl";
 if($0 !~ qr|s/u?mount\.t$|) {
 	my ($reject) = 1;
-	if(-f $_pidfile) {
-		unless(POSIX::WEXITSTATUS(system("ps `cat $_pidfile` | grep \"$_loop $_point\" >/dev/null"))) {
-			if(`mount | grep "on $_point"`) {
+	if(open my $fh, '<', $_pidfile) {
+		my $pid = do {local $/ = undef; <$fh>};
+		close $fh;
+		if(kill 0, $pid) {
+			if(`mount` =~ m{on (?:/private)?$_point }) {
 				$reject = 0;
 			} else {
-				system("kill `cat $_pidfile`");
+				kill 1, $pid;
 			}
 		}
 	}
Index: test/statfs.t
===================================================================
RCS file: /cvsroot/fuse/perl/test/statfs.t,v
retrieving revision 1.3
diff -u -r1.3 statfs.t
--- test/statfs.t	2 Jan 2006 23:52:14 -0000	1.3
+++ test/statfs.t	10 Nov 2007 05:24:16 -0000
@@ -1,7 +1,10 @@
 #!/usr/bin/perl
 use test::helper qw($_real $_point);
 use Test::More;
-require 'syscall.ph'; # for SYS_statfs
+eval {
+   require 'syscall.ph'; # for SYS_statfs
+} or plan skip_all => 'No syscall.ph';
+
 plan tests => 7;
 my ($statfs_data) = 0x00 x 8 x 16;
 my ($tmp) = $_point;
Index: test/s/mount.t
===================================================================
RCS file: /cvsroot/fuse/perl/test/s/mount.t,v
retrieving revision 1.6
diff -u -r1.6 mount.t
--- test/s/mount.t	30 Jul 2006 18:41:40 -0000	1.6
+++ test/s/mount.t	10 Nov 2007 05:24:16 -0000
@@ -2,7 +2,13 @@
 use test::helper qw($_point $_loop $_real $_pidfile);
 use strict;
 use Test::More tests => 3;
-ok(!(scalar grep(/ on $_point /,`cat /proc/mounts`)),"already mounted");
+
+sub is_mounted {
+	my $diag = -d '/proc' ? `cat /proc/mounts` : `mount`;
+	return $diag =~ m{ (?:/private)?$_point };
+}
+
+ok(!is_mounted(),"already mounted");
 ok(-f $_loop,"loopback exists");
 
 if(!fork()) {
@@ -13,6 +19,8 @@
 	mkdir $_real;
 	`echo $$ >test/s/mounted.pid`;
 	diag "mounting $_loop to $_point";
+	open STDOUT, '>', '/tmp/fusemnt.log';
+	open STDERR, '>&', \*STDOUT;
 	exec("perl -Iblib/lib -Iblib/arch $_loop $_point");
 	exit(1);
 }
@@ -20,7 +28,7 @@
 my ($success, $count) = (0,0);
 while ($count++ < 50 && !$success) {
 	select(undef, undef, undef, 0.1);
-    ($success) = `cat /proc/mounts` =~ / $_point /;
+    ($success) = is_mounted();
 }
 diag "Mounted in ", $count/10, " secs";
 
Index: test/s/umount.t
===================================================================
RCS file: /cvsroot/fuse/perl/test/s/umount.t,v
retrieving revision 1.3
diff -u -r1.3 umount.t
--- test/s/umount.t	21 Dec 2005 16:33:38 -0000	1.3
+++ test/s/umount.t	10 Nov 2007 05:24:16 -0000
@@ -4,6 +4,9 @@
 use Test::More tests => 1;
 use POSIX qw(WEXITSTATUS);
 system("fusermount -u $_point");
+if(POSIX::WEXITSTATUS($?) != 0) {
+	system("umount $_point");
+}
 ok(POSIX::WEXITSTATUS($?) == 0,"unmount");
 system("rm -rf $_real $_pidfile");
 rmdir($_point);
