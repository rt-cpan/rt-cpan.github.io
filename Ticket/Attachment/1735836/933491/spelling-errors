Description: Fix spelling errors
Author: Angel Abad <angel@debian.org>
Forwarded: yes
Bug: https://rt.cpan.org/Public/Bug/Display.html?id=118537
Last-Updated: 2016-10-29

--- a/MPFR.xs
+++ b/MPFR.xs
@@ -6530,7 +6530,7 @@
     croak("2nd arg to Math::MPFR::_d_bytes_fr must be 53");
 
   if(mpfr_get_prec(*str) != 53)
-    croak("Precison of 1st arg supplied to _d_bytes_fr must be 53, not %u", mpfr_get_prec(*str));
+    croak("Precision of 1st arg supplied to _d_bytes_fr must be 53, not %u", mpfr_get_prec(*str));
 
   if((size_t)bits != DBL_MANT_DIG)
     croak("2nd arg (%u) supplied to Math::MPFR::_d_bytes_fr does not match DBL_MANT_DIG (%u)", bits, DBL_MANT_DIG);
@@ -6631,7 +6631,7 @@
     croak("2nd arg to Math::MPFR::_dd_bytes must be 106");
 
   if(mpfr_get_prec(*str) != 2098)
-    croak("Precison of 1st arg supplied to _dd_bytes_fr must be 2098, not %u", mpfr_get_prec(*str));
+    croak("Precision of 1st arg supplied to _dd_bytes_fr must be 2098, not %u", mpfr_get_prec(*str));
 
   mpfr_init2(temp, 2098);
 
@@ -6743,7 +6743,7 @@
   }
 
   if(mpfr_get_prec(*str) != bits)
-    croak("Precison of 1st arg (%u) supplied to _ld_bytes_fr must match 2nd arg (%d)", mpfr_get_prec(*str), bits);
+    croak("Precision of 1st arg (%u) supplied to _ld_bytes_fr must match 2nd arg (%d)", mpfr_get_prec(*str), bits);
 
   if((size_t)bits != LDBL_MANT_DIG)
     croak("2nd arg (%u) supplied to Math::MPFR::_ld_bytes_fr does not match LDBL_MANT_DIG (%u)", bits, LDBL_MANT_DIG);
@@ -6849,7 +6849,7 @@
     croak("2nd arg to Math::MPFR::_f128_bytes_fr must be 113");
 
   if(mpfr_get_prec(*str) != 113)
-    croak("Precison of 1st arg supplied to _f128_bytes_fr must be 113, not %u", mpfr_get_prec(*str));
+    croak("Precision of 1st arg supplied to _f128_bytes_fr must be 113, not %u", mpfr_get_prec(*str));
 
   if((size_t)bits != FLT128_MANT_DIG)
     croak("2nd arg (%u) supplied to Math::MPFR::_f128_bytes_fr does not match FLT128_MANT_DIG (%u)", bits, FLT128_MANT_DIG);
--- a/t/bytes.t
+++ b/t/bytes.t
@@ -277,7 +277,7 @@
 
 eval {Math::MPFR::_d_bytes_fr($fr_breaker, 53);};
 
-if($@ =~ /^Precison of 1st arg supplied to _d_bytes_fr must be 53, not 200/) {print "ok 14\n"}
+if($@ =~ /^Precision of 1st arg supplied to _d_bytes_fr must be 53, not 200/) {print "ok 14\n"}
 else {
   warn "\$\@: $@\n";
   print "not ok 14\n";
@@ -285,7 +285,7 @@
 
 eval {Math::MPFR::_dd_bytes_fr($fr_breaker, 106);};
 
-if($@ =~ /^Precison of 1st arg supplied to _dd_bytes_fr must be 2098, not 200/) {print "ok 15\n"}
+if($@ =~ /^Precision of 1st arg supplied to _dd_bytes_fr must be 2098, not 200/) {print "ok 15\n"}
 else {
   warn "\$\@: $@\n";
   print "not ok 15\n";
@@ -294,7 +294,7 @@
 eval {Math::MPFR::_ld_bytes_fr($fr_breaker, 64);};
 
 
-if($@ =~ /^Precison of 1st arg \(200\) supplied to _ld_bytes_fr must match 2nd arg \(64\)/) {print "ok 16\n"}
+if($@ =~ /^Precision of 1st arg \(200\) supplied to _ld_bytes_fr must match 2nd arg \(64\)/) {print "ok 16\n"}
 else {
   warn "\$\@: $@\n";
   print "not ok 16\n";
@@ -302,7 +302,7 @@
 
 eval {Math::MPFR::_f128_bytes_fr($fr_breaker, 113);};
 
-if($@ =~ /^Precison of 1st arg supplied to _f128_bytes_fr must be 113, not 200/ ||
+if($@ =~ /^Precision of 1st arg supplied to _f128_bytes_fr must be 113, not 200/ ||
    $@ =~ /^__float128 support not built into this Math::MPFR/) {print "ok 17\n"}
 else {
   warn "\$\@: $@\n";
@@ -377,7 +377,7 @@
 
 eval{$h = Math::MPFR::bytes($d_fr, 'Long Double');};
 
-if($@ =~ /^Precison of 1st arg \(53\) supplied to _ld_bytes_fr must match 2nd arg \(64\)/) {print "ok 22\n"}
+if($@ =~ /^Precision of 1st arg \(53\) supplied to _ld_bytes_fr must match 2nd arg \(64\)/) {print "ok 22\n"}
 else {
   warn "\$\@: $@";
   print "not ok 22\n";
--- a/MPFR.pod
+++ b/MPFR.pod
@@ -119,7 +119,7 @@
     MPFR_RNDA (numeric value = 4): Round away from zero.
 
    It, too, can be used with Math-MPFR-3.0 or later, but
-   will cause a fatal error iff the mpfr library against
+   will cause a fatal error if the mpfr library against
    which Math::MPFR is built is earlier than version 3.0.0.
 
     The 'round to nearest' mode works as in the IEEE
@@ -315,7 +315,7 @@
    Rmpfr_set_default_rounding_mode($rnd);
     Sets the default rounding mode to $rnd (where $rnd can be one of
     MPFR_RNDN, MPFR_RNDU, MPFR_RNDZ, MPFR_RNDD and MPFR_RNDA.
-    Note that MPFR_RNDA is avaiable only if Math::MPFR has been built
+    Note that MPFR_RNDA is available only if Math::MPFR has been built
     against mpfr-3.0.0 or later.
     The default rounding mode is to nearest initially (MPFR_RNDN).
     The default rounding mode is the rounding mode that is used in
@@ -509,7 +509,7 @@
     the entire string is a valid number in base $base. otherwise
     it returns -1.
     If -1 is returned:
-      1) the non-numeric flag (which was initalised to 0) will be
+      1) the non-numeric flag (which was initialised to 0) will be
          incremented. You can query/clear/reset the value of the
          flag with (resp.) nnumflag()/clear_nnum()/set_nnum() - all
          of which are documented below (in "MISCELLANEOUS");
@@ -683,7 +683,7 @@
     rounded to direction $rnd. If $str was a valid number, then
     $si will be set to 0. Else it will be set to -1.
     If $si is -1 :
-      1) the non-numeric flag (which was initalised to 0) will be
+      1) the non-numeric flag (which was initialised to 0) will be
          incremented. You can query/clear/reset the value of the
          flag with (resp.) nnumflag()/clear_nnum()/set_nnum() - all
          of which are documented below (in "MISCELLANEOUS");
@@ -794,7 +794,7 @@
     When built against mpfr-3.0.0 or later, this function returns the
     usual ternary value. (If $op is NaN or Inf, then the erange flag
     will be set.) When built against earlier versions of mpfr,
-    return zero iff no error occurred.In particular a non-zero value
+    return zero if no error occurred.In particular a non-zero value
     is returned if $op is NaN or Inf. which do not exist in 'mpf'.
 
    Rmpfr_get_q ($q, $op); # $q is a Math::GMPq object.
@@ -913,7 +913,7 @@
    $si = Rmpfr_pow($rop, $op1, $op2, $rnd);
    $si = Rmpfr_pow_z($rop, $op1, $z, $rnd);  # $z is a mpz object
     Set $rop to 2nd arg raised to 3rd arg, rounded to the directio
-    $rnd with the precision of $rop.  Return zero iff the result is
+    $rnd with the precision of $rop.  Return zero if the result is
     exact, a positive value when the result is greater than 2nd arg
     to the power 3rd arg, and a negative value when it is smaller.
     See the MPFR documentation for documentation regarding special
@@ -1071,23 +1071,23 @@
    $si = Rmpfr_tan($rop, $op, $rnd);
     Set $rop to the sine/cosine/tangent respectively of $op,
     rounded to the direction $rnd with the precision of $rop.
-    Return 0 iff the result is exact (this occurs in fact only
+    Return 0 if the result is exact (this occurs in fact only
     when $op is 0 i.e. the sine is 0, the cosine is 1, and the
-    tangent is 0). Return a negative value iff the result is less
-    than the actual value. Return a positive result iff the
+    tangent is 0). Return a negative value if the result is less
+    than the actual value. Return a positive result if the
     return is greater than the actual value.
 
    $si = Rmpfr_sin_cos($rop1, $rop2, $op, $rnd);
     Set simultaneously $rop1 to the sine of $op and
     $rop2 to the cosine of $op, rounded to the direction $rnd
-    with their corresponding precisions.  Return 0 iff both
+    with their corresponding precisions.  Return 0 if both
     results are exact.
 
    $si = Rmpfr_sinh_cosh($rop1, $rop2, $op, $rnd);
     Set simultaneously $rop1 to the hyperbolic sine of $op and
     $rop2 to the hyperbolic cosine of $op, rounded in the direction
     $rnd with the corresponding precision of $rop1 and $rop2 which
-    must be different variables. Return 0 iff both results are
+    must be different variables. Return 0 if both results are
     exact.
 
    $si = Rmpfr_acos($rop, $op, $rnd);
@@ -1095,16 +1095,16 @@
    $si = Rmpfr_atan($rop, $op, $rnd);
     Set $rop to the arc-cosine, arc-sine or arc-tangent of $op,
     rounded to the direction $rnd with the precision of $rop.
-    Return 0 iff the result is exact. Return a negative value iff
+    Return 0 if the result is exact. Return a negative value if
     the result is less than the actual value. Return a positive
-    result iff the return is greater than the actual value.
+    result if the return is greater than the actual value.
 
    $si = Rmpfr_atan2($rop, $op1, $op2, $rnd);
     Set $rop to the tangent of $op1/$op2, rounded to the
     direction $rnd with the precision of $rop.
-    Return 0 iff the result is exact. Return a negative value iff
+    Return 0 if the result is exact. Return a negative value if
     the result is less than the actual value. Return a positive
-    result iff the return is greater than the actual value.
+    result if the return is greater than the actual value.
     See the MPFR documentation for details regarding special cases.
 
 
@@ -1113,10 +1113,10 @@
    $si = Rmpfr_tanh($rop, $op, $rnd);
     Set $rop to the hyperbolic cosine/hyperbolic sine/hyperbolic
     tangent respectively of $op, rounded to the direction $rnd
-    with the precision of $rop.  Return 0 iff the result is exact
+    with the precision of $rop.  Return 0 if the result is exact
     (this occurs in fact only when $op is 0 i.e. the result is 1).
-    Return a negative value iff the result is less than the actual
-    value. Return a positive result iff the return is greater than
+    Return a negative value if the result is less than the actual
+    value. Return a positive result if the return is greater than
     the actual value.
 
    $si = Rmpfr_acosh($rop, $op, $rnd);
@@ -1124,40 +1124,40 @@
    $si = Rmpfr_atanh($rop, $op, $rnd);
     Set $rop to the inverse hyperbolic cosine, sine or tangent
     of $op, rounded to the direction $rnd with the precision of
-    $rop.  Return 0 iff the result is exact.
+    $rop.  Return 0 if the result is exact.
 
    $si = Rmpfr_sec ($rop, $op, $rnd);
    $si = Rmpfr_csc ($rop, $op, $rnd);
    $si = Rmpfr_cot ($rop, $op, $rnd);
     Set $rop to the secant of $op, cosecant of $op,
     cotangent of $op, rounded in the direction RND. Return 0
-    iff the result is exact. Return a negative value iff the
+    if the result is exact. Return a negative value if the
     result is less than the actual value. Return a positive
-    result iff the return is greater than the actual value.
+    result if the return is greater than the actual value.
 
    $si = Rmpfr_sech ($rop, $op, $rnd);
    $si = Rmpfr_csch ($rop, $op, $rnd);
    $si = Rmpfr_coth ($rop, $op, $rnd);
     Set $rop to the hyperbolic secant of $op, cosecant of $op,
     cotangent of $op, rounded in the direction RND. Return 0
-    iff the result is exact. Return a negative value iff the
+    if the result is exact. Return a negative value if the
     result is less than the actual value. Return a positive
-    result iff the return is greater than the actual value.
+    result if the return is greater than the actual value.
 
    $bool = Rmpfr_fac_ui($rop, $ui, $rnd);
     Set $rop to the factorial of $ui, rounded to the direction
-    $rnd with the precision of $rop.  Return 0 iff the
+    $rnd with the precision of $rop.  Return 0 if the
     result is exact.
 
    $bool = Rmpfr_log1p($rop, $op, $rnd);
     Set $rop to the logarithm of one plus $op, rounded to the
-    direction $rnd with the precision of $rop.  Return 0 iff
+    direction $rnd with the precision of $rop.  Return 0 if
     the result is exact (this occurs in fact only when $op is 0
     i.e. the result is 0).
 
    $bool = Rmpfr_expm1($rop, $op, $rnd);
     Set $rop to the exponential of $op minus one, rounded to the
-    direction $rnd with the precision of $rop.  Return 0 iff the
+    direction $rnd with the precision of $rop.  Return 0 if the
     result is exact (this occurs in fact only when $op is 0 i.e
     the result is 0).
 
@@ -1375,7 +1375,7 @@
     Return the number of bytes read, or if non-numeric characters were
     encountered in the input, return 0.
     If 0 is returned:
-      1) the non-numeric flag (which was initalised to 0) will be
+      1) the non-numeric flag (which was initialised to 0) will be
          incremented. You can query/clear/reset the value of the
          flag with (resp.) nnumflag()/clear_nnum()/set_nnum() - all
          of which are documented below;
@@ -1410,7 +1410,7 @@
     The precision of OP is stored too. The import function fails if
     the precision (which is read from the stream) is greater than
     MPFR_PREC_MAX.
-    Return 0 iff the export/import was successful.
+    Return 0 if the export/import was successful.
 
    ##########
 
@@ -1490,7 +1490,7 @@
    $bool = Rmpfr_erangeflag_p();
    $bool = Rmpfr_divby0_p();   # mpfr-3.1.0 and later only
     Return the corresponding (underflow, overflow, invalid, inexact,
-    erange, divide-by-zero) flag, which is non-zero iff the flag is set.
+    erange, divide-by-zero) flag, which is non-zero if the flag is set.
 
    Rmpfr_flags_clear($mask);            # needs mpfr-3.2.0 or later
    Rmpfr_flags_set($mask);              # needs mpfr-3.2.0 or later
@@ -1667,7 +1667,7 @@
     to the fractional part of $op, rounded in the direction RND with
     the corresponding precision of $rop1 and $rop2 (equivalent to
     'Rmpfr_trunc($rop1, $op, $rnd)' and 'Rmpfr_frac($rop1, $op, $rnd)').
-    The variables $rop1 and $rop2 must be different. Return 0 iff both
+    The variables $rop1 and $rop2 must be different. Return 0 if both
     results are exact.
 
    $si         = Rmpfr_remainder($rop, $op1, $op2, $rnd);
@@ -1695,7 +1695,7 @@
     functions are useful for additive argument reduction.
 
    $si = Rmpfr_integer_p($op);
-    Return non-zero iff $op is an integer.
+    Return non-zero if $op is an integer.
 
    Rmpfr_nexttoward($op1, $op2);
     If $op1 or $op2 is NaN, set $op1 to NaN. Otherwise, if $op1 is
@@ -1936,7 +1936,7 @@
     ordinary number); otherwise, return a non-zero value.
 
    $si = Rmpfr_signbit ($op);
-    Return a non-zero value iff $op has its sign bit set (i.e. if it is
+    Return a non-zero value if $op has its sign bit set (i.e. if it is
     negative, -0, or a NaN whose representation has its sign bit set).
 
    $si2 = Rmpfr_setsign ($rop, $op, $si, $rnd);
@@ -1967,7 +1967,7 @@
     the *current default rounding mode*.
 
     Note that any comparison using the spaceship operator ( <=> )
-    will return undef iff either/both of the operands is a NaN.
+    will return undef if either/both of the operands is a NaN.
     All comparisons ( < <= > >= == != <=> ) involving one or more
     NaNs will set the erange flag.
 
@@ -2231,7 +2231,7 @@
    which will set $max_len to 15.
 
    That is, so long as your base 10 float consists of no more than 15
-   siginificant digits, you can pass it to a 53-bit double and back again,
+   significant digits, you can pass it to a 53-bit double and back again,
    and be assured of retrieving the original value.
    (Again, we assume absence of bugs and correct rounding practice.)
 
--- a/MPFR.pm
+++ b/MPFR.pm
@@ -386,7 +386,7 @@
       if(!@_) {return Rmpfr_init()}
       }
 
-    # @_ can now contain a maximum of 2 args - the value, and iff the value is
+    # @_ can now contain a maximum of 2 args - the value, and if the value is
     # a string, (optionally) the base of the numeric string.
     if(@_ > 2) {die "Too many arguments supplied to new() - expected no more than two"}
 
