entering CODE(0x814f834)
 3:	use Carp;
 3:	use Carp;
 3:	use Carp;
 entering Exporter::import
  30:	  my $pkg = shift;
  31:	  my $callpkg = caller($ExportLevel);
  33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
  39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
  39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
  39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
  40:	  return export $pkg, $callpkg, @_
  41:	    if $Verbose or $Debug or @$fail > 1;
  42:	  my $export_cache = ($Cache{$pkg} ||= {});
  43:	  my $args = @_ or @_ = @$exports;
  45:	  local $_;
  46:	  if ($args and not %$export_cache) {
  50:	  my $heavy;
  53:	  if ($args or $fail) {
  54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
  55:	               or @$fail and $_ eq $fail->[0])) and last
  56:	                 foreach (@_);
  56:	                 foreach (@_);
  61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
  63:		sub {require Carp; &Carp::carp};
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
entering CODE(0x814f864)
 4:	use Mail::IMAPClient;
 entering CODE(0x822c17c)
  5:	use Mail::IMAPClient::MessageSet;
  entering CODE(0x822bc54)
   4:	use warnings;
   4:	use warnings;
   4:	use warnings;
   entering warnings::import
    213:	    shift;
    215:	    my $catmask ;
    216:	    my $fatal = 0 ;
    217:	    my $no_fatal = 0 ;
    219:	    my $mask = ${^WARNING_BITS} ;
    221:	    if (vec($mask, $Offsets{'all'}, 1)) {
    222:	        $mask |= $Bits{'all'} ;
    223:	        $mask |= $DeadBits{'all'} if vec($mask, $Offsets{'all'}+1, 1);
    226:	    push @_, 'all' unless @_;
    228:	    foreach my $word ( @_ ) {
    229:		if ($word eq 'FATAL') {
    238:		    $mask |= $catmask ;
    239:		    $mask |= $DeadBits{$word} if $fatal ;
    240:		    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;
    246:	    ${^WARNING_BITS} = $mask ;
  entering CODE(0x822bccc)
   5:	use strict;
   5:	use strict;
   5:	use strict;
   entering strict::import
    28:	    shift;
    29:	    $^H |= @_ ? bits(@_) : $default_bits;
  entering CODE(0x822bc84)
   19:	  , fallback => 1;
   entering CODE(0x83227c8)
    131:	use warnings::register;
    Package /usr/share/perl/5.8/warnings/register.pm.
    3:	our $VERSION = '1.01';
    5:	require warnings;
    32:	1;
    131:	use warnings::register;
    131:	use warnings::register;
    entering warnings::register::import
     18:	    shift;
     19:	    my $package = (caller(0))[0];
     20:	    if (! defined $warnings::Bits{$package}) {
     21:	        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);
     entering warnings::register::mkMask
      9:	    my ($bit) = @_;
      10:	    my $mask = "";
      12:	    vec($mask, $bit, 1) = 1;
      13:	    return $mask;
     22:	        vec($warnings::Bits{'all'}, $warnings::LAST_BIT, 1) = 1;
     23:	        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;
     24:		foreach my $k (keys %warnings::Bits) {
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     27:	        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);
     entering warnings::register::mkMask
      9:	    my ($bit) = @_;
      10:	    my $mask = "";
      12:	    vec($mask, $bit, 1) = 1;
      13:	    return $mask;
     28:	        vec($warnings::DeadBits{'all'}, $warnings::LAST_BIT++, 1) = 1;
   Package /usr/share/perl/5.8/overload.pm.
   3:	our $VERSION = '1.04';
   5:	$overload::hint_bits = 0x20000; # HINT_LOCALIZE_HH
   96:	*StrVal = *AddrRef;
   109:	%constants = (
   110:		      'integer'	  =>  0x1000, # HINT_NEW_INTEGER
   111:		      'float'	  =>  0x2000, # HINT_NEW_FLOAT
   112:		      'binary'	  =>  0x4000, # HINT_NEW_BINARY
   113:		      'q'	  =>  0x8000, # HINT_NEW_STRING
   114:		      'qr'	  => 0x10000, # HINT_NEW_RE
   115:		     );
   117:	%ops = ( with_assign	  => "+ - * / % ** << >> x .",
   118:		 assign		  => "+= -= *= /= %= **= <<= >>= x= .=",
   119:		 num_comparison	  => "< <= >  >= == !=",
   120:		 '3way_comparison'=> "<=> cmp",
   121:		 str_comparison	  => "lt le gt ge eq ne",
   122:		 binary		  => "& | ^",
   123:		 unary		  => "neg ! ~",
   124:		 mutators	  => '++ --',
   125:		 func		  => "atan2 cos sin exp abs log sqrt int",
   126:		 conversion	  => 'bool "" 0+',
   127:		 iterators	  => '<>',
   128:		 dereferencing	  => '${} @{} %{} &{} *{}',
   129:		 special	  => 'nomethod fallback =');
   167:	1;
   19:	  , fallback => 1;
   18:	  , '@{}'    => "unfold"
   entering overload::import
    32:	  $package = (caller())[0];
    34:	  shift;
    35:	  $package->overload::OVERLOAD(@_);
    entering overload::OVERLOAD
     10:	  $package = shift;
     11:	  my %arg = @_;
     12:	  my ($sub, $fb);
     13:	  $ {$package . "::OVERLOAD"}{dummy}++; # Register with magic by touching.
     13:	  $ {$package . "::OVERLOAD"}{dummy}++; # Register with magic by touching.
     14:	  *{$package . "::()"} = \&nil; # Make it findable via fetchmethod.
     14:	  *{$package . "::()"} = \&nil; # Make it findable via fetchmethod.
     15:	  for (keys %arg) {
     16:	    if ($_ eq 'fallback') {
     19:	      $sub = $arg{$_};
     20:	      if (not ref $sub and $sub !~ /::/) {
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     16:	    if ($_ eq 'fallback') {
     19:	      $sub = $arg{$_};
     20:	      if (not ref $sub and $sub !~ /::/) {
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     16:	    if ($_ eq 'fallback') {
     19:	      $sub = $arg{$_};
     20:	      if (not ref $sub and $sub !~ /::/) {
     21:		$ {$package . "::(" . $_} = $sub;
     21:		$ {$package . "::(" . $_} = $sub;
     22:		$sub = \&nil;
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     16:	    if ($_ eq 'fallback') {
     19:	      $sub = $arg{$_};
     20:	      if (not ref $sub and $sub !~ /::/) {
     21:		$ {$package . "::(" . $_} = $sub;
     21:		$ {$package . "::(" . $_} = $sub;
     22:		$sub = \&nil;
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     16:	    if ($_ eq 'fallback') {
     19:	      $sub = $arg{$_};
     20:	      if (not ref $sub and $sub !~ /::/) {
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     25:	      *{$package . "::(" . $_} = \&{ $sub };
     16:	    if ($_ eq 'fallback') {
     17:	      $fb = $arg{$_};
     28:	  ${$package . "::()"} = $fb; # Make it findable too (fallback only).
     28:	  ${$package . "::()"} = $fb; # Make it findable too (fallback only).
  Package Mail-IMAPClient-2.99_02/lib/Mail/IMAPClient/MessageSet.pm.
  285:	1;
  5:	use Mail::IMAPClient::MessageSet;
  5:	use Mail::IMAPClient::MessageSet;
 entering CODE(0x822c134)
  7:	use Socket();
  entering CODE(0x816f734)
   6:	use Carp;
   6:	use Carp;
   6:	use Carp;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x816f740)
   7:	use warnings::register;
   7:	use warnings::register;
   7:	use warnings::register;
   entering warnings::register::import
    18:	    shift;
    19:	    my $package = (caller(0))[0];
    20:	    if (! defined $warnings::Bits{$package}) {
    21:	        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);
    entering warnings::register::mkMask
     9:	    my ($bit) = @_;
     10:	    my $mask = "";
     12:	    vec($mask, $bit, 1) = 1;
     13:	    return $mask;
    22:	        vec($warnings::Bits{'all'}, $warnings::LAST_BIT, 1) = 1;
    23:	        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;
    24:		foreach my $k (keys %warnings::Bits) {
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    27:	        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);
    entering warnings::register::mkMask
     9:	    my ($bit) = @_;
     10:	    my $mask = "";
     12:	    vec($mask, $bit, 1) = 1;
     13:	    return $mask;
    28:	        vec($warnings::DeadBits{'all'}, $warnings::LAST_BIT++, 1) = 1;
  entering CODE(0x816f8d8)
   10:	use XSLoader ();
   10:	use XSLoader ();
   10:	use XSLoader ();
  entering CODE(0x83e0010)
   180:	BEGIN {
  Package /usr/lib/perl/5.8/Socket.pm.
  3:	our($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);
  4:	$VERSION = "1.78";
  9:	require Exporter;
  11:	@ISA = qw(Exporter);
  12:	@EXPORT = qw(
  13:		inet_aton inet_ntoa
  14:		sockaddr_family
  15:		pack_sockaddr_in unpack_sockaddr_in
  16:		pack_sockaddr_un unpack_sockaddr_un
  17:		sockaddr_in sockaddr_un
  18:		INADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE
  19:		AF_802
  20:		AF_AAL
  21:		AF_APPLETALK
  22:		AF_CCITT
  23:		AF_CHAOS
  24:		AF_CTF
  25:		AF_DATAKIT
  26:		AF_DECnet
  27:		AF_DLI
  28:		AF_ECMA
  29:		AF_GOSIP
  30:		AF_HYLINK
  31:		AF_IMPLINK
  32:		AF_INET
  33:		AF_INET6
  34:		AF_ISO
  35:		AF_KEY
  36:		AF_LAST
  37:		AF_LAT
  38:		AF_LINK
  39:		AF_MAX
  40:		AF_NBS
  41:		AF_NIT
  42:		AF_NS
  43:		AF_OSI
  44:		AF_OSINET
  45:		AF_PUP
  46:		AF_ROUTE
  47:		AF_SNA
  48:		AF_UNIX
  49:		AF_UNSPEC
  50:		AF_USER
  51:		AF_WAN
  52:		AF_X25
  53:		IOV_MAX
  54:		MSG_BCAST
  55:		MSG_BTAG
  56:		MSG_CTLFLAGS
  57:		MSG_CTLIGNORE
  58:		MSG_CTRUNC
  59:		MSG_DONTROUTE
  60:		MSG_DONTWAIT
  61:		MSG_EOF
  62:		MSG_EOR
  63:		MSG_ERRQUEUE
  64:		MSG_ETAG
  65:		MSG_FIN
  66:		MSG_MAXIOVLEN
  67:		MSG_MCAST
  68:		MSG_NOSIGNAL
  69:		MSG_OOB
  70:		MSG_PEEK
  71:		MSG_PROXY
  72:		MSG_RST
  73:		MSG_SYN
  74:		MSG_TRUNC
  75:		MSG_URG
  76:		MSG_WAITALL
  77:		MSG_WIRE
  78:		PF_802
  79:		PF_AAL
  80:		PF_APPLETALK
  81:		PF_CCITT
  82:		PF_CHAOS
  83:		PF_CTF
  84:		PF_DATAKIT
  85:		PF_DECnet
  86:		PF_DLI
  87:		PF_ECMA
  88:		PF_GOSIP
  89:		PF_HYLINK
  90:		PF_IMPLINK
  91:		PF_INET
  92:		PF_INET6
  93:		PF_ISO
  94:		PF_KEY
  95:		PF_LAST
  96:		PF_LAT
  97:		PF_LINK
  98:		PF_MAX
  99:		PF_NBS
  100:		PF_NIT
  101:		PF_NS
  102:		PF_OSI
  103:		PF_OSINET
  104:		PF_PUP
  105:		PF_ROUTE
  106:		PF_SNA
  107:		PF_UNIX
  108:		PF_UNSPEC
  109:		PF_USER
  110:		PF_WAN
  111:		PF_X25
  112:		SCM_CONNECT
  113:		SCM_CREDENTIALS
  114:		SCM_CREDS
  115:		SCM_RIGHTS
  116:		SCM_TIMESTAMP
  117:		SHUT_RD
  118:		SHUT_RDWR
  119:		SHUT_WR
  120:		SOCK_DGRAM
  121:		SOCK_RAW
  122:		SOCK_RDM
  123:		SOCK_SEQPACKET
  124:		SOCK_STREAM
  125:		SOL_SOCKET
  126:		SOMAXCONN
  127:		SO_ACCEPTCONN
  128:		SO_ATTACH_FILTER
  129:		SO_BACKLOG
  130:		SO_BROADCAST
  131:		SO_CHAMELEON
  132:		SO_DEBUG
  133:		SO_DETACH_FILTER
  134:		SO_DGRAM_ERRIND
  135:		SO_DONTLINGER
  136:		SO_DONTROUTE
  137:		SO_ERROR
  138:		SO_FAMILY
  139:		SO_KEEPALIVE
  140:		SO_LINGER
  141:		SO_OOBINLINE
  142:		SO_PASSCRED
  143:		SO_PASSIFNAME
  144:		SO_PEERCRED
  145:		SO_PROTOCOL
  146:		SO_PROTOTYPE
  147:		SO_RCVBUF
  148:		SO_RCVLOWAT
  149:		SO_RCVTIMEO
  150:		SO_REUSEADDR
  151:		SO_REUSEPORT
  152:		SO_SECURITY_AUTHENTICATION
  153:		SO_SECURITY_ENCRYPTION_NETWORK
  154:		SO_SECURITY_ENCRYPTION_TRANSPORT
  155:		SO_SNDBUF
  156:		SO_SNDLOWAT
  157:		SO_SNDTIMEO
  158:		SO_STATE
  159:		SO_TYPE
  160:		SO_USELOOPBACK
  161:		SO_XOPEN
  162:		SO_XSE
  163:		UIO_MAXIOV
  164:	);
  166:	@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF
  175:	%EXPORT_TAGS = (
  176:	    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],
  177:	    all     => [@EXPORT, @EXPORT_OK],
  178:	);
  186:	*CR   = \CR();
  187:	*LF   = \LF();
  188:	*CRLF = \CRLF();
  227:	XSLoader::load 'Socket', $VERSION;
  entering XSLoader::load
   25:	    die q{XSLoader::load('Your::Module', $Your::Module::VERSION)} unless @_;
   27:	    my($module) = $_[0];
   30:	    my $b = "$module\::bootstrap";
   31:	    goto &$b if defined &$b;
   33:	    goto retry unless $module and defined &dl_load_file;
   35:	    my @modparts = split(/::/,$module);
   36:	    my $modfname = $modparts[-1];
   38:	    my $modpname = join('/',@modparts);
   39:	    my $modlibname = (caller())[1];
   40:	    my $c = @modparts;
   41:	    $modlibname =~ s,[\\/][^\\/]+$,, while $c--;	# Q&D basename
   42:	    my $file = "$modlibname/auto/$modpname/$modfname.$dl_dlext";
   46:	    my $bs = $file;
   47:	    $bs =~ s/(\.\w+)?(;\d*)?$/\.bs/; # look for .bs 'beside' the library
   49:	    goto retry if not -f $file or -s $bs;
   51:	    my $bootname = "boot_$module";
   52:	    $bootname =~ s/\W/_/g;
   53:	    @DynaLoader::dl_require_symbols = ($bootname);
   55:	    my $boot_symbol_ref;
   57:	    if ($^O eq 'darwin') {
   70:	    my $libref = dl_load_file($file, 0) or do { 
   entering DynaLoader::dl_load_file
   74:	    push(@DynaLoader::dl_librefs,$libref);  # record loaded object
   76:	    my @unresolved = dl_undef_symbols();
   entering DynaLoader::dl_undef_symbols
   77:	    if (@unresolved) {
   82:	    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {
   entering DynaLoader::dl_find_symbol
   87:	    push(@DynaLoader::dl_modules, $module); # record loaded module
   89:	  boot:
   90:	    my $xs = dl_install_xsub("${module}::bootstrap", $boot_symbol_ref, $file);
   entering DynaLoader::dl_install_xsub
   93:	    return &$xs(@_);
   entering Socket::bootstrap
  229:	1;
  7:	use Socket();
  7:	use Socket();
 entering CODE(0x822c194)
  8:	use IO::Socket();
  entering CODE(0x83dfe84)
   11:	use IO::Handle;
   11:	use IO::Handle;
   11:	use IO::Handle;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x83dfde8)
   12:	use Socket 1.3;
   12:	use Socket 1.3;
   entering UNIVERSAL::VERSION
   12:	use Socket 1.3;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x83dfd7c)
   13:	use Carp;
   13:	use Carp;
   13:	use Carp;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x83dfcbc)
   14:	use strict;
   14:	use strict;
   14:	use strict;
   entering strict::import
    28:	    shift;
    29:	    $^H |= @_ ? bits(@_) : $default_bits;
  entering CODE(0x83ed0e4)
   16:	use Exporter;
   16:	use Exporter;
   16:	use Exporter;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x83ed18c)
   17:	use Errno;
   entering CODE(0x83ed558)
    7:	use Exporter ();
    7:	use Exporter ();
    7:	use Exporter ();
   entering CODE(0x83ed564)
    8:	use strict;
    8:	use strict;
    8:	use strict;
    entering strict::import
     28:	    shift;
     29:	    $^H |= @_ ? bits(@_) : $default_bits;
   entering CODE(0x841c170)
    187:		no strict 'refs';
    187:		no strict 'refs';
    187:		no strict 'refs';
    entering strict::unimport
     33:	    shift;
     34:	    $^H &= ~ (@_ ? bits(@_) : $default_bits);
     entering strict::bits
      12:	    my $bits = 0;
      13:	    my @wrong;
      14:	    foreach my $s (@_) {
      15:		push @wrong, $s unless exists $bitmask{$s};
      16:	        $bits |= $bitmask{$s} || 0;
      18:	    if (@wrong) {
      22:	    $bits;
   Package /usr/lib/perl/5.8/Errno.pm.
   6:	our (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);
   10:	$VERSION = "1.09_01";
   11:	$VERSION = eval $VERSION;
   1:	1.09_01
   12:	@ISA = qw(Exporter);
   14:	@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF
   15:		ENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT
   16:		ECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED
   17:		ECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ
   18:		ENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL
   19:		EINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS
   20:		EOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR
   21:		EBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL
   22:		EDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET
   23:		EUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK
   24:		ECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL
   25:		ENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM
   26:		EBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS
   27:		EHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE
   28:		ENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC
   29:		ENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV
   30:		ETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);
   32:	%EXPORT_TAGS = (
   33:	    POSIX => [qw(
   34:		E2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY
   35:		EBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK
   36:		EDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH
   37:		EINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK
   38:		EMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS
   39:		ENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK
   40:		ENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM
   41:		EPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART
   42:		EROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT
   43:		ETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV
   44:	    )]
   45:	);
   199:	*CLEAR = \&STORE;
   200:	*DELETE = \&STORE;
   223:	tie %!, __PACKAGE__;
   entering Errno::TIEHASH
    180:	sub TIEHASH { bless [] }
   225:	1;
   226:	__END__
   17:	use Errno;
   17:	use Errno;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  Package /usr/lib/perl/5.8/IO/Socket.pm.
  9:	require 5.006;
  15:	our(@ISA, $VERSION, @EXPORT_OK);
  21:	require IO::Socket::INET;
  entering CODE(0x842f0d4)
   9:	use strict;
   9:	use strict;
   9:	use strict;
   entering strict::import
    28:	    shift;
    29:	    $^H |= @_ ? bits(@_) : $default_bits;
  entering CODE(0x843e0dc)
   11:	use IO::Socket;
   11:	use IO::Socket;
   11:	use IO::Socket;
   entering IO::Socket::import
    31:	    my $pkg = shift;
    32:	    if (@_ && $_[0] eq 'sockatmark') { # not very extensible but for now, fast
    35:		my $callpkg = caller;
    36:		Exporter::export 'Socket', $callpkg, @_;
    entering Exporter::export
     26:	  goto &{as_heavy()};
     26:	  goto &{as_heavy()};
     entering Exporter::as_heavy
      17:	  require Exporter::Heavy;
      entering CODE(0x843e2b0)
       3:	use strict;
       3:	use strict;
       3:	use strict;
       entering strict::import
        28:	    shift;
        29:	    $^H |= @_ ? bits(@_) : $default_bits;
      entering CODE(0x843e2bc)
       4:	no strict 'refs';
       4:	no strict 'refs';
       4:	no strict 'refs';
       entering strict::unimport
        33:	    shift;
        34:	    $^H &= ~ (@_ ? bits(@_) : $default_bits);
        entering strict::bits
         12:	    my $bits = 0;
         13:	    my @wrong;
         14:	    foreach my $s (@_) {
         15:		push @wrong, $s unless exists $bitmask{$s};
         16:	        $bits |= $bitmask{$s} || 0;
         18:	    if (@wrong) {
         22:	    $bits;
      Package /usr/share/perl/5.8/Exporter/Heavy.pm.
      7:	require Exporter;  our $VERSION = $Exporter::VERSION;
      7:	require Exporter;  our $VERSION = $Exporter::VERSION;
      8:	$Carp::Internal{"Exporter::Heavy"} = 1;
      234:	1;
      20:	  my $c = (caller(1))[3];
      21:	  $c =~ s/.*:://;
      22:	  \&{"Exporter::Heavy::heavy_$c"};
      22:	  \&{"Exporter::Heavy::heavy_$c"};
     39:	    };
     40:	    local $SIG{__DIE__} = sub {
     45:	    };
     47:	    my($pkg, $callpkg, @imports) = @_;
     48:	    my($type, $sym, $cache_is_current, $oops);
     49:	    my($exports, $export_cache) = (\@{"${pkg}::EXPORT"},
     50:	                                   $Exporter::Cache{$pkg} ||= {});
     49:	    my($exports, $export_cache) = (\@{"${pkg}::EXPORT"},
     50:	                                   $Exporter::Cache{$pkg} ||= {});
     52:	    if (@imports) {
     145:		@imports = @$exports;
     148:	    my($fail, $fail_cache) = (\@{"${pkg}::EXPORT_FAIL"},
     149:	                              $Exporter::FailCache{$pkg} ||= {});
     148:	    my($fail, $fail_cache) = (\@{"${pkg}::EXPORT_FAIL"},
     149:	                              $Exporter::FailCache{$pkg} ||= {});
     151:	    if (@$fail) {
     176:	    warn "Importing into $callpkg from $pkg: ",
     177:			join(", ",sort @imports) if $Exporter::Verbose;
     179:	    foreach $sym (@imports) {
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
  entering CODE(0x843e0f4)
   12:	use Socket;
   12:	use Socket;
   12:	use Socket;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x83ed5e8)
   13:	use Carp;
   13:	use Carp;
   13:	use Carp;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x843e100)
   14:	use Exporter;
   14:	use Exporter;
   14:	use Exporter;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x843e118)
   15:	use Errno;
   15:	use Errno;
   15:	use Errno;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  Package /usr/lib/perl/5.8/IO/Socket/INET.pm.
  10:	our(@ISA, $VERSION);
  17:	@ISA = qw(IO::Socket);
  18:	$VERSION = "1.29";
  20:	my $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;
  22:	IO::Socket::INET->register_domain( AF_INET );
  entering Socket::AUTOLOAD for Socket::AF_INET
   216:	    my($constname);
   217:	    ($constname = $AUTOLOAD) =~ s/.*:://;
   218:	    croak "&Socket::constant not defined" if $constname eq 'constant';
   219:	    my ($error, $val) = constant($constname);
   entering Socket::constant
   220:	    if ($error) {
   223:	    *$AUTOLOAD = sub { $val };
   224:	    goto &$AUTOLOAD;
   223:	    *$AUTOLOAD = sub { $val };
  entering IO::Socket::register_domain
   55:	    my($p,$d) = @_;
   56:	    $domain2pkg[$d] = $p;
  24:	my %socket_type = ( tcp  => SOCK_STREAM,
  25:			    udp  => SOCK_DGRAM,
  26:			    icmp => SOCK_RAW
  27:			  );
  entering Socket::AUTOLOAD for Socket::SOCK_STREAM
   216:	    my($constname);
   217:	    ($constname = $AUTOLOAD) =~ s/.*:://;
   218:	    croak "&Socket::constant not defined" if $constname eq 'constant';
   219:	    my ($error, $val) = constant($constname);
   entering Socket::constant
   220:	    if ($error) {
   223:	    *$AUTOLOAD = sub { $val };
   224:	    goto &$AUTOLOAD;
   223:	    *$AUTOLOAD = sub { $val };
  entering Socket::AUTOLOAD for Socket::SOCK_DGRAM
   216:	    my($constname);
   217:	    ($constname = $AUTOLOAD) =~ s/.*:://;
   218:	    croak "&Socket::constant not defined" if $constname eq 'constant';
   219:	    my ($error, $val) = constant($constname);
   entering Socket::constant
   220:	    if ($error) {
   223:	    *$AUTOLOAD = sub { $val };
   224:	    goto &$AUTOLOAD;
   223:	    *$AUTOLOAD = sub { $val };
  entering Socket::AUTOLOAD for Socket::SOCK_RAW
   216:	    my($constname);
   217:	    ($constname = $AUTOLOAD) =~ s/.*:://;
   218:	    croak "&Socket::constant not defined" if $constname eq 'constant';
   219:	    my ($error, $val) = constant($constname);
   entering Socket::constant
   220:	    if ($error) {
   223:	    *$AUTOLOAD = sub { $val };
   224:	    goto &$AUTOLOAD;
   223:	    *$AUTOLOAD = sub { $val };
  275:	1;
  22:	require IO::Socket::UNIX if ($^O ne 'epoc' && $^O ne 'symbian');
  entering CODE(0x8474028)
   9:	use strict;
   9:	use strict;
   9:	use strict;
   entering strict::import
    28:	    shift;
    29:	    $^H |= @_ ? bits(@_) : $default_bits;
  entering CODE(0x8474100)
   11:	use IO::Socket;
   11:	use IO::Socket;
   11:	use IO::Socket;
   entering IO::Socket::import
    31:	    my $pkg = shift;
    32:	    if (@_ && $_[0] eq 'sockatmark') { # not very extensible but for now, fast
    35:		my $callpkg = caller;
    36:		Exporter::export 'Socket', $callpkg, @_;
    entering Exporter::export
     26:	  goto &{as_heavy()};
     26:	  goto &{as_heavy()};
     entering Exporter::as_heavy
      17:	  require Exporter::Heavy;
      20:	  my $c = (caller(1))[3];
      21:	  $c =~ s/.*:://;
      22:	  \&{"Exporter::Heavy::heavy_$c"};
      22:	  \&{"Exporter::Heavy::heavy_$c"};
     39:	    };
     40:	    local $SIG{__DIE__} = sub {
     45:	    };
     47:	    my($pkg, $callpkg, @imports) = @_;
     48:	    my($type, $sym, $cache_is_current, $oops);
     49:	    my($exports, $export_cache) = (\@{"${pkg}::EXPORT"},
     50:	                                   $Exporter::Cache{$pkg} ||= {});
     49:	    my($exports, $export_cache) = (\@{"${pkg}::EXPORT"},
     50:	                                   $Exporter::Cache{$pkg} ||= {});
     52:	    if (@imports) {
     145:		@imports = @$exports;
     148:	    my($fail, $fail_cache) = (\@{"${pkg}::EXPORT_FAIL"},
     149:	                              $Exporter::FailCache{$pkg} ||= {});
     148:	    my($fail, $fail_cache) = (\@{"${pkg}::EXPORT_FAIL"},
     149:	                              $Exporter::FailCache{$pkg} ||= {});
     151:	    if (@$fail) {
     176:	    warn "Importing into $callpkg from $pkg: ",
     177:			join(", ",sort @imports) if $Exporter::Verbose;
     179:	    foreach $sym (@imports) {
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
     181:		(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
     182:		    unless $sym =~ s/^(\W)//;
  entering CODE(0x8474118)
   12:	use Socket;
   12:	use Socket;
   12:	use Socket;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x8473f44)
   13:	use Carp;
   13:	use Carp;
   13:	use Carp;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  Package /usr/lib/perl/5.8/IO/Socket/UNIX.pm.
  10:	our(@ISA, $VERSION);
  15:	@ISA = qw(IO::Socket);
  16:	$VERSION = "1.22";
  17:	$VERSION = eval $VERSION;
  1:	1.22
  19:	IO::Socket::UNIX->register_domain( AF_UNIX );
  entering Socket::AUTOLOAD for Socket::AF_UNIX
   216:	    my($constname);
   217:	    ($constname = $AUTOLOAD) =~ s/.*:://;
   218:	    croak "&Socket::constant not defined" if $constname eq 'constant';
   219:	    my ($error, $val) = constant($constname);
   entering Socket::constant
   220:	    if ($error) {
   223:	    *$AUTOLOAD = sub { $val };
   224:	    goto &$AUTOLOAD;
   223:	    *$AUTOLOAD = sub { $val };
  entering IO::Socket::register_domain
   55:	    my($p,$d) = @_;
   56:	    $domain2pkg[$d] = $p;
  66:	1; # Keep require happy
  24:	@ISA = qw(IO::Handle);
  26:	$VERSION = "1.29";
  28:	@EXPORT_OK = qw(sockatmark);
  52:	my @domain2pkg;
  250:	my $intsize = length(pack("i",0));
  302:	1;
  8:	use IO::Socket();
  8:	use IO::Socket();
 entering CODE(0x822c044)
  9:	use IO::Select();
  entering CODE(0x8483648)
   9:	use     strict;
   9:	use     strict;
   9:	use     strict;
   entering strict::import
    28:	    shift;
    29:	    $^H |= @_ ? bits(@_) : $default_bits;
  entering CODE(0x8483630)
   10:	use warnings::register;
   10:	use warnings::register;
   10:	use warnings::register;
   entering warnings::register::import
    18:	    shift;
    19:	    my $package = (caller(0))[0];
    20:	    if (! defined $warnings::Bits{$package}) {
    21:	        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);
    entering warnings::register::mkMask
     9:	    my ($bit) = @_;
     10:	    my $mask = "";
     12:	    vec($mask, $bit, 1) = 1;
     13:	    return $mask;
    22:	        vec($warnings::Bits{'all'}, $warnings::LAST_BIT, 1) = 1;
    23:	        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;
    24:		foreach my $k (keys %warnings::Bits) {
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    27:	        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);
    entering warnings::register::mkMask
     9:	    my ($bit) = @_;
     10:	    my $mask = "";
     12:	    vec($mask, $bit, 1) = 1;
     13:	    return $mask;
    28:	        vec($warnings::DeadBits{'all'}, $warnings::LAST_BIT++, 1) = 1;
  entering CODE(0x8483690)
   11:	use     vars qw($VERSION @ISA);
   entering CODE(0x84838a0)
    3:	use 5.006;
    3:	use 5.006;
    3:	use 5.006;
   entering CODE(0x8483984)
    7:	use warnings::register;
    7:	use warnings::register;
    7:	use warnings::register;
    entering warnings::register::import
     18:	    shift;
     19:	    my $package = (caller(0))[0];
     20:	    if (! defined $warnings::Bits{$package}) {
     21:	        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);
     entering warnings::register::mkMask
      9:	    my ($bit) = @_;
      10:	    my $mask = "";
      12:	    vec($mask, $bit, 1) = 1;
      13:	    return $mask;
     22:	        vec($warnings::Bits{'all'}, $warnings::LAST_BIT, 1) = 1;
     23:	        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;
     24:		foreach my $k (keys %warnings::Bits) {
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
     27:	        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);
     entering warnings::register::mkMask
      9:	    my ($bit) = @_;
      10:	    my $mask = "";
      12:	    vec($mask, $bit, 1) = 1;
      13:	    return $mask;
     28:	        vec($warnings::DeadBits{'all'}, $warnings::LAST_BIT++, 1) = 1;
   entering CODE(0x8483978)
    8:	use strict qw(vars subs);
    8:	use strict qw(vars subs);
    8:	use strict qw(vars subs);
    entering strict::import
     28:	    shift;
     29:	    $^H |= @_ ? bits(@_) : $default_bits;
     entering strict::bits
      12:	    my $bits = 0;
      13:	    my @wrong;
      14:	    foreach my $s (@_) {
      15:		push @wrong, $s unless exists $bitmask{$s};
      16:	        $bits |= $bitmask{$s} || 0;
      15:		push @wrong, $s unless exists $bitmask{$s};
      16:	        $bits |= $bitmask{$s} || 0;
      18:	    if (@wrong) {
      22:	    $bits;
   Package /usr/share/perl/5.8/vars.pm.
   5:	our $VERSION = '1.01';
   46:	1;
   47:	__END__
   11:	use     vars qw($VERSION @ISA);
   11:	use     vars qw($VERSION @ISA);
   entering vars::import
    11:	    my $callpack = caller;
    12:	    my ($pack, @imports) = @_;
    13:	    my ($sym, $ch);
    14:	    foreach (@imports) {
    15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
    16:		    if ($sym =~ /\W/) {
    28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
    29:		    *$sym =
    30:			(  $ch eq "\$" ? \$$sym
    31:			 : $ch eq "\@" ? \@$sym
    32:			 : $ch eq "\%" ? \%$sym
    33:			 : $ch eq "\*" ? \*$sym
    34:			 : $ch eq "\&" ? \&$sym 
    35:			 : do {
    15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
    16:		    if ($sym =~ /\W/) {
    28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
    29:		    *$sym =
    30:			(  $ch eq "\$" ? \$$sym
    31:			 : $ch eq "\@" ? \@$sym
    32:			 : $ch eq "\%" ? \%$sym
    33:			 : $ch eq "\*" ? \*$sym
    34:			 : $ch eq "\&" ? \&$sym 
    35:			 : do {
  Package /usr/lib/perl/5.8/IO/Select.pm.
  12:	require Exporter;
  14:	$VERSION = "1.17";
  16:	@ISA = qw(Exporter); # This is only so we can do version checking
  231:	1;
  232:	__END__
  9:	use IO::Select();
  9:	use IO::Select();
 entering CODE(0x822c098)
  10:	use IO::File();
  entering CODE(0x849b3e4)
   5:	use 5.006_001;
   5:	use 5.006_001;
   5:	use 5.006_001;
  entering CODE(0x849cab8)
   6:	use strict;
   6:	use strict;
   6:	use strict;
   entering strict::import
    28:	    shift;
    29:	    $^H |= @_ ? bits(@_) : $default_bits;
  entering CODE(0x84a6b28)
   8:	use Carp;
   8:	use Carp;
   8:	use Carp;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x84a6b34)
   9:	use Symbol;
   9:	use Symbol;
   9:	use Symbol;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x84a6b40)
   10:	use SelectSaver;
   10:	use SelectSaver;
   10:	use SelectSaver;
  entering CODE(0x84a6b4c)
   11:	use IO::Seekable;
   entering CODE(0x84a6db0)
    5:	use 5.006_001;
    5:	use 5.006_001;
    5:	use 5.006_001;
   entering CODE(0x84a6dbc)
    6:	use Carp;
    6:	use Carp;
    6:	use Carp;
    entering Exporter::import
     30:	  my $pkg = shift;
     31:	  my $callpkg = caller($ExportLevel);
     33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
     39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
     39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
     39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
     40:	  return export $pkg, $callpkg, @_
     41:	    if $Verbose or $Debug or @$fail > 1;
     42:	  my $export_cache = ($Cache{$pkg} ||= {});
     43:	  my $args = @_ or @_ = @$exports;
     45:	  local $_;
     46:	  if ($args and not %$export_cache) {
     50:	  my $heavy;
     53:	  if ($args or $fail) {
     54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
     55:	               or @$fail and $_ eq $fail->[0])) and last
     56:	                 foreach (@_);
     56:	                 foreach (@_);
     61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
     63:		sub {require Carp; &Carp::carp};
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   entering CODE(0x84a6dc8)
    7:	use strict;
    7:	use strict;
    7:	use strict;
    entering strict::import
     28:	    shift;
     29:	    $^H |= @_ ? bits(@_) : $default_bits;
   entering CODE(0x84a6e64)
    9:	use IO::Handle ();
    9:	use IO::Handle ();
    9:	use IO::Handle ();
   entering CODE(0x84a6e58)
    12:	use Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);
    entering CODE(0x84b2a20)
     6:	use XSLoader ();
     6:	use XSLoader ();
     6:	use XSLoader ();
    Package /usr/lib/perl/5.8/Fcntl.pm.
    3:	our($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);
    5:	require Exporter;
    7:	@ISA = qw(Exporter);
    8:	$VERSION = "1.05";
    11:	@EXPORT =
    12:	  qw(
    13:		FD_CLOEXEC
    14:		F_ALLOCSP
    15:		F_ALLOCSP64
    16:		F_COMPAT
    17:		F_DUP2FD
    18:		F_DUPFD
    19:		F_EXLCK
    20:		F_FREESP
    21:		F_FREESP64
    22:		F_FSYNC
    23:		F_FSYNC64
    24:		F_GETFD
    25:		F_GETFL
    26:		F_GETLK
    27:		F_GETLK64
    28:		F_GETOWN
    29:		F_NODNY
    30:		F_POSIX
    31:		F_RDACC
    32:		F_RDDNY
    33:		F_RDLCK
    34:		F_RWACC
    35:		F_RWDNY
    36:		F_SETFD
    37:		F_SETFL
    38:		F_SETLK
    39:		F_SETLK64
    40:		F_SETLKW
    41:		F_SETLKW64
    42:		F_SETOWN
    43:		F_SHARE
    44:		F_SHLCK
    45:		F_UNLCK
    46:		F_UNSHARE
    47:		F_WRACC
    48:		F_WRDNY
    49:		F_WRLCK
    50:		O_ACCMODE
    51:		O_ALIAS
    52:		O_APPEND
    53:		O_ASYNC
    54:		O_BINARY
    55:		O_CREAT
    56:		O_DEFER
    57:		O_DIRECT
    58:		O_DIRECTORY
    59:		O_DSYNC
    60:		O_EXCL
    61:		O_EXLOCK
    62:		O_LARGEFILE
    63:		O_NDELAY
    64:		O_NOCTTY
    65:		O_NOFOLLOW
    66:		O_NOINHERIT
    67:		O_NONBLOCK
    68:		O_RANDOM
    69:		O_RAW
    70:		O_RDONLY
    71:		O_RDWR
    72:		O_RSRC
    73:		O_RSYNC
    74:		O_SEQUENTIAL
    75:		O_SHLOCK
    76:		O_SYNC
    77:		O_TEMPORARY
    78:		O_TEXT
    79:		O_TRUNC
    80:		O_WRONLY
    81:	     );
    84:	@EXPORT_OK = qw(
    85:		DN_ACCESS
    86:		DN_ATTRIB
    87:		DN_CREATE
    88:		DN_DELETE
    89:		DN_MODIFY
    90:		DN_MULTISHOT
    91:		DN_RENAME
    92:		FAPPEND
    93:		FASYNC
    94:		FCREAT
    95:		FDEFER
    96:		FDSYNC
    97:		FEXCL
    98:		FLARGEFILE
    99:		FNDELAY
    100:		FNONBLOCK
    101:		FRSYNC
    102:		FSYNC
    103:		FTRUNC
    104:		F_GETLEASE
    105:		F_GETSIG
    106:		F_NOTIFY
    107:		F_SETLEASE
    108:		F_SETSIG
    109:		LOCK_EX
    110:		LOCK_MAND
    111:		LOCK_NB
    112:		LOCK_READ
    113:		LOCK_RW
    114:		LOCK_SH
    115:		LOCK_UN
    116:		LOCK_WRITE
    117:		O_IGNORE_CTTY
    118:		O_NOATIME
    119:		O_NOLINK
    120:		O_NOTRANS
    121:		SEEK_CUR
    122:		SEEK_END
    123:		SEEK_SET
    124:		S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT
    125:		S_IREAD S_IWRITE S_IEXEC
    126:		S_IRGRP S_IWGRP S_IXGRP S_IRWXG
    127:		S_IROTH S_IWOTH S_IXOTH S_IRWXO
    128:		S_IRUSR S_IWUSR S_IXUSR S_IRWXU
    129:		S_ISUID S_ISGID S_ISVTX S_ISTXT
    130:		_S_IFMT S_IFREG S_IFDIR S_IFLNK
    131:		&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO
    132:		&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE
    133:	);
    135:	%EXPORT_TAGS = (
    136:	    'flock'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],
    137:	    'Fcompat' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE
    138:			     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],
    139:	    'seek'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],
    140:	    'mode'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT
    141:			     _S_IFMT S_IFREG S_IFDIR S_IFLNK
    142:			     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT
    143:			     S_IRUSR S_IWUSR S_IXUSR S_IRWXU
    144:			     S_IRGRP S_IWGRP S_IXGRP S_IRWXG
    145:			     S_IROTH S_IWOTH S_IXOTH S_IRWXO
    146:			     S_IREAD S_IWRITE S_IEXEC
    147:			     S_ISREG S_ISDIR S_ISLNK S_ISSOCK
    148:			     S_ISBLK S_ISCHR S_ISFIFO
    149:			     S_ISWHT S_ISENFMT		
    150:			     S_IFMT S_IMODE
    151:	                  )],
    152:	);
    179:	XSLoader::load 'Fcntl', $VERSION;
    entering XSLoader::load
     25:	    die q{XSLoader::load('Your::Module', $Your::Module::VERSION)} unless @_;
     27:	    my($module) = $_[0];
     30:	    my $b = "$module\::bootstrap";
     31:	    goto &$b if defined &$b;
     33:	    goto retry unless $module and defined &dl_load_file;
     35:	    my @modparts = split(/::/,$module);
     36:	    my $modfname = $modparts[-1];
     38:	    my $modpname = join('/',@modparts);
     39:	    my $modlibname = (caller())[1];
     40:	    my $c = @modparts;
     41:	    $modlibname =~ s,[\\/][^\\/]+$,, while $c--;	# Q&D basename
     42:	    my $file = "$modlibname/auto/$modpname/$modfname.$dl_dlext";
     46:	    my $bs = $file;
     47:	    $bs =~ s/(\.\w+)?(;\d*)?$/\.bs/; # look for .bs 'beside' the library
     49:	    goto retry if not -f $file or -s $bs;
     51:	    my $bootname = "boot_$module";
     52:	    $bootname =~ s/\W/_/g;
     53:	    @DynaLoader::dl_require_symbols = ($bootname);
     55:	    my $boot_symbol_ref;
     57:	    if ($^O eq 'darwin') {
     70:	    my $libref = dl_load_file($file, 0) or do { 
     entering DynaLoader::dl_load_file
     74:	    push(@DynaLoader::dl_librefs,$libref);  # record loaded object
     76:	    my @unresolved = dl_undef_symbols();
     entering DynaLoader::dl_undef_symbols
     77:	    if (@unresolved) {
     82:	    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {
     entering DynaLoader::dl_find_symbol
     87:	    push(@DynaLoader::dl_modules, $module); # record loaded module
     89:	  boot:
     90:	    my $xs = dl_install_xsub("${module}::bootstrap", $boot_symbol_ref, $file);
     entering DynaLoader::dl_install_xsub
     93:	    return &$xs(@_);
     entering Fcntl::bootstrap
    181:	1;
    12:	use Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);
    12:	use Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);
    entering Exporter::import
     30:	  my $pkg = shift;
     31:	  my $callpkg = caller($ExportLevel);
     33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
     39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
     39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
     39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
     40:	  return export $pkg, $callpkg, @_
     41:	    if $Verbose or $Debug or @$fail > 1;
     42:	  my $export_cache = ($Cache{$pkg} ||= {});
     43:	  my $args = @_ or @_ = @$exports;
     45:	  local $_;
     46:	  if ($args and not %$export_cache) {
     48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
     48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
     47:	    s/^&//, $export_cache->{$_} = 1
     50:	  my $heavy;
     53:	  if ($args or $fail) {
     54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
     55:	               or @$fail and $_ eq $fail->[0])) and last
     56:	                 foreach (@_);
     56:	                 foreach (@_);
     61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
     63:		sub {require Carp; &Carp::carp};
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
     65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   Package /usr/lib/perl/5.8/IO/Seekable.pm.
   8:	our($VERSION, @EXPORT, @ISA);
   13:	require Exporter;
   15:	@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);
   16:	@ISA = qw(Exporter);
   18:	$VERSION = "1.10";
   19:	$VERSION = eval $VERSION;
   1:	1.10
   36:	1;
   11:	use IO::Seekable;
   11:	use IO::Seekable;
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x84a6b88)
   12:	use File::Spec;
   entering CODE(0x84b1c74)
    3:	use strict;
    3:	use strict;
    3:	use strict;
    entering strict::import
     28:	    shift;
     29:	    $^H |= @_ ? bits(@_) : $default_bits;
   entering CODE(0x84b1c80)
    4:	use vars qw(@ISA $VERSION);
    4:	use vars qw(@ISA $VERSION);
    4:	use vars qw(@ISA $VERSION);
    entering vars::import
     11:	    my $callpack = caller;
     12:	    my ($pack, @imports) = @_;
     13:	    my ($sym, $ch);
     14:	    foreach (@imports) {
     15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
     16:		    if ($sym =~ /\W/) {
     28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
     29:		    *$sym =
     30:			(  $ch eq "\$" ? \$$sym
     31:			 : $ch eq "\@" ? \@$sym
     32:			 : $ch eq "\%" ? \%$sym
     33:			 : $ch eq "\*" ? \*$sym
     34:			 : $ch eq "\&" ? \&$sym 
     35:			 : do {
     15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
     16:		    if ($sym =~ /\W/) {
     28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
     29:		    *$sym =
     30:			(  $ch eq "\$" ? \$$sym
     31:			 : $ch eq "\@" ? \@$sym
     32:			 : $ch eq "\%" ? \%$sym
     33:			 : $ch eq "\*" ? \*$sym
     34:			 : $ch eq "\&" ? \&$sym 
     35:			 : do {
   Package /usr/share/perl/5.8/File/Spec.pm.
   6:	$VERSION = '3.12';
   7:	$VERSION = eval $VERSION;
   1:	3.12
   9:	my %module = (MacOS   => 'Mac',
   10:		      MSWin32 => 'Win32',
   11:		      os2     => 'OS2',
   12:		      VMS     => 'VMS',
   13:		      epoc    => 'Epoc',
   14:		      NetWare => 'Win32', # Yes, File::Spec::Win32 works on NetWare.
   15:		      symbian => 'Win32', # Yes, File::Spec::Win32 works on symbian.
   16:		      dos     => 'OS2',   # Yes, File::Spec::OS2 works on DJGPP.
   17:		      cygwin  => 'Cygwin');
   19:	my $module = $module{$^O} || 'Unix';
   21:	require "File/Spec/$module.pm";
   entering CODE(0x84b20e8)
    3:	use strict;
    3:	use strict;
    3:	use strict;
    entering strict::import
     28:	    shift;
     29:	    $^H |= @_ ? bits(@_) : $default_bits;
   entering CODE(0x84b20f4)
    4:	use vars qw($VERSION);
    4:	use vars qw($VERSION);
    4:	use vars qw($VERSION);
    entering vars::import
     11:	    my $callpack = caller;
     12:	    my ($pack, @imports) = @_;
     13:	    my ($sym, $ch);
     14:	    foreach (@imports) {
     15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
     16:		    if ($sym =~ /\W/) {
     28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
     29:		    *$sym =
     30:			(  $ch eq "\$" ? \$$sym
     31:			 : $ch eq "\@" ? \@$sym
     32:			 : $ch eq "\%" ? \%$sym
     33:			 : $ch eq "\*" ? \*$sym
     34:			 : $ch eq "\&" ? \&$sym 
     35:			 : do {
   entering CODE(0x84cda44)
    61:		no strict 'refs';
    61:		no strict 'refs';
    61:		no strict 'refs';
    entering strict::unimport
     33:	    shift;
     34:	    $^H &= ~ (@_ ? bits(@_) : $default_bits);
     entering strict::bits
      12:	    my $bits = 0;
      13:	    my @wrong;
      14:	    foreach my $s (@_) {
      15:		push @wrong, $s unless exists $bitmask{$s};
      16:	        $bits |= $bitmask{$s} || 0;
      18:	    if (@wrong) {
      22:	    $bits;
   Package /usr/share/perl/5.8/File/Spec/Unix.pm.
   6:	$VERSION = '1.5';
   55:	my $tmpdir;
   56:	sub _tmpdir {
   266:	1;
   22:	@ISA = ("File::Spec::$module");
   24:	1;
   12:	use File::Spec;
   12:	use File::Spec;
  Package /usr/lib/perl/5.8/IO/File.pm.
  7:	our($VERSION, @EXPORT, @EXPORT_OK, @ISA);
  14:	require Exporter;
  16:	@ISA = qw(IO::Handle IO::Seekable Exporter);
  18:	$VERSION = "1.13";
  20:	@EXPORT = @IO::Seekable::EXPORT;
  22:	eval {
  24:	    require Fcntl;
  25:	    my @O = grep /^O_/, @Fcntl::EXPORT;
  26:	    Fcntl->import(@O);  # first we import what we want to export
  entering Exporter::import
   30:	  my $pkg = shift;
   31:	  my $callpkg = caller($ExportLevel);
   33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   40:	  return export $pkg, $callpkg, @_
   41:	    if $Verbose or $Debug or @$fail > 1;
   42:	  my $export_cache = ($Cache{$pkg} ||= {});
   43:	  my $args = @_ or @_ = @$exports;
   45:	  local $_;
   46:	  if ($args and not %$export_cache) {
   50:	  my $heavy;
   53:	  if ($args or $fail) {
   54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
   55:	               or @$fail and $_ eq $fail->[0])) and last
   56:	                 foreach (@_);
   56:	                 foreach (@_);
   61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
   63:		sub {require Carp; &Carp::carp};
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  27:	    push(@EXPORT, @O);
  86:	1;
  10:	use IO::File();
  10:	use IO::File();
 entering CODE(0x822c188)
  11:	use Carp qw(carp);
  11:	use Carp qw(carp);
  11:	use Carp qw(carp);
  entering Exporter::import
   30:	  my $pkg = shift;
   31:	  my $callpkg = caller($ExportLevel);
   33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   40:	  return export $pkg, $callpkg, @_
   41:	    if $Verbose or $Debug or @$fail > 1;
   42:	  my $export_cache = ($Cache{$pkg} ||= {});
   43:	  my $args = @_ or @_ = @$exports;
   45:	  local $_;
   46:	  if ($args and not %$export_cache) {
   48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
   48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
   47:	    s/^&//, $export_cache->{$_} = 1
   50:	  my $heavy;
   53:	  if ($args or $fail) {
   54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
   55:	               or @$fail and $_ eq $fail->[0])) and last
   56:	                 foreach (@_);
   56:	                 foreach (@_);
   61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
   63:		sub {require Carp; &Carp::carp};
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
 entering CODE(0x843e034)
  13:	use Fcntl       qw(F_GETFL F_SETFL O_NONBLOCK);
  13:	use Fcntl       qw(F_GETFL F_SETFL O_NONBLOCK);
  13:	use Fcntl       qw(F_GETFL F_SETFL O_NONBLOCK);
  entering Exporter::import
   30:	  my $pkg = shift;
   31:	  my $callpkg = caller($ExportLevel);
   33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   40:	  return export $pkg, $callpkg, @_
   41:	    if $Verbose or $Debug or @$fail > 1;
   42:	  my $export_cache = ($Cache{$pkg} ||= {});
   43:	  my $args = @_ or @_ = @$exports;
   45:	  local $_;
   46:	  if ($args and not %$export_cache) {
   50:	  my $heavy;
   53:	  if ($args or $fail) {
   54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
   55:	               or @$fail and $_ eq $fail->[0])) and last
   56:	                 foreach (@_);
   56:	                 foreach (@_);
   61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
   63:		sub {require Carp; &Carp::carp};
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
 entering CODE(0x84b1f74)
  14:	use Errno       qw/EAGAIN/;
  14:	use Errno       qw/EAGAIN/;
  14:	use Errno       qw/EAGAIN/;
  entering Exporter::import
   30:	  my $pkg = shift;
   31:	  my $callpkg = caller($ExportLevel);
   33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   40:	  return export $pkg, $callpkg, @_
   41:	    if $Verbose or $Debug or @$fail > 1;
   42:	  my $export_cache = ($Cache{$pkg} ||= {});
   43:	  my $args = @_ or @_ = @$exports;
   45:	  local $_;
   46:	  if ($args and not %$export_cache) {
   48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
   48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
   47:	    s/^&//, $export_cache->{$_} = 1
   50:	  my $heavy;
   53:	  if ($args or $fail) {
   54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
   55:	               or @$fail and $_ eq $fail->[0])) and last
   56:	                 foreach (@_);
   56:	                 foreach (@_);
   61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
   63:		sub {require Carp; &Carp::carp};
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
 entering CODE(0x84db578)
  15:	use List::Util  qw/first min max sum/;
  entering CODE(0x84e93e4)
   9:	use strict;
   9:	use strict;
   9:	use strict;
   entering strict::import
    28:	    shift;
    29:	    $^H |= @_ ? bits(@_) : $default_bits;
  entering CODE(0x84e93f0)
   10:	use vars qw(@ISA @EXPORT_OK $VERSION $XS_VERSION $TESTING_PERL_ONLY);
   10:	use vars qw(@ISA @EXPORT_OK $VERSION $XS_VERSION $TESTING_PERL_ONLY);
   10:	use vars qw(@ISA @EXPORT_OK $VERSION $XS_VERSION $TESTING_PERL_ONLY);
   entering vars::import
    11:	    my $callpack = caller;
    12:	    my ($pack, @imports) = @_;
    13:	    my ($sym, $ch);
    14:	    foreach (@imports) {
    15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
    16:		    if ($sym =~ /\W/) {
    28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
    29:		    *$sym =
    30:			(  $ch eq "\$" ? \$$sym
    31:			 : $ch eq "\@" ? \@$sym
    32:			 : $ch eq "\%" ? \%$sym
    33:			 : $ch eq "\*" ? \*$sym
    34:			 : $ch eq "\&" ? \&$sym 
    35:			 : do {
    15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
    16:		    if ($sym =~ /\W/) {
    28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
    29:		    *$sym =
    30:			(  $ch eq "\$" ? \$$sym
    31:			 : $ch eq "\@" ? \@$sym
    32:			 : $ch eq "\%" ? \%$sym
    33:			 : $ch eq "\*" ? \*$sym
    34:			 : $ch eq "\&" ? \&$sym 
    35:			 : do {
    15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
    16:		    if ($sym =~ /\W/) {
    28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
    29:		    *$sym =
    30:			(  $ch eq "\$" ? \$$sym
    31:			 : $ch eq "\@" ? \@$sym
    32:			 : $ch eq "\%" ? \%$sym
    33:			 : $ch eq "\*" ? \*$sym
    34:			 : $ch eq "\&" ? \&$sym 
    35:			 : do {
    15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
    16:		    if ($sym =~ /\W/) {
    28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
    29:		    *$sym =
    30:			(  $ch eq "\$" ? \$$sym
    31:			 : $ch eq "\@" ? \@$sym
    32:			 : $ch eq "\%" ? \%$sym
    33:			 : $ch eq "\*" ? \*$sym
    34:			 : $ch eq "\&" ? \&$sym 
    35:			 : do {
    15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
    16:		    if ($sym =~ /\W/) {
    28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
    29:		    *$sym =
    30:			(  $ch eq "\$" ? \$$sym
    31:			 : $ch eq "\@" ? \@$sym
    32:			 : $ch eq "\%" ? \%$sym
    33:			 : $ch eq "\*" ? \*$sym
    34:			 : $ch eq "\&" ? \&$sym 
    35:			 : do {
  Package /usr/lib/perl/5.8/List/Util.pm.
  11:	require Exporter;
  13:	@ISA        = qw(Exporter);
  14:	@EXPORT_OK  = qw(first min max minstr maxstr reduce sum shuffle);
  15:	$VERSION    = "1.18";
  16:	$XS_VERSION = $VERSION;
  17:	$VERSION    = eval $VERSION;
  1:	1.18
  19:	eval {
  22:	  local $ENV{PERL_DL_NONLAZY} = 0 if $ENV{PERL_DL_NONLAZY};
  23:	  eval {
  27:	  } or do {
  24:	    require XSLoader;
  25:	    XSLoader::load('List::Util', $XS_VERSION);
  entering XSLoader::load
   25:	    die q{XSLoader::load('Your::Module', $Your::Module::VERSION)} unless @_;
   27:	    my($module) = $_[0];
   30:	    my $b = "$module\::bootstrap";
   31:	    goto &$b if defined &$b;
   33:	    goto retry unless $module and defined &dl_load_file;
   35:	    my @modparts = split(/::/,$module);
   36:	    my $modfname = $modparts[-1];
   38:	    my $modpname = join('/',@modparts);
   39:	    my $modlibname = (caller())[1];
   40:	    my $c = @modparts;
   41:	    $modlibname =~ s,[\\/][^\\/]+$,, while $c--;	# Q&D basename
   42:	    my $file = "$modlibname/auto/$modpname/$modfname.$dl_dlext";
   46:	    my $bs = $file;
   47:	    $bs =~ s/(\.\w+)?(;\d*)?$/\.bs/; # look for .bs 'beside' the library
   49:	    goto retry if not -f $file or -s $bs;
   51:	    my $bootname = "boot_$module";
   52:	    $bootname =~ s/\W/_/g;
   53:	    @DynaLoader::dl_require_symbols = ($bootname);
   55:	    my $boot_symbol_ref;
   57:	    if ($^O eq 'darwin') {
   70:	    my $libref = dl_load_file($file, 0) or do { 
   entering DynaLoader::dl_load_file
   74:	    push(@DynaLoader::dl_librefs,$libref);  # record loaded object
   76:	    my @unresolved = dl_undef_symbols();
   entering DynaLoader::dl_undef_symbols
   77:	    if (@unresolved) {
   82:	    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {
   entering DynaLoader::dl_find_symbol
   87:	    push(@DynaLoader::dl_modules, $module); # record loaded module
   89:	  boot:
   90:	    my $xs = dl_install_xsub("${module}::bootstrap", $boot_symbol_ref, $file);
   entering DynaLoader::dl_install_xsub
   93:	    return &$xs(@_);
   entering List::Util::bootstrap
  26:	    1;
  37:	if (!defined &reduce) {
  75:	eval <<'ESQ' if !defined &sum;
  101:	1;
  15:	use List::Util  qw/first min max sum/;
  15:	use List::Util  qw/first min max sum/;
  entering Exporter::import
   30:	  my $pkg = shift;
   31:	  my $callpkg = caller($ExportLevel);
   33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   40:	  return export $pkg, $callpkg, @_
   41:	    if $Verbose or $Debug or @$fail > 1;
   42:	  my $export_cache = ($Cache{$pkg} ||= {});
   43:	  my $args = @_ or @_ = @$exports;
   45:	  local $_;
   46:	  if ($args and not %$export_cache) {
   48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
   48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
   47:	    s/^&//, $export_cache->{$_} = 1
   50:	  my $heavy;
   53:	  if ($args or $fail) {
   54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
   55:	               or @$fail and $_ eq $fail->[0])) and last
   56:	                 foreach (@_);
   56:	                 foreach (@_);
   61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
   63:		sub {require Carp; &Carp::carp};
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
 entering CODE(0x849af88)
  16:	use Digest::HMAC_MD5 qw/hmac_md5_hex/; 
  entering CODE(0x84ec01c)
   4:	use strict;
   4:	use strict;
   4:	use strict;
   entering strict::import
    28:	    shift;
    29:	    $^H |= @_ ? bits(@_) : $default_bits;
  entering CODE(0x84ec028)
   5:	use Digest::MD5  qw(md5);
   entering CODE(0x84ec214)
    3:	use strict;
    3:	use strict;
    3:	use strict;
    entering strict::import
     28:	    shift;
     29:	    $^H |= @_ ? bits(@_) : $default_bits;
   entering CODE(0x84ec220)
    4:	use vars qw($VERSION @ISA @EXPORT_OK);
    4:	use vars qw($VERSION @ISA @EXPORT_OK);
    4:	use vars qw($VERSION @ISA @EXPORT_OK);
    entering vars::import
     11:	    my $callpack = caller;
     12:	    my ($pack, @imports) = @_;
     13:	    my ($sym, $ch);
     14:	    foreach (@imports) {
     15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
     16:		    if ($sym =~ /\W/) {
     28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
     29:		    *$sym =
     30:			(  $ch eq "\$" ? \$$sym
     31:			 : $ch eq "\@" ? \@$sym
     32:			 : $ch eq "\%" ? \%$sym
     33:			 : $ch eq "\*" ? \*$sym
     34:			 : $ch eq "\&" ? \&$sym 
     35:			 : do {
     15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
     16:		    if ($sym =~ /\W/) {
     28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
     29:		    *$sym =
     30:			(  $ch eq "\$" ? \$$sym
     31:			 : $ch eq "\@" ? \@$sym
     32:			 : $ch eq "\%" ? \%$sym
     33:			 : $ch eq "\*" ? \*$sym
     34:			 : $ch eq "\&" ? \&$sym 
     35:			 : do {
     15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
     16:		    if ($sym =~ /\W/) {
     28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
     29:		    *$sym =
     30:			(  $ch eq "\$" ? \$$sym
     31:			 : $ch eq "\@" ? \@$sym
     32:			 : $ch eq "\%" ? \%$sym
     33:			 : $ch eq "\*" ? \*$sym
     34:			 : $ch eq "\&" ? \&$sym 
     35:			 : do {
   Package /usr/lib/perl/5.8/Digest/MD5.pm.
   6:	$VERSION = '2.36';  # $Date: 2005/11/30 13:46:47 $
   8:	require Exporter;
   9:	*import = \&Exporter::import;
   10:	@EXPORT_OK = qw(md5 md5_hex md5_base64);
   12:	eval {
   13:	    require Digest::base;
   entering CODE(0x84f6678)
    3:	use strict;
    3:	use strict;
    3:	use strict;
    entering strict::import
     28:	    shift;
     29:	    $^H |= @_ ? bits(@_) : $default_bits;
   entering CODE(0x84f6684)
    4:	use vars qw($VERSION);
    4:	use vars qw($VERSION);
    4:	use vars qw($VERSION);
    entering vars::import
     11:	    my $callpack = caller;
     12:	    my ($pack, @imports) = @_;
     13:	    my ($sym, $ch);
     14:	    foreach (@imports) {
     15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
     16:		    if ($sym =~ /\W/) {
     28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
     29:		    *$sym =
     30:			(  $ch eq "\$" ? \$$sym
     31:			 : $ch eq "\@" ? \@$sym
     32:			 : $ch eq "\%" ? \%$sym
     33:			 : $ch eq "\*" ? \*$sym
     34:			 : $ch eq "\&" ? \&$sym 
     35:			 : do {
   Package /usr/share/perl/5.8/Digest/base.pm.
   5:	$VERSION = "1.00";
   67:	1;
   14:	    push(@ISA, 'Digest::base');
   16:	if ($@) {
   22:	eval {
   23:	    require XSLoader;
   24:	    XSLoader::load('Digest::MD5', $VERSION);
   entering XSLoader::load
    25:	    die q{XSLoader::load('Your::Module', $Your::Module::VERSION)} unless @_;
    27:	    my($module) = $_[0];
    30:	    my $b = "$module\::bootstrap";
    31:	    goto &$b if defined &$b;
    33:	    goto retry unless $module and defined &dl_load_file;
    35:	    my @modparts = split(/::/,$module);
    36:	    my $modfname = $modparts[-1];
    38:	    my $modpname = join('/',@modparts);
    39:	    my $modlibname = (caller())[1];
    40:	    my $c = @modparts;
    41:	    $modlibname =~ s,[\\/][^\\/]+$,, while $c--;	# Q&D basename
    42:	    my $file = "$modlibname/auto/$modpname/$modfname.$dl_dlext";
    46:	    my $bs = $file;
    47:	    $bs =~ s/(\.\w+)?(;\d*)?$/\.bs/; # look for .bs 'beside' the library
    49:	    goto retry if not -f $file or -s $bs;
    51:	    my $bootname = "boot_$module";
    52:	    $bootname =~ s/\W/_/g;
    53:	    @DynaLoader::dl_require_symbols = ($bootname);
    55:	    my $boot_symbol_ref;
    57:	    if ($^O eq 'darwin') {
    70:	    my $libref = dl_load_file($file, 0) or do { 
    entering DynaLoader::dl_load_file
    74:	    push(@DynaLoader::dl_librefs,$libref);  # record loaded object
    76:	    my @unresolved = dl_undef_symbols();
    entering DynaLoader::dl_undef_symbols
    77:	    if (@unresolved) {
    82:	    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {
    entering DynaLoader::dl_find_symbol
    87:	    push(@DynaLoader::dl_modules, $module); # record loaded module
    89:	  boot:
    90:	    my $xs = dl_install_xsub("${module}::bootstrap", $boot_symbol_ref, $file);
    entering DynaLoader::dl_install_xsub
    93:	    return &$xs(@_);
    entering Digest::MD5::bootstrap
   26:	if ($@) {
   41:	    *reset = \&new;
   44:	1;
   45:	__END__
   5:	use Digest::MD5  qw(md5);
   5:	use Digest::MD5  qw(md5);
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
    48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
    47:	    s/^&//, $export_cache->{$_} = 1
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x84ec034)
   6:	use Digest::HMAC qw(hmac);
   entering CODE(0x84ec370)
    4:	use strict;
    4:	use strict;
    4:	use strict;
    entering strict::import
     28:	    shift;
     29:	    $^H |= @_ ? bits(@_) : $default_bits;
   entering CODE(0x84ff604)
    47:	use vars qw(@EXPORT_OK);
    47:	use vars qw(@EXPORT_OK);
    47:	use vars qw(@EXPORT_OK);
    entering vars::import
     11:	    my $callpack = caller;
     12:	    my ($pack, @imports) = @_;
     13:	    my ($sym, $ch);
     14:	    foreach (@imports) {
     15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
     16:		    if ($sym =~ /\W/) {
     28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
     29:		    *$sym =
     30:			(  $ch eq "\$" ? \$$sym
     31:			 : $ch eq "\@" ? \@$sym
     32:			 : $ch eq "\%" ? \%$sym
     33:			 : $ch eq "\*" ? \*$sym
     34:			 : $ch eq "\&" ? \&$sym 
     35:			 : do {
   Package /usr/share/perl5/Digest/HMAC.pm.
   2:	$VERSION = "1.01";
   45:	require Exporter;
   46:	*import = \&Exporter::import;
   48:	@EXPORT_OK = qw(hmac hmac_hex);
   64:	1;
   6:	use Digest::HMAC qw(hmac);
   6:	use Digest::HMAC qw(hmac);
   entering Exporter::import
    30:	  my $pkg = shift;
    31:	  my $callpkg = caller($ExportLevel);
    33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
    40:	  return export $pkg, $callpkg, @_
    41:	    if $Verbose or $Debug or @$fail > 1;
    42:	  my $export_cache = ($Cache{$pkg} ||= {});
    43:	  my $args = @_ or @_ = @$exports;
    45:	  local $_;
    46:	  if ($args and not %$export_cache) {
    48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
    48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
    47:	    s/^&//, $export_cache->{$_} = 1
    50:	  my $heavy;
    53:	  if ($args or $fail) {
    54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
    55:	               or @$fail and $_ eq $fail->[0])) and last
    56:	                 foreach (@_);
    56:	                 foreach (@_);
    61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
    63:		sub {require Carp; &Carp::carp};
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
  entering CODE(0x84ec0b8)
   9:	use vars qw(@ISA);
   9:	use vars qw(@ISA);
   9:	use vars qw(@ISA);
   entering vars::import
    11:	    my $callpack = caller;
    12:	    my ($pack, @imports) = @_;
    13:	    my ($sym, $ch);
    14:	    foreach (@imports) {
    15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
    16:		    if ($sym =~ /\W/) {
    28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
    29:		    *$sym =
    30:			(  $ch eq "\$" ? \$$sym
    31:			 : $ch eq "\@" ? \@$sym
    32:			 : $ch eq "\%" ? \%$sym
    33:			 : $ch eq "\*" ? \*$sym
    34:			 : $ch eq "\&" ? \&$sym 
    35:			 : do {
  entering CODE(0x84ffa60)
   20:	use vars qw(@EXPORT_OK);
   20:	use vars qw(@EXPORT_OK);
   20:	use vars qw(@EXPORT_OK);
   entering vars::import
    11:	    my $callpack = caller;
    12:	    my ($pack, @imports) = @_;
    13:	    my ($sym, $ch);
    14:	    foreach (@imports) {
    15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
    16:		    if ($sym =~ /\W/) {
    28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
    29:		    *$sym =
    30:			(  $ch eq "\$" ? \$$sym
    31:			 : $ch eq "\@" ? \@$sym
    32:			 : $ch eq "\%" ? \%$sym
    33:			 : $ch eq "\*" ? \*$sym
    34:			 : $ch eq "\&" ? \&$sym 
    35:			 : do {
  Package /usr/share/perl5/Digest/HMAC_MD5.pm.
  2:	$VERSION="1.01";
  10:	@ISA=qw(Digest::HMAC);
  11:	sub new
  12:	{
  18:	require Exporter;
  19:	*import = \&Exporter::import;
  21:	@EXPORT_OK=qw(hmac_md5 hmac_md5_hex);
  33:	1;
  16:	use Digest::HMAC_MD5 qw/hmac_md5_hex/; 
  16:	use Digest::HMAC_MD5 qw/hmac_md5_hex/; 
  entering Exporter::import
   30:	  my $pkg = shift;
   31:	  my $callpkg = caller($ExportLevel);
   33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   40:	  return export $pkg, $callpkg, @_
   41:	    if $Verbose or $Debug or @$fail > 1;
   42:	  my $export_cache = ($Cache{$pkg} ||= {});
   43:	  my $args = @_ or @_ = @$exports;
   45:	  local $_;
   46:	  if ($args and not %$export_cache) {
   48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
   48:	      foreach (@$exports, @{"$pkg\::EXPORT_OK"});
   47:	    s/^&//, $export_cache->{$_} = 1
   50:	  my $heavy;
   53:	  if ($args or $fail) {
   54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
   55:	               or @$fail and $_ eq $fail->[0])) and last
   56:	                 foreach (@_);
   56:	                 foreach (@_);
   61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
   63:		sub {require Carp; &Carp::carp};
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
 entering CODE(0x84dbb60)
  17:	use MIME::Base64;
  entering CODE(0x84ffd60)
   5:	use strict;
   5:	use strict;
   5:	use strict;
   entering strict::import
    28:	    shift;
    29:	    $^H |= @_ ? bits(@_) : $default_bits;
  entering CODE(0x84ffd6c)
   6:	use vars qw(@ISA @EXPORT $VERSION);
   6:	use vars qw(@ISA @EXPORT $VERSION);
   6:	use vars qw(@ISA @EXPORT $VERSION);
   entering vars::import
    11:	    my $callpack = caller;
    12:	    my ($pack, @imports) = @_;
    13:	    my ($sym, $ch);
    14:	    foreach (@imports) {
    15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
    16:		    if ($sym =~ /\W/) {
    28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
    29:		    *$sym =
    30:			(  $ch eq "\$" ? \$$sym
    31:			 : $ch eq "\@" ? \@$sym
    32:			 : $ch eq "\%" ? \%$sym
    33:			 : $ch eq "\*" ? \*$sym
    34:			 : $ch eq "\&" ? \&$sym 
    35:			 : do {
    15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
    16:		    if ($sym =~ /\W/) {
    28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
    29:		    *$sym =
    30:			(  $ch eq "\$" ? \$$sym
    31:			 : $ch eq "\@" ? \@$sym
    32:			 : $ch eq "\%" ? \%$sym
    33:			 : $ch eq "\*" ? \*$sym
    34:			 : $ch eq "\&" ? \&$sym 
    35:			 : do {
    15:	        if (($ch, $sym) = /^([\$\@\%\*\&])(.+)/) {
    16:		    if ($sym =~ /\W/) {
    28:		    $sym = "${callpack}::$sym" unless $sym =~ /::/;
    29:		    *$sym =
    30:			(  $ch eq "\$" ? \$$sym
    31:			 : $ch eq "\@" ? \@$sym
    32:			 : $ch eq "\%" ? \%$sym
    33:			 : $ch eq "\*" ? \*$sym
    34:			 : $ch eq "\&" ? \&$sym 
    35:			 : do {
  Package /usr/lib/perl/5.8/MIME/Base64.pm.
  8:	require Exporter;
  9:	@ISA = qw(Exporter);
  10:	@EXPORT = qw(encode_base64 decode_base64);
  12:	$VERSION = '3.07';
  14:	require XSLoader;
  15:	XSLoader::load('MIME::Base64', $VERSION);
  entering XSLoader::load
   25:	    die q{XSLoader::load('Your::Module', $Your::Module::VERSION)} unless @_;
   27:	    my($module) = $_[0];
   30:	    my $b = "$module\::bootstrap";
   31:	    goto &$b if defined &$b;
   33:	    goto retry unless $module and defined &dl_load_file;
   35:	    my @modparts = split(/::/,$module);
   36:	    my $modfname = $modparts[-1];
   38:	    my $modpname = join('/',@modparts);
   39:	    my $modlibname = (caller())[1];
   40:	    my $c = @modparts;
   41:	    $modlibname =~ s,[\\/][^\\/]+$,, while $c--;	# Q&D basename
   42:	    my $file = "$modlibname/auto/$modpname/$modfname.$dl_dlext";
   46:	    my $bs = $file;
   47:	    $bs =~ s/(\.\w+)?(;\d*)?$/\.bs/; # look for .bs 'beside' the library
   49:	    goto retry if not -f $file or -s $bs;
   51:	    my $bootname = "boot_$module";
   52:	    $bootname =~ s/\W/_/g;
   53:	    @DynaLoader::dl_require_symbols = ($bootname);
   55:	    my $boot_symbol_ref;
   57:	    if ($^O eq 'darwin') {
   70:	    my $libref = dl_load_file($file, 0) or do { 
   entering DynaLoader::dl_load_file
   74:	    push(@DynaLoader::dl_librefs,$libref);  # record loaded object
   76:	    my @unresolved = dl_undef_symbols();
   entering DynaLoader::dl_undef_symbols
   77:	    if (@unresolved) {
   82:	    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {
   entering DynaLoader::dl_find_symbol
   87:	    push(@DynaLoader::dl_modules, $module); # record loaded module
   89:	  boot:
   90:	    my $xs = dl_install_xsub("${module}::bootstrap", $boot_symbol_ref, $file);
   entering DynaLoader::dl_install_xsub
   93:	    return &$xs(@_);
   entering MIME::Base64::bootstrap
  17:	*encode = \&encode_base64;
  18:	*decode = \&decode_base64;
  20:	1;
  17:	use MIME::Base64;
  17:	use MIME::Base64;
  entering Exporter::import
   30:	  my $pkg = shift;
   31:	  my $callpkg = caller($ExportLevel);
   33:	  if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   39:	  my($exports, $fail) = (\@{"$pkg\::EXPORT"}, \@{"$pkg\::EXPORT_FAIL"});
   40:	  return export $pkg, $callpkg, @_
   41:	    if $Verbose or $Debug or @$fail > 1;
   42:	  my $export_cache = ($Cache{$pkg} ||= {});
   43:	  my $args = @_ or @_ = @$exports;
   45:	  local $_;
   46:	  if ($args and not %$export_cache) {
   50:	  my $heavy;
   53:	  if ($args or $fail) {
   54:	    ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
   55:	               or @$fail and $_ eq $fail->[0])) and last
   56:	                 foreach (@_);
   56:	                 foreach (@_);
   61:	  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
   63:		sub {require Carp; &Carp::carp};
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
   65:	  *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
 entering CODE(0x84e49c8)
  19:	use constant Unconnected   => 0;
  entering CODE(0x85074c4)
   3:	use strict;
   3:	use strict;
   3:	use strict;
   entering strict::import
    28:	    shift;
    29:	    $^H |= @_ ? bits(@_) : $default_bits;
  entering CODE(0x85074d0)
   4:	use 5.006_00;
   4:	use 5.006_00;
   4:	use 5.006_00;
  entering CODE(0x85074dc)
   5:	use warnings::register;
   5:	use warnings::register;
   5:	use warnings::register;
   entering warnings::register::import
    18:	    shift;
    19:	    my $package = (caller(0))[0];
    20:	    if (! defined $warnings::Bits{$package}) {
    21:	        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);
    entering warnings::register::mkMask
     9:	    my ($bit) = @_;
     10:	    my $mask = "";
     12:	    vec($mask, $bit, 1) = 1;
     13:	    return $mask;
    22:	        vec($warnings::Bits{'all'}, $warnings::LAST_BIT, 1) = 1;
    23:	        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;
    24:		foreach my $k (keys %warnings::Bits) {
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    25:		    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;
    27:	        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);
    entering warnings::register::mkMask
     9:	    my ($bit) = @_;
     10:	    my $mask = "";
     12:	    vec($mask, $bit, 1) = 1;
     13:	    return $mask;
    28:	        vec($warnings::DeadBits{'all'}, $warnings::LAST_BIT++, 1) = 1;
  entering CODE(0x850807c)
   94:		    no strict 'refs';
   94:		    no strict 'refs';
   94:		    no strict 'refs';
   entering strict::unimport
    33:	    shift;
    34:	    $^H &= ~ (@_ ? bits(@_) : $default_bits);
    entering strict::bits
     12:	    my $bits = 0;
     13:	    my @wrong;
     14:	    foreach my $s (@_) {
     15:		push @wrong, $s unless exists $bitmask{$s};
     16:	        $bits |= $bitmask{$s} || 0;
     18:	    if (@wrong) {
     22:	    $bits;
  Package /usr/share/perl/5.8/constant.pm.
  7:	our($VERSION, %declared);
  8:	$VERSION = '1.05';
  13:	my %keywords = map +($_, 1), qw{ BEGIN INIT CHECK END DESTROY AUTOLOAD };
  15:	my %forced_into_main = map +($_, 1),
  16:	    qw{ STDIN STDOUT STDERR ARGV ARGVOUT ENV INC SIG };
  18:	my %forbidden = (%keywords, %forced_into_main);
  115:	1;
  19:	use constant Unconnected   => 0;
  19:	use constant Unconnected   => 0;
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 entering CODE(0x84dbb84)
  20:	use constant Connected     => 1; # connected; not logged in
  20:	use constant Connected     => 1; # connected; not logged in
  20:	use constant Connected     => 1; # connected; not logged in
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 entering CODE(0x84e4998)
  21:	use constant Authenticated => 2; # logged in; no mailbox selected
  21:	use constant Authenticated => 2; # logged in; no mailbox selected
  21:	use constant Authenticated => 2; # logged in; no mailbox selected
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 entering CODE(0x84a6b7c)
  22:	use constant Selected      => 3; # mailbox selected
  22:	use constant Selected      => 3; # mailbox selected
  22:	use constant Selected      => 3; # mailbox selected
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 entering CODE(0x8507770)
  24:	use constant INDEX         => 0; # Array index for output line number
  24:	use constant INDEX         => 0; # Array index for output line number
  24:	use constant INDEX         => 0; # Array index for output line number
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 entering CODE(0x8507698)
  25:	use constant TYPE          => 1; # Array index for line type
  25:	use constant TYPE          => 1; # Array index for line type
  25:	use constant TYPE          => 1; # Array index for line type
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 entering CODE(0x84e948c)
  27:	use constant DATA          => 2; # Array index for output line data
  27:	use constant DATA          => 2; # Array index for output line data
  27:	use constant DATA          => 2; # Array index for output line data
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 entering CODE(0x8510768)
  29:	use constant NonFolderArg => 1;  # Value to pass to Massage to
  29:	use constant NonFolderArg => 1;  # Value to pass to Massage to
  29:	use constant NonFolderArg => 1;  # Value to pass to Massage to
  entering constant::import
   29:	    my $class = shift;
   30:	    return unless @_;			# Ignore 'use constant;'
   31:	    my %constants = ();
   32:	    my $multiple  = ref $_[0];
   34:	    if ( $multiple ) {
   41:		$constants{+shift} = undef;
   44:	    foreach my $name ( keys %constants ) {
   45:		unless (defined $name) {
   49:		my $pkg = caller;
   52:		if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
   94:		    no strict 'refs';
   95:		    my $full_name = "${pkg}::$name";
   96:		    $declared{$full_name}++;
   97:		    if ($multiple) {
   101:			if (@_ == 1) {
   102:			    my $scalar = $_[0];
   103:			    *$full_name = sub () { $scalar };
 entering CODE(0x8510d2c)
  54:	   { no strict 'refs';
  54:	   { no strict 'refs';
  54:	   { no strict 'refs';
  entering strict::unimport
   33:	    shift;
   34:	    $^H &= ~ (@_ ? bits(@_) : $default_bits);
   entering strict::bits
    12:	    my $bits = 0;
    13:	    my @wrong;
    14:	    foreach my $s (@_) {
    15:		push @wrong, $s unless exists $bitmask{$s};
    16:	        $bits |= $bitmask{$s} || 0;
    18:	    if (@wrong) {
    22:	    $bits;
 entering CODE(0x8510b4c)
  48:	   foreach my $datum (
  49:	     qw(State Port Server Folder Peek User Password Timeout Buffer
  50:	        Debug Count Uid Debug_fh Maxtemperrors
  51:	        EnableServerResponseInLiteral Authmechanism Authcallback Ranges
  52:	        Readmethod Showcredentials Prewritemethod Ignoresizeerrors
  53:	        Supportedflags Proxy))
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
 entering CODE(0x85ab5dc)
  1324:	        no warnings;
  1324:	        no warnings;
  1324:	        no warnings;
  entering warnings::unimport
   251:	    shift;
   253:	    my $catmask ;
   254:	    my $mask = ${^WARNING_BITS} ;
   256:	    if (vec($mask, $Offsets{'all'}, 1)) {
   257:	        $mask |= $Bits{'all'} ;
   258:	        $mask |= $DeadBits{'all'} if vec($mask, $Offsets{'all'}+1, 1);
   261:	    push @_, 'all' unless @_;
   263:	    foreach my $word ( @_ ) {
   264:		if ($word eq 'FATAL') {
   268:		    $mask &= ~($catmask | $DeadBits{$word} | $All);
   274:	    ${^WARNING_BITS} = $mask ;
 Package Mail-IMAPClient-2.99_02/lib/Mail/IMAPClient.pm.
 3:	our $VERSION = '2.99_02';
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 32:	my %SEARCH_KEYS = map { ( $_ => 1 ) } qw/
 33:	    ALL ANSWERED BCC BEFORE BODY CC DELETED DRAFT FLAGGED
 34:	    FROM HEADER KEYWORD LARGER NEW NOT OLD ON OR RECENT
 35:	    SEEN SENTBEFORE SENTON SENTSINCE SINCE SMALLER SUBJECT
 36:	    TEXT TO UID UNANSWERED UNDELETED UNDRAFT UNFLAGGED
 37:	    UNKEYWORD UNSEEN/;
 110:	my @dow  = qw/Sun Mon Tue Wed Thu Fri Sat/;
 111:	my @mnt  = qw/Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec/;
 2129:	my $thread_parser;
 2130:	sub thread
 2856:	1;
 4:	use Mail::IMAPClient;
 4:	use Mail::IMAPClient;
Package t/01_connect.
6:	$imap = Mail::IMAPClient->new(Debug => 1);
entering Mail::IMAPClient::new
 171:	{   my $class = shift;
 172:	    my $self  =
 173:	      { LastError     => "",
 174:	      , Uid           => 1
 175:	      , Count         => 0
 176:	      , Fast_io       => 1
 177:	      , Clear         => 5
 178:	      , Maxtemperrors => 'unlimited'
 179:	      , State         => Unconnected
 181:	    while(@_)
 182:	    {   my $k = ucfirst lc shift;
 183:	        $self->{$k} = shift;
 185:	    bless $self, ref($class)||$class;
 187:	    if($self->{Supportedflags})  # unpack into case-less HASH
 192:	    $self->{Debug_fh} ||= \*STDERR;
 193:	    select((select($self->{Debug_fh}),$|++)[0]);
 195:	    $self->_debug("Using Mail::IMAPClient version $Mail::IMAPClient::VERSION " .
 196:	        "and perl version " . (defined $^V ? join(".",unpack("CCC",$^V)) : "") .
 197:	        " ($])\n") if $self->Debug;
 entering CODE(0x8511284)
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
 entering Mail::IMAPClient::_debug
  40:	{   my $self = shift;
  41:	    return unless $self->Debug;
  entering CODE(0x8511284)
   55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
  42:	    my $fh   = $self->{Debug_fh} || \*STDERR;
  43:	    print $fh @_;
 199:	    if($self->{Socket})    { $self->Socket($self->{Socket}) }
 202:	    $self;
7:	$imap->Debug(1);
entering CODE(0x8511284)
 55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
8:	$imap->Server('louloutte.dyndns.org');
entering CODE(0x8510f3c)
 55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
9:	$imap->connect() or croak "Error connecting @!";
entering Mail::IMAPClient::connect
 206:	{   my $self = shift;
 207:	    %$self = (%$self, @_);
 209:	    my $sock = IO::Socket::INET->new
 210:	      ( PeerAddr => $self->Server
 211:	      , PeerPort => ( $self->Port   || 'imap(143)')
 212:	      , Timeout  => ($self->Timeout || 0)
 213:	      , Proto    => 'tcp'
 214:	      , Debug    => $self->Debug
 215:	      );
 entering CODE(0x8510f3c)
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
 entering CODE(0x8510ec4)
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
 entering CODE(0x8511194)
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
 entering CODE(0x8511284)
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
 entering IO::Socket::INET::new
  30:	    my $class = shift;
  31:	    unshift(@_, "PeerAddr") if @_ == 1;
  32:	    return $class->SUPER::new(@_);
  entering IO::Socket::new
   41:	    my($class,%arg) = @_;
   42:	    my $sock = $class->SUPER::new();
   entering IO::Handle::new
    53:	    my $class = ref($_[0]) || $_[0] || "IO::Handle";
    54:	    @_ == 1 or croak "usage: new $class";
    55:	    my $io = gensym;
    entering Symbol::gensym
     23:	    my $name = "GEN" . $genseq++;
     24:	    my $ref = \*{$genpkg . $name};
     24:	    my $ref = \*{$genpkg . $name};
     25:	    delete $$genpkg{$name};
     26:	    $ref;
    56:	    bless $io, $class;
   44:	    $sock->autoflush(1);
   entering IO::Handle::autoflush
    213:	    my $old = new SelectSaver qualify($_[0], caller);
    entering Symbol::qualify
     39:	    my ($name) = @_;
     40:	    if (!ref($name) && index($name, '::') == -1 && index($name, "'") == -1) {
     53:	    $name;
    entering SelectSaver::new
     10:	    @_ >= 1 && @_ <= 2 or croak 'usage: new SelectSaver [FILEHANDLE]';
     11:	    my $fh = select;
     12:	    my $self = bless \$fh, $_[0];
     13:	    select qualify($_[1], caller) if @_ > 1;
     entering Symbol::qualify
      39:	    my ($name) = @_;
      40:	    if (!ref($name) && index($name, '::') == -1 && index($name, "'") == -1) {
      53:	    $name;
     14:	    $self;
    214:	    my $prev = $|;
    215:	    $| = @_ > 1 ? $_[1] : 1;
    216:	    $prev;
    entering SelectSaver::DESTROY
     18:	    my $self = $_[0];
     19:	    select $$self;
   46:	    ${*$sock}{'io_socket_timeout'} = delete $arg{Timeout};
   46:	    ${*$sock}{'io_socket_timeout'} = delete $arg{Timeout};
   48:	    return scalar(%arg) ? $sock->configure(\%arg)
   49:				: $sock;
   entering IO::Socket::INET::configure
    104:	    my($sock,$arg) = @_;
    105:	    my($lport,$rport,$laddr,$raddr,$proto,$type);
    107:	    $arg->{LocalAddr} = $arg->{LocalHost}
    108:		if exists $arg->{LocalHost} && !exists $arg->{LocalAddr};
    110:	    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},
    111:						$arg->{LocalPort},
    112:						$arg->{Proto})
    113:				or return _error($sock, $!, $@);
    entering IO::Socket::INET::_sock_info
     36:	  my($addr,$port,$proto) = @_;
     37:	  my $origport = $port;
     38:	  my @proto = ();
     39:	  my @serv = ();
     41:	  $port = $1
     42:		if(defined $addr && $addr =~ s,:([\w\(\)/]+)$,,);
     44:	  if(defined $proto  && $proto =~ /\D/) {
     45:	    if(@proto = getprotobyname($proto)) {
     46:	      $proto = $proto[2] || undef;
     54:	  if(defined $port) {
     71:	 return ($addr || undef,
     72:		 $port || undef,
     73:		 $proto || undef
     74:		);
    115:	    $laddr = defined $laddr ? inet_aton($laddr)
    116:				    : INADDR_ANY;
    entering Socket::AUTOLOAD for Socket::INADDR_ANY
     216:	    my($constname);
     217:	    ($constname = $AUTOLOAD) =~ s/.*:://;
     218:	    croak "&Socket::constant not defined" if $constname eq 'constant';
     219:	    my ($error, $val) = constant($constname);
     entering Socket::constant
     220:	    if ($error) {
     223:	    *$AUTOLOAD = sub { $val };
     224:	    goto &$AUTOLOAD;
     223:	    *$AUTOLOAD = sub { $val };
    118:	    return _error($sock, $EINVAL, "Bad hostname '",$arg->{LocalAddr},"'")
    119:		unless(defined $laddr);
    121:	    $arg->{PeerAddr} = $arg->{PeerHost}
    122:		if exists $arg->{PeerHost} && !exists $arg->{PeerAddr};
    124:	    unless(exists $arg->{Listen}) {
    125:		($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},
    126:						    $arg->{PeerPort},
    127:						    $proto)
    128:				or return _error($sock, $!, $@);
    entering IO::Socket::INET::_sock_info
     36:	  my($addr,$port,$proto) = @_;
     37:	  my $origport = $port;
     38:	  my @proto = ();
     39:	  my @serv = ();
     41:	  $port = $1
     42:		if(defined $addr && $addr =~ s,:([\w\(\)/]+)$,,);
     44:	  if(defined $proto  && $proto =~ /\D/) {
     54:	  if(defined $port) {
     55:	    my $defport = ($port =~ s,\((\d+)\)$,,) ? $1 : undef;
     56:	    my $pnum = ($port =~ m,^(\d+)$,)[0];
     58:	    @serv = getservbyname($port, $proto[0] || "")
     59:		if ($port =~ m,\D,);
     61:	    $port = $serv[2] || $defport || $pnum;
     62:	    unless (defined $port) {
     67:	    $proto = (getprotobyname($serv[3]))[2] || undef
     68:		if @serv && !$proto;
     71:	 return ($addr || undef,
     72:		 $port || undef,
     73:		 $proto || undef
     74:		);
    131:	    $proto ||= (getprotobyname('tcp'))[2];
    133:	    my $pname = (getprotobynumber($proto))[0];
    134:	    $type = $arg->{Type} || $socket_type{lc $pname};
    136:	    my @raddr = ();
    138:	    if(defined $raddr) {
    139:		@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});
    entering IO::Socket::INET::_get_addr
     92:	    my($sock,$addr_str, $multi) = @_;
     93:	    my @addr;
     94:	    if ($multi && $addr_str !~ /^\d+(?:\.\d+){3}$/) {
     97:		my $h = inet_aton($addr_str);
     entering Socket::inet_aton
     98:		push(@addr, $h) if defined $h;
     100:	    @addr;
    140:		return _error($sock, $EINVAL, "Bad hostname '",$arg->{PeerAddr},"'")
    141:		    unless @raddr;
    144:	    while(1) {
    146:		$sock->socket(AF_INET, $type, $proto) or
    147:		    return _error($sock, $!, "$!");
    entering CODE(0x846272c)
     223:	    *$AUTOLOAD = sub { $val };
    entering IO::Socket::socket
     77:	    @_ == 4 or croak 'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)';
     78:	    my($sock,$domain,$type,$protocol) = @_;
     80:	    socket($sock,$domain,$type,$protocol) or
     81:	    	return undef;
     83:	    ${*$sock}{'io_socket_domain'} = $domain;
     83:	    ${*$sock}{'io_socket_domain'} = $domain;
     84:	    ${*$sock}{'io_socket_type'}   = $type;
     84:	    ${*$sock}{'io_socket_type'}   = $type;
     85:	    ${*$sock}{'io_socket_proto'}  = $protocol;
     85:	    ${*$sock}{'io_socket_proto'}  = $protocol;
     87:	    $sock;
    149:	        if (defined $arg->{Blocking}) {
    154:		if ($arg->{Reuse} || $arg->{ReuseAddr}) {
    159:		if ($arg->{ReusePort}) {
    164:		if ($arg->{Broadcast}) {
    169:		if($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {
    entering CODE(0x8571688)
     223:	    *$AUTOLOAD = sub { $val };
    174:		if(exists $arg->{Listen}) {
    181:	 	last unless exists($arg->{PeerAddr});
    183:	        $raddr = shift @raddr;
    185:		return _error($sock, $EINVAL, 'Cannot determine remote port')
    186:			unless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);
    189:		    unless($type == SOCK_STREAM || defined $raddr);
    entering CODE(0x84781ac)
     223:	    *$AUTOLOAD = sub { $val };
    191:		return _error($sock, $EINVAL, "Bad hostname '",$arg->{PeerAddr},"'")
    192:		    unless defined $raddr;
    197:		undef $@;
    198:	        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {
    entering Socket::pack_sockaddr_in
    entering IO::Socket::INET::connect
     220:	    @_ == 2 || @_ == 3 or
     221:	       croak 'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)';
     222:	    my $sock = shift;
     223:	    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));
     entering IO::Socket::connect
      106:	    @_ == 2 or croak 'usage: $sock->connect(NAME)';
      107:	    my $sock = shift;
      108:	    my $addr = shift;
      109:	    my $timeout = ${*$sock}{'io_socket_timeout'};
      109:	    my $timeout = ${*$sock}{'io_socket_timeout'};
      110:	    my $err;
      111:	    my $blocking;
      113:	    $blocking = $sock->blocking(0) if $timeout;
      114:	    if (!connect($sock, $addr)) {
      137:	    $sock->blocking(1) if $blocking;
      139:	    $! = $err if $err;
      141:	    $err ? undef : $sock;
    200:	            return $sock;
 217:	    unless($sock)
 222:	    $self->Socket($sock);
 entering Mail::IMAPClient::Socket
  97:	{   my ($self, $sock) = @_;
  98:	    defined $sock
  99:	       or return $self->{Socket};
  101:	    delete $self->{_fcntl};
  103:	    $self->{_select} = IO::Select->new($_[1]);
  entering IO::Select::new
   24:	 my $self = shift;
   25:	 my $type = ref($self) || $self;
   27:	 my $vec = bless [undef,0], $type;
   29:	 $vec->add(@_)
   30:	    if @_;
   entering IO::Select::add
    37:	 shift->_update('add', @_);
    entering IO::Select::_update
     63:	 my $vec = shift;
     64:	 my $add = shift eq 'add';
     66:	 my $bits = $vec->[VEC_BITS];
     67:	 $bits = '' unless defined $bits;
     69:	 my $count = 0;
     70:	 my $f;
     71:	 foreach $f (@_)
     72:	  {
     73:	   my $fn = $vec->_fileno($f);
     entering IO::Select::_fileno
      55:	 my($self, $f) = @_;
      56:	 return unless defined $f;
      57:	 $f = $f->[0] if ref($f) eq 'ARRAY';
      58:	 ($f =~ /^\d+$/) ? $f : fileno($f);
     74:	   next unless defined $fn;
     75:	   my $i = $fn + FIRST_FD;
     76:	   if ($add) {
     77:	     if (defined $vec->[$i]) {
     81:	     $vec->[FD_COUNT]++;
     82:	     vec($bits, $fn, 1) = 1;
     83:	     $vec->[$i] = $f;
     90:	   $count++;
     92:	 $vec->[VEC_BITS] = $vec->[FD_COUNT] ? $bits : undef;
     93:	 $count;
   32:	 $vec;
 223:	    $self->State(Connected);
 entering CODE(0x8510dc8)
  55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
 224:	    $sock->autoflush(1);
 entering IO::Handle::autoflush
  213:	    my $old = new SelectSaver qualify($_[0], caller);
  entering Symbol::qualify
   39:	    my ($name) = @_;
   40:	    if (!ref($name) && index($name, '::') == -1 && index($name, "'") == -1) {
   53:	    $name;
  entering SelectSaver::new
   10:	    @_ >= 1 && @_ <= 2 or croak 'usage: new SelectSaver [FILEHANDLE]';
   11:	    my $fh = select;
   12:	    my $self = bless \$fh, $_[0];
   13:	    select qualify($_[1], caller) if @_ > 1;
   entering Symbol::qualify
    39:	    my ($name) = @_;
    40:	    if (!ref($name) && index($name, '::') == -1 && index($name, "'") == -1) {
    53:	    $name;
   14:	    $self;
  214:	    my $prev = $|;
  215:	    $| = @_ > 1 ? $_[1] : 1;
  216:	    $prev;
  entering SelectSaver::DESTROY
   18:	    my $self = $_[0];
   19:	    select $$self;
 226:	    my $code;
 227:	  LINE:
 228:	    while(my $output = $self->_read_line)
 entering Mail::IMAPClient::_read_line
  1274:	{   my ($self, $literal_callback, $output_callback) = @_;
  1276:	    my $sh = $self->Socket;
  entering Mail::IMAPClient::Socket
   97:	{   my ($self, $sock) = @_;
   98:	    defined $sock
   99:	       or return $self->{Socket};
  1277:	    unless($self->IsConnected && $self->Socket)
  entering Mail::IMAPClient::IsConnected
   2816:	sub IsConnected     { shift->State >= Connected }
   entering CODE(0x8510dc8)
    55:	     *$datum = sub { @_ > 1 ? $_[0]->{$datum} = $_[1] : $_[0]->{$datum} };
  entering Mail::IMAPClient::Socket
   97:	{   my ($self, $sock) = @_;
   98:	    defined $sock
   99:	       or return $self->{Socket};
  1278:	    {   $self->LastError("NO Not connected.");
  entering Mail::IMAPClient::LastError
   60:	{   my $self = shift;
   61:	    $self->{LastError} = shift if @_;
   62:	    $@ = $self->{LastError};
  1279:	        return undef;
 238:	    $code or return undef;
entering Carp::croak
 102:	sub croak   { die  shortmess @_ }
 entering Carp::shortmess
  86:		local($@, $!);
  86:		local($@, $!);
  89:		require Carp::Heavy unless $INC{"Carp/Heavy.pm"};
  92:	    my $call_pack = caller();
  93:	    local @CARP_NOT = caller();
  94:	    shortmess_heavy(@_);
  entering Carp::shortmess_heavy
   177:	  return longmess_heavy(@_) if $Verbose;
   178:	  return @_ if ref($_[0]); # don't break references as exceptions
   179:	  my $i = short_error_loc();
   entering Carp::short_error_loc
    160:	  my $cache;
    161:	  my $i = 1;
    162:	  my $lvl = $CarpLevel;
    163:	  {
    164:	    my $called = caller($i++);
    164:	    my $called = caller($i++);
    165:	    my $caller = caller($i);
    166:	    return 0 unless defined($caller); # What happened?
    167:	    redo if $Internal{$caller};
    168:	    redo if $CarpInternal{$called};
    164:	    my $called = caller($i++);
    165:	    my $caller = caller($i);
    166:	    return 0 unless defined($caller); # What happened?
    167:	    redo if $Internal{$caller};
    168:	    redo if $CarpInternal{$called};
    164:	    my $called = caller($i++);
    165:	    my $caller = caller($i);
    166:	    return 0 unless defined($caller); # What happened?
   180:	  if ($i) {
   184:	    longmess_heavy(@_);
   entering Carp::longmess_heavy
    115:	  return @_ if ref($_[0]); # don't break references as exceptions
    116:	  my $i = long_error_loc();
    entering Carp::long_error_loc
     91:	  my $i;
     92:	  my $lvl = $CarpLevel;
     93:	  {
     94:	    my $pkg = caller(++$i);
     94:	    my $pkg = caller(++$i);
     95:	    unless(defined($pkg)) {
     107:	    redo if $CarpInternal{$pkg};
     94:	    my $pkg = caller(++$i);
     95:	    unless(defined($pkg)) {
     107:	    redo if $CarpInternal{$pkg};
     94:	    my $pkg = caller(++$i);
     95:	    unless(defined($pkg)) {
     107:	    redo if $CarpInternal{$pkg};
     94:	    my $pkg = caller(++$i);
     95:	    unless(defined($pkg)) {
     107:	    redo if $CarpInternal{$pkg};
     108:	    redo unless 0 > --$lvl;
     109:	    redo if $Internal{$pkg};
     111:	  return $i - 1;
    117:	  return ret_backtrace($i, @_);
    entering Carp::ret_backtrace
     123:	  my ($i, @error) = @_;
     124:	  my $mess;
     125:	  my $err = join '', @error;
     126:	  $i++;
     128:	  my $tid_msg = '';
     129:	  if (defined &Thread::tid) {
     134:	  my %i = caller_info($i);
     entering Carp::caller_info
      12:	  my $i = shift(@_) + 1;
      13:	  package DB;
      14:	
      15:	
      16:	
      17:	
      18:	
      19:	
      20:	
      21:	
      22:	
      23:	
      24:	
      25:	
      26:	
      27:	
      28:	
      29:	
      30:	
      31:	
      32:	
      33:	
      34:	
      35:	
      73:	  my $info = shift;
      74:	  if (defined($info->{evaltext})) {
      85:	  return ($info->{sub} eq '(eval)') ? 'eval {...}' : $info->{sub};
      39:	  my $arg = shift;
      40:	  if (ref($arg)) {
      45:	  $arg =~ s/'/\\'/g;
      46:	  $arg = str_len_trim($arg, $MaxArgLen);
      entering Carp::str_len_trim
       190:	  my $str = shift;
       191:	  my $max = shift || 0;
       192:	  if (2 < $max and $max < length($str)) {
       195:	  return $str;
      49:	  $arg = "'$arg'" unless $arg =~ /^-?[\d.]+\z/;
      55:	    or $arg =~ s/([[:cntrl:]]|[[:^ascii:]])/sprintf("\\x{%x}",ord($1))/eg;
      entering utf8::is_utf8
      56:	  return $arg;
     135:	  $mess = "$err at $i{file} line $i{line}$tid_msg\n";
     137:	  while (my %i = caller_info(++$i)) {
     entering Carp::caller_info
      12:	  my $i = shift(@_) + 1;
      13:	  package DB;
      14:	
      15:	
      16:	
      17:	
      18:	
      19:	
      20:	
      21:	
      22:	
      23:	
      24:	
      25:	
      26:	
      27:	
      28:	
      29:	
      30:	
      31:	
      32:	
      33:	
      34:	
      35:	
     141:	  return $mess;
entering IO::Handle::DESTROY
 75:	sub DESTROY {}
entering IO::Handle::DESTROY
 75:	sub DESTROY {}
entering Config::DESTROY
 62:	sub DESTROY { }
entering IO::Handle::DESTROY
 75:	sub DESTROY {}
