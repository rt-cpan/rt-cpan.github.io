--- a/lib/IO/Async/Loop.pm
+++ b/lib/IO/Async/Loop.pm
@@ -16,6 +16,10 @@
 # Base value but some classes might override
 use constant _CAN_ON_HANGUP => 0;
 
+# Some Loop implementations do not accurately handle sub-second timers.
+# This only matters for unit tests
+use constant _CAN_SUBSECOND_ACCURATELY => 1;
+
 use Carp;
 
 use IO::Socket (); # empty import
--- a/lib/IO/Async/LoopTests.pm
+++ b/lib/IO/Async/LoopTests.pm
@@ -464,21 +464,25 @@
       }
    } 1.5, 2.5, 'loop_once(5) while waiting for timer';
 
-   # Check that short delays are achievable in one ->loop_once call
-   foreach my $delay ( 0.001, 0.01, 0.1 ) {
-      my $done;
-      my $count = 0;
-      my $start = time;
-
-      $loop->enqueue_timer( delay => $delay, code => sub { $done++ } );
-
-      while( !$done ) {
-         $loop->loop_once( 1 );
-         $count++;
-         last if time - $start > 5; # bailout
-      }
+   SKIP: {
+      skip "Unable to handle sub-second timers accurately", 3 unless $loop->_CAN_SUBSECOND_ACCURATELY;
+
+      # Check that short delays are achievable in one ->loop_once call
+      foreach my $delay ( 0.001, 0.01, 0.1 ) {
+         my $done;
+         my $count = 0;
+         my $start = time;
+
+         $loop->enqueue_timer( delay => $delay, code => sub { $done++ } );
 
-      is( $count, 1, "One ->loop_once(1) sufficient for a single $delay second timer" );
+         while( !$done ) {
+            $loop->loop_once( 1 );
+            $count++;
+            last if time - $start > 5; # bailout
+         }
+
+         is( $count, 1, "One ->loop_once(1) sufficient for a single $delay second timer" );
+      }
    }
 
    $cancelled_fired = 0;
