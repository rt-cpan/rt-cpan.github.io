Description: fix POD spelling errors
Origin: vendor
Author: Jonathan Yu <jawnsy@cpan.org>
Reviewed-by: gregor herrmann <gregoa@debian.org>
Last-Update: 2016-10-30

--- a/lib/Net/SIP/Endpoint.pod
+++ b/lib/Net/SIP/Endpoint.pod
@@ -133,7 +133,7 @@
 
 =item from
 
-The adress to register at the registrar. Mandatory.
+The address to register at the registrar. Mandatory.
 
 =item contact
 
--- a/lib/Net/SIP/Leg.pod
+++ b/lib/Net/SIP/Leg.pod
@@ -116,7 +116,7 @@
 ADDR is a hostname which can be prefixed by the protocol ( e.g. C<udp:host> )
 and postfixed by the port ( C<host:port>, C<tcp:host:port>,... ).
 
-If the caller has 'proto','addr' and 'port' already as seperate items
+If the caller has 'proto','addr' and 'port' already as separate items
 it can call the method with %SPEC instead.
 
 Right now it has now way to check if the leg can deliver to a specific
--- a/lib/Net/SIP/Request.pod
+++ b/lib/Net/SIP/Request.pod
@@ -77,7 +77,7 @@
 
 Returns Net::SIP::Response packet for the received request C<$self> with
 numerical code CODE and text message MSG. Header for the response will
-be based on the request, but can be added or overriden using \%HEADER.
+be based on the request, but can be added or overridden using \%HEADER.
 If MSG is not given (e.g. argument is missing, second argument is \%HEADER
 already) a builtin message for the code will be used.
 
--- a/lib/Net/SIP/Simple.pod
+++ b/lib/Net/SIP/Simple.pod
@@ -67,8 +67,8 @@
 \@List of legs or single leg. Leg can be an existing L<Net::SIP::Leg> (or derived)
 object, an L<IO::Handle> (existing socket), a hash reference which can be used
 in the constructor of L<Net::SIP::Leg> or a string of C<< "proto:ip:port" >>.
-In the latter case C<proto> can be ommitted (including the colon) and defaults
-to 'udp' and C<port> can be ommitted to (including the colon) defaulting to 5060.
+In the latter case C<proto> can be omitted (including the colon) and defaults
+to 'udp' and C<port> can be omitted to (including the colon) defaulting to 5060.
 
 Either B<legs> or B<outgoing_proxy> has to be provided, e.g. it needs at least one
 leg.
--- a/lib/Net/SIP/Simple/Call.pod
+++ b/lib/Net/SIP/Simple/Call.pod
@@ -193,7 +193,7 @@
 
 =item ...
 
-More parameters may be specified and are accessable from the callbacks.
+More parameters may be specified and are accessible from the callbacks.
 For instance B<media_send_recv> in L<Net::SIP::Simple::RTP> uses a parameter
 B<cb_rtp_done>. See there.
 
--- a/lib/Net/SIP/NATHelper/Base.pod
+++ b/lib/Net/SIP/NATHelper/Base.pod
@@ -144,7 +144,7 @@
 =item active
 
 Expire time for active sessions. Default to 30 seconds. If no data
-gets transfered through the session for C<active> seconds the session
+gets transferred through the session for C<active> seconds the session
 will be closed.
 
 =back
--- a/lib/Net/SIP/Debug.pod
+++ b/lib/Net/SIP/Debug.pod
@@ -80,7 +80,7 @@
 
 Enables debugging for package PACKAGE. PACKAGE might be a fully
 qualified package (e.g. C<Net::SIP::Registrar>) or the C<Net>
-or C<Net::SIP> might be ommited (C<Registrar>). If a C<*> is added
+or C<Net::SIP> might be omitted (C<Registrar>). If a C<*> is added
 the debugging will also be enabled for subpackages, e.g.
 C<Endpoint*> will enable debugging for L<Net::SIP::Endpoint> and
 L<Net::SIP::Endpoint::Context> too.
--- a/lib/Net/SIP/Dispatcher.pod
+++ b/lib/Net/SIP/Dispatcher.pod
@@ -50,7 +50,7 @@
 
 =item do_retransmits
 
-If TRUE retransmits will be done accoring to RFC3261. If FALSE no
+If TRUE retransmits will be done according to RFC3261. If FALSE no
 retransmits will be done, which is used in the case of stateless
 proxies.
 Defaults to TRUE.
@@ -138,7 +138,7 @@
 be decided based on the value of WHEN). Absolute times will be
 specified in time_t (seconds since 1970-01-01 00:00:00) and
 relative time will be specified in seconds.
-WHEN can be floating point to specifiy subseconds.
+WHEN can be floating point to specify subseconds.
 WHEN can be C<0> to trigger the timer immediately.
 
 CALLBACK is a callback usable by B<invoke_callback> in L<Net::SIP::Util>.
@@ -231,7 +231,7 @@
 objects and only these legs are allowed.
 
 Because the method can be asynchronous (DNS lookups can be involved)
-it will call CALLBACK once it is done. If no errors occured
+it will call CALLBACK once it is done. If no errors occurred
 CALLBACK will be invoked without additional arguments, otherwise
 with the errno as additional argument.
 
--- a/lib/Net/SIP/Packet.pm
+++ b/lib/Net/SIP/Packet.pm
@@ -740,9 +740,9 @@
 ###########################################################################
 # Create new HeaderPair
 # Args: ($class,$key,$value,$line,$pos)
-#   $key: orginal key
+#   $key: original key
 #   $value: value
-#   $line: index of header line in orginal header
+#   $line: index of header line in original header
 #   $pos: index within header line if multiple values are in line
 # Returns: $self
 ###########################################################################
--- a/lib/Net/SIP/Packet.pod
+++ b/lib/Net/SIP/Packet.pod
@@ -136,7 +136,7 @@
 values, but if C<wantarray> says, that the caller expects only a
 single value it will C<croak()>.
 
-If no NAME is given it will return a reference to a hash wich contains
+If no NAME is given it will return a reference to a hash which contains
 all fields and has the format described in B<new_from_parts>.
 
 =item add_header ( NAME, VAL )
--- a/lib/Net/SIP/Response.pod
+++ b/lib/Net/SIP/Response.pod
@@ -33,6 +33,6 @@
 
 =item method
 
-Get method for orginal request by parsing the CSeq header.
+Get method for original request by parsing the CSeq header.
 
 =back
--- a/lib/Net/SIP/SDP.pod
+++ b/lib/Net/SIP/SDP.pod
@@ -84,7 +84,7 @@
 =back
 
 If the SDP should contain multiple values for the same key in the same
-media section on can specifiy the value for the key as a \@list instead
+media section on can specify the value for the key as a \@list instead
 of a string (this is often the case for 'a' lines).
 
 =back
--- a/lib/Net/SIP/Util.pod
+++ b/lib/Net/SIP/Util.pod
@@ -122,7 +122,7 @@
 delimiter is C<;>, but for some keys C<,> the field name KEY need to
 be known.
 
-KEY needs to be normalized already (lower case, no abbrevation).
+KEY needs to be normalized already (lower case, no abbreviation).
 
 Returns array with initial data (up to first delimiter) and
 the parameters as hash.
--- a/lib/Net/SIP/Dispatcher/Eventloop.pod
+++ b/lib/Net/SIP/Dispatcher/Eventloop.pod
@@ -81,7 +81,7 @@
 
 Returns the current loop time in subseconds resolution (using B<gettimeofday>
 from L<Time::HiRes>). This is not the current time, but the time, when the
-last event in the loop occured (e.g. when the select(2) call returned)
+last event in the loop occurred (e.g. when the select(2) call returned)
 
 =item loop ( [ TIMEOUT, \@STOPVAR ] )
 
--- a/lib/Net/SIP/Endpoint.pm
+++ b/lib/Net/SIP/Endpoint.pm
@@ -201,7 +201,7 @@
 # delivered (tcp only) or an error occurred
 # Args: ($self,$ctx,$error,$delivery_packet)
 #   $ctx: Net::SIP::Endpoint::Context
-#   $error: errno if error occured
+#   $error: errno if error occurred
 #   $delivery_packet: Net::SIP::Dispatcher::Packet which encapsulates
 #     the original request and information about leg, dst_addr...
 #     and has method use_next_dstaddr to try the next dstaddr if for the
--- a/lib/Net/SIP/Endpoint/Context.pm
+++ b/lib/Net/SIP/Endpoint/Context.pm
@@ -238,7 +238,7 @@
 # layer (e.g response with 400 Bad request) are handled by handle_response()
 # Args: ($self,$tid;$error)
 #  $tid: Transaction ID
-#  $error: errno if error occured
+#  $error: errno if error occurred
 # Returns: NONE
 ############################################################################
 sub request_delivery_done {
--- a/lib/Net/SIP/Endpoint/Context.pod
+++ b/lib/Net/SIP/Endpoint/Context.pod
@@ -148,7 +148,7 @@
 
 =item ERROR
 
-The errno of the error occured ( undef or 0 if no error ).
+The errno of the error occurred ( undef or 0 if no error ).
 These are the same numbers defined in L<Errno>, but they are
 usually not set by a system call, but by the dispatcher
 (like ETIMEDOUT if delivery failed permanently after none of
--- a/lib/Net/SIP/Leg.pm
+++ b/lib/Net/SIP/Leg.pm
@@ -253,8 +253,8 @@
 # Args: ($self,$packet,$addr;$callback)
 #   $packet: Net::SIP::Packet
 #   $addr:   ip:port where to deliver
-#   $callback: optional callback, if an error occured the callback will
-#      be called with $! as argument. If no error occured and the
+#   $callback: optional callback, if an error occurred the callback will
+#      be called with $! as argument. If no error occurred and the
 #      proto is tcp the callback will be called with error=0 to show
 #      that the packet was definitely delivered (and there's no need to retry)
 ###########################################################################
@@ -329,7 +329,7 @@
 #   $port: target port
 #   $callback: callback for error|success, see method deliver
 # Returns: $success
-#   $success: true if no problems occured while sending (this does not
+#   $success: true if no problems occurred while sending (this does not
 #     mean that the packet was delivered reliable!)
 ###########################################################################
 sub sendto {
--- a/lib/Net/SIP/Simple/Call.pm
+++ b/lib/Net/SIP/Simple/Call.pm
@@ -495,7 +495,7 @@
 # Args: ($self,$endpoint,$ctx,$error,$code,$packet,$leg,$from)
 #   $endpoint: the endpoint
 #   $ctx: context for call
-#   $error: errno if error occured
+#   $error: errno if error occurred
 #   $code: code from responses
 #   $packet: incoming packet
 #   $leg: leg where packet came in
@@ -505,7 +505,7 @@
 sub receive {
     my ($self,$endpoint,$ctx,$error,$code,$packet,$leg,$from) = @_;
     if ( ! $packet ) {
-	$self->error( "error occured: $error" );
+	$self->error( "error occurred: $error" );
     } elsif ( $packet->is_request ) {
 	my $method = $packet->method;
 	my $param = $self->{param};
