//--------------------------------------------------
//  
//      Verilog code generated by Visual HDL
//
//  Design Unit:
//  ------------
//      Unit    Name  :  i2c_control_blk
//      Library Name  :  i2c_work
//  
//      Creation Date :  Mon Mar 12 10:41:54 2001
//      Version       :  6.7.0 build 17 from Oct  2 2000
//  
//  Options Used:
//  -------------
//      Target
//         HDL        :  Verilog
//         Purpose    :  Synthesis
//         Vendor     :  Design Compiler
//  
//      Style
//         Use Procedures                 :  No
//         Code Destination               :  Combined file
//         Attach Directives              :  Yes
//         Structural                     :  No
//         Preserve spacing for free text :  Yes
//         Sort Ports by mode             :  No
//         Declaration alignment          :  No
//
//--------------------------------------------------
//--------------------------------------------------
//  
//  Library Name :  i2c_work
//  Unit    Name :  i2c_control_blk
//  Unit    Type :  Block Diagram
//  
//----------------------------------------------------
 
module i2c_control (sda, scl, txak, msta, msta_rst, rsta, mtx, mbdr_micro,
                        madr, mbb, mcf, maas, mal, srw, mif, rxak, mbdr_i2c,
                        mbcr_wr, mif_bit_reset, mal_bit_reset, sys_clk, reset);
 
  //   I2C bus signals
  inout sda;
  inout scl;
  //   interface signals from uP interface
  input txak;              //   value for acknowledge when xmit
  input msta;              //   master/slave select
  output msta_rst;         //   resets MSTA bit if arbitration is lost
  input rsta;              //   repeated start
  input mtx;               //   master read/write
  input [7:0] mbdr_micro;  //   uP data to output on I2C bus
  input [7:0] madr;        //   I2C slave address
  output mbb;              //   bus busy
  inout mcf;               //   data transfer
  inout maas;              //   addressed as slave
  inout mal;               //   arbitration lost
  inout srw;               //   slave read/write
  output mif;              //   interrupt pending
  output rxak;             //   received acknowledge
  inout [7:0] mbdr_i2c;    //   I2C data for uP
  input mbcr_wr;           //   indicates that MCBR register was written
  input mif_bit_reset;     //   indicates that the MIF bit should be reset
  input mal_bit_reset;     //   indicates that the MAL bit should be reset
  input sys_clk;
  input reset;
 
  `define state_type_IDLE	 3'd0
  `define state_type_HEADER	 3'd1
  `define state_type_ACK_HEADER	 3'd2
  `define state_type_RCV_DATA	 3'd3
  `define state_type_ACK_DATA	 3'd4
  `define state_type_XMIT_DATA	 3'd5
  `define state_type_WAIT_ACK	 3'd6
  `define scl_state_type_SCL_IDLE	 3'd0
  `define scl_state_type_START	 3'd1
  `define scl_state_type_SCL_LOW_EDGE	 3'd2
  `define scl_state_type_SCL_LOW	 3'd3
  `define scl_state_type_SCL_HIGH_EDGE	 3'd4
  `define scl_state_type_SCL_HIGH	 3'd5
  `define CNT_100KHZ	 5'b10100
                           //   number of 2MHz clocks in 100KHz
  `define HIGH_CNT	 4'b1000
                           //   number of 2MHz clocks in half
  //   100KHz period -1 since count from 0
  //   and -1 for "edge" state
  `define LOW_CNT	 4'b1000
                           //   number of 2Mhz clocks in half
  //   100KHZ period -1 since count from 0
  //   and -1 for "edge" state
  `define HIGH_CNT_2	 4'b0100
                           //   half of HIGH_CNT
  `define DATA_HOLD	 4'b0001
                           //   number of 2MHz clocks in 300ns
  `define START_HOLD	 4'b0010
 
  `define CLR_REG	 8'b00000000
 
  `define START_CNT	 4'b0000
 
  `define CNT_DONE	 4'b0111
 
  `define ZERO_CNT	 4'b0000
 
  parameter ZERO = 1'b0;
  parameter RESET_ACTIVE = 1'b0;
  //   Used to check slave address detected
  wire addr_match;
  wire arb_lost;           //   1 if arbitration is lost
  //   Bit counter 0 to 7
  wire [3:0] bit_cnt;
  wire bit_cnt_clr;
  wire bit_cnt_en;
  wire bit_cnt_ld;
  //   from state machine
  wire bus_busy;           //   indicates that the bus is busy - set when START, cleared when STOP
  wire bus_busy_d1;        //   delayed sample of bus busy used to determine MAL
  //   Clock Counter
  wire [3:0] clk_cnt;
  wire clk_cnt_en;
  wire clk_cnt_rst;
  wire [3:0] cnt_start;
  wire [3:0] cnt_zero;
  wire detect_start;       //   indicates that a START condition has been detected
  wire detect_stop;        //   indicates that a STOP condition has been detected
  wire gen_start;          //   indicates that the uP wants to generate a START
  wire gen_stop;           //   indicates that the uP wants to generate a STOP
  wire [7:0] i2c_header;   //   shift register that holds I2C header
  wire i2c_header_en;
  wire i2c_header_ld;
  wire i2c_shiftout;
  wire master_sda;         //   sda value when master
  wire master_slave;       //   1 if master, 0 if slave
  wire msta_d1;            //   delayed sample of msta
  wire [2:0] next_scl_state;
  //   the following signals are only here because Viewlogic's VHDL compiler won't allow a constant
  //   to be used in a component instantiation
  wire [7:0] reg_clr;
  wire rep_start;          //   indicates that the uP wants to generate a repeated START
  wire scl_in;             //   sampled version of scl
  wire scl_not;            //   inverted version of SCL
  wire scl_out;            //   combinatorial scl output from scl generator state machine
  wire scl_out_reg;        //   registered version of SCL_OUT
  wire [2:0] scl_state;
  wire sda_in;             //   sampled version of sda
  wire sda_oe;
  wire sda_out;            //   combinatorial sda output from scl generator state machine
  wire sda_out_reg;        //   registered version of SDA_OUT
  wire sda_out_reg_d1;     //   delayed sda output for arbitration comparison
  wire shift_out;
  //   Shift Register and the controls	
  wire [7:0] shift_reg;    //   shift register that holds I2C data				
  wire shift_reg_en;
  wire shift_reg_ld;
  wire slave_sda;          //   sda value when slave
  wire sm_stop;            //   indicates that a STOP condition needs to be generated
  wire [2:0] state;
  wire stop_scl;           //   signal in SCL state machine indicating a STOP
  wire stop_scl_reg;       //   registered version of STOP_SCL
  wire zero_sig;
 
  reg visual_0_msta_rst;
  assign msta_rst = visual_0_msta_rst;
 
  reg visual_0_arb_lost;
  assign arb_lost = visual_0_arb_lost;
 
  reg [2:0] visual_0_next_scl_state;
  assign next_scl_state = visual_0_next_scl_state;
 
  reg visual_0_clk_cnt_rst;
  assign clk_cnt_rst = visual_0_clk_cnt_rst;
 
  reg visual_0_clk_cnt_en;
  assign clk_cnt_en = visual_0_clk_cnt_en;
 
  reg visual_0_stop_scl;
  assign stop_scl = visual_0_stop_scl;
 
  reg visual_0_sda_out;
  assign sda_out = visual_0_sda_out;
 
  reg visual_0_scl_out;
  assign scl_out = visual_0_scl_out;
 
  reg visual_0_stop_scl_reg;
  assign stop_scl_reg = visual_0_stop_scl_reg;
 
  reg visual_0_scl_out_reg;
  assign scl_out_reg = visual_0_scl_out_reg;
 
  reg visual_0_sda_out_reg;
  assign sda_out_reg = visual_0_sda_out_reg;
 
  reg [2:0] visual_0_scl_state;
  assign scl_state = visual_0_scl_state;
 
  reg visual_0_sda_out_reg_d1;
  assign sda_out_reg_d1 = visual_0_sda_out_reg_d1;
 
  reg visual_0_msta_d1;
  assign msta_d1 = visual_0_msta_d1;
 
  reg visual_0_scl_in;
  assign scl_in = visual_0_scl_in;
 
  reg visual_0_sda_in;
  assign sda_in = visual_0_sda_in;
 
  reg visual_0_master_slave;
  assign master_slave = visual_0_master_slave;
 
  reg visual_0_gen_stop;
  assign gen_stop = visual_0_gen_stop;
 
  reg visual_0_gen_start;
  assign gen_start = visual_0_gen_start;
 
  reg visual_0_sm_stop;
  assign sm_stop = visual_0_sm_stop;
 
  reg [2:0] visual_0_state;
  assign state = visual_0_state;
 
  reg visual_0_detect_start;
  assign detect_start = visual_0_detect_start;
 
  reg visual_0_rxak;
  assign rxak = visual_0_rxak;
 
  reg visual_0_detect_stop;
  assign detect_stop = visual_0_detect_stop;
 
  reg visual_0_i2c_header_en;
  assign i2c_header_en = visual_0_i2c_header_en;
 
  reg visual_0_bus_busy_d1;
  assign bus_busy_d1 = visual_0_bus_busy_d1;
 
  reg visual_0_bus_busy;
  assign bus_busy = visual_0_bus_busy;
 
  reg visual_0_mal;
  assign mal = visual_0_mal;
 
  reg visual_0_maas;
  assign maas = visual_0_maas;
 
  reg visual_0_mcf;
  assign mcf = visual_0_mcf;
 
  reg visual_0_srw;
  assign srw = visual_0_srw;
 
  reg visual_0_shift_reg_ld;
  assign shift_reg_ld = visual_0_shift_reg_ld;
 
  reg visual_0_shift_reg_en;
  assign shift_reg_en = visual_0_shift_reg_en;
 
  reg visual_0_mif;
  assign mif = visual_0_mif;
 
  reg visual_0_slave_sda;
  assign slave_sda = visual_0_slave_sda;
 
  reg visual_0_master_sda;
  assign master_sda = visual_0_master_sda;
 
  reg [7:0] visual_0_mbdr_i2c;
  assign mbdr_i2c = visual_0_mbdr_i2c;
 
 
  //   ************************  Bit Counter  ************************
  upcnt4  BITCNT
    (
     .data(cnt_start[3:0]),
     .cnt_en(bit_cnt_en),
     .load(bit_cnt_ld),
     .clr(reset),
     .clk(scl_not),
     .qout(bit_cnt[3:0]));
 
  //   ************************  Clock Counter Implementation ************************
  //   The following code implements the counter that divides the sys_clock for
  //   creation of SCL. Control lines for this counter are set in SCL state machine
  upcnt4  CLKCNT
    (
     .data(cnt_zero[3:0]),
     .cnt_en(clk_cnt_en),
     .load(clk_cnt_rst),
     .clr(reset),
     .clk(sys_clk),
     .qout(clk_cnt[3:0]));
 
  //   ************************  I2C Header Shift Register ************************
  //   Header/Address Shift Register
  SHIFT8  I2CHEADER_REG
    (
     .clk(scl_not),
     .clr(reset),
     .data_ld(i2c_header_ld),
     .data_in(reg_clr[7:0]),
     .shift_in(sda_in),
     .shift_en(i2c_header_en),
     .shift_out(i2c_shiftout),
     .data_out({i2c_header[3:0],reg_clr[3:0]}));
//     .data_out(i2c_header[7:0]));
 
  //   ************************  I2C Data Shift Register ************************
  SHIFT8  I2CDATA_REG
    (
     .clk(scl_not),
     .clr(reset),
     .data_ld(shift_reg_ld),
     .data_in(mbdr_micro[7:0]),
     .shift_in(sda_in),
     .shift_en(shift_reg_en),
     .shift_out(shift_out),
     .data_out(shift_reg[7:0]));
 
  //   ************************  Arbitration Process ************************
  //   This process checks the master's outgoing SDA with the incoming SDA to determine
  //   if control of the bus has been lost. SDA is checked only when SCL is high
  //   and during the states IDLE, HEADER, and XMIT_DATA to insure that START and STOP
  //   conditions are not set when the bus is busy. Note that this is only done when Master.
  //   When arbitration is lost, a reset is generated for the MSTA bit
  //   Note that when arbitration is lost, the mode is switched to slave and SCL continues
  //   to be generated until the byte transfer is complete
  //   arb_lost stays set until scl state machine goes to IDLE state
  always @( posedge (sys_clk) or negedge (reset) )
  begin
    if (!reset)
    begin
      visual_0_arb_lost <= 1'b0;
      visual_0_msta_rst <= 1'b0;
    end
    else
    begin
      if (scl_state == `scl_state_type_SCL_IDLE)
      begin
        visual_0_arb_lost <= 1'b0;
        visual_0_msta_rst <= 1'b0;
      end
      else if ((master_slave))
        //   only need to check arbitration in master mode
        //   check for SCL high before comparing data and insure that arb_lost is
        //   not already set
        if ((scl_in && scl && !arb_lost && (state == `state_type_HEADER || state
            == `state_type_XMIT_DATA || state == `state_type_IDLE)))
          //   when master, will check bus in all states except ACK_HEADER and WAIT_ACK
          //   this will insure that arb_lost is set if a start or stop condition
          //   is set at the wrong time
          if (sda_out_reg_d1 == sda_in)
          begin
            visual_0_arb_lost <= 1'b0;
            visual_0_msta_rst <= 1'b0;
          end
          else
          begin
            visual_0_arb_lost <= 1'b1;
            visual_0_msta_rst <= 1'b1;
          end
 
        else
        begin
          visual_0_arb_lost <= arb_lost;
          visual_0_msta_rst <= 1'b0;
        end
 
 
    end
 
  end
 
 
  //   ************************  SCL_Generator Process ************************
  //   This process generates SCL and SDA when in Master mode. It generates the START
  //   and STOP conditions. If arbitration is lost, SCL will be generated until the
  //   end of the byte transfer.
  always @(scl_state or arb_lost or sm_stop or gen_stop or rep_start or bus_busy or
    gen_start or master_slave or stop_scl_reg or clk_cnt or bit_cnt or scl_in or
    state or sda_out or sda_out_reg or stop_scl_reg or master_sda)
  begin
    //   state machine defaults
    visual_0_scl_out <= 1'b1;
    visual_0_sda_out <= sda_out_reg;
    visual_0_stop_scl <= stop_scl_reg;
    visual_0_clk_cnt_en <= 1'b0;
    visual_0_clk_cnt_rst <= 1'b1;
    visual_0_next_scl_state <= scl_state;
    case (scl_state)
      `scl_state_type_SCL_IDLE :
      begin
        visual_0_sda_out <= 1'b1;
        visual_0_stop_scl <= 1'b0;
        //   leave IDLE state when master, bus is idle, and gen_start
        if (master_slave && !bus_busy && gen_start)
          visual_0_next_scl_state <= `scl_state_type_START;
 
      end
      `scl_state_type_START :
      begin
        //   generate start condition
        visual_0_clk_cnt_en <= 1'b1;
        visual_0_clk_cnt_rst <= 1'b0;
        visual_0_sda_out <= 1'b0;
        visual_0_stop_scl <= 1'b0;
        if (clk_cnt == `START_HOLD)
          visual_0_next_scl_state <= `scl_state_type_SCL_LOW_EDGE;
        else
          visual_0_next_scl_state <= `scl_state_type_START;
 
      end
      `scl_state_type_SCL_LOW_EDGE :
      begin
        visual_0_clk_cnt_rst <= 1'b1;
        visual_0_scl_out <= 1'b0;
        visual_0_next_scl_state <= `scl_state_type_SCL_LOW;
        visual_0_stop_scl <= 1'b0;
      end
      `scl_state_type_SCL_LOW :
      begin
        visual_0_clk_cnt_en <= 1'b1;
        visual_0_clk_cnt_rst <= 1'b0;
        visual_0_scl_out <= 1'b0;
        //   set SDA_OUT based on control signals
        if (arb_lost)
          visual_0_stop_scl <= 1'b0;
        else if (((sm_stop || gen_stop) && (state != `state_type_ACK_DATA &&
                 state != `state_type_ACK_HEADER && state !=
                 `state_type_WAIT_ACK)))
        begin
          visual_0_sda_out <= 1'b0;
          visual_0_stop_scl <= 1'b1;
        end
        else if (rep_start)
        begin
          visual_0_sda_out <= 1'b1;
          visual_0_stop_scl <= 1'b0;
        end
        else if (clk_cnt == `DATA_HOLD)
        begin
          visual_0_sda_out <= master_sda;
          visual_0_stop_scl <= 1'b0;
        end
        else
          visual_0_stop_scl <= 1'b0;
 
        //   determine next state
        if (clk_cnt == `LOW_CNT)
          if (bit_cnt == `CNT_DONE && arb_lost)
            visual_0_next_scl_state <= `scl_state_type_SCL_IDLE;
          else
            visual_0_next_scl_state <= `scl_state_type_SCL_HIGH_EDGE;
 
        else
          visual_0_next_scl_state <= `scl_state_type_SCL_LOW;
 
      end
      `scl_state_type_SCL_HIGH_EDGE :
      begin
        visual_0_clk_cnt_rst <= 1'b1;
        visual_0_scl_out <= 1'b1;
        if (((sm_stop || gen_stop) && (state != `state_type_ACK_DATA && state !=
            `state_type_ACK_HEADER && state != `state_type_WAIT_ACK)))
          visual_0_stop_scl <= 1'b1;
        else
          visual_0_stop_scl <= 1'b0;
 
        //   this state sets SCL high
        //   stay in this state until SCL_IN = 1
        //   this will hold the counter in reset until all SCL drivers
        //   have released SCL to 1
        if (!scl_in)
          visual_0_next_scl_state <= `scl_state_type_SCL_HIGH_EDGE;
        else
          visual_0_next_scl_state <= `scl_state_type_SCL_HIGH;
 
      end
      `scl_state_type_SCL_HIGH :
      begin
        //   now all SCL drivers have set SCL to '1'
        //   begin count for high time
        visual_0_clk_cnt_en <= 1'b1;
        visual_0_clk_cnt_rst <= 1'b0;
        visual_0_scl_out <= 1'b1;
        //   check to see if a repeated start or a stop needs to be
        //   generated. If so, only hold SCL high for half of the high time
        if (clk_cnt == `HIGH_CNT_2)
        begin
        begin
          if (rep_start)
            visual_0_next_scl_state <= `scl_state_type_START;
          else if (stop_scl_reg)
            visual_0_next_scl_state <= `scl_state_type_SCL_IDLE;
 
        end
        end
        else if (clk_cnt == `HIGH_CNT)
          visual_0_next_scl_state <= `scl_state_type_SCL_LOW_EDGE;
        else
          visual_0_next_scl_state <= `scl_state_type_SCL_HIGH;
 
      end
    endcase
 
  end
 
 
  always @( posedge (sys_clk) or negedge (reset) )
  begin
    if (!reset)
    begin
      visual_0_scl_state <= `scl_state_type_SCL_IDLE;
      visual_0_sda_out_reg <= 1'b1;
      visual_0_scl_out_reg <= 1'b1;
      visual_0_stop_scl_reg <= 1'b0;
    end
    else
    begin
      visual_0_scl_state <= next_scl_state;
      visual_0_sda_out_reg <= sda_out;
      visual_0_scl_out_reg <= scl_out;
      visual_0_stop_scl_reg <= stop_scl;
    end
 
  end
 
 
  //   ************************  Input Registers Process ************************
  //   This process samples the incoming SDA and SCL with the system clock
  always @( posedge (sys_clk) or negedge (reset) )
  begin
    if (!reset)
    begin
      visual_0_sda_in <= 1'b1;
      visual_0_scl_in <= 1'b1;
      visual_0_msta_d1 <= 1'b0;
      visual_0_sda_out_reg_d1 <= 1'b1;
    end
    else
    begin
      //   the following if, then, else clauses are used
      //   because scl may equal 'H' or '1'
      if (!scl)
        visual_0_scl_in <= 1'b0;
      else
        visual_0_scl_in <= 1'b1;
 
      if (!sda)
        visual_0_sda_in <= 1'b0;
      else
        visual_0_sda_in <= 1'b1;
 
      visual_0_sda_out_reg_d1 <= sda_out_reg;
      visual_0_msta_d1 <= msta;
    end
 
  end
 
 
  //   ************************   uP Control Bits Process ************************
  //   This process detects the rising and falling edges of MSTA and sets signals to
  //   control generation of start and stop conditions
  //   This process also sets the master slave bit based on MSTA if and only if it is not
  //   in the middle of a cycle, i.e. bus_busy = '0'
  always @( posedge (sys_clk) or negedge (reset) )
  begin
    if (!reset)
    begin
      visual_0_gen_start <= 1'b0;
      visual_0_gen_stop <= 1'b0;
      visual_0_master_slave <= 1'b0;
    end
    else
    begin
      if (!msta_d1 && msta)
        //   rising edge of MSTA - generate start condition
        visual_0_gen_start <= 1'b1;
      else if (detect_start)
        visual_0_gen_start <= 1'b0;
 
      if (!arb_lost && msta_d1 && !msta)
        //   falling edge of MSTA - generate stop condition only
        //   if arbitration has not been lost
        visual_0_gen_stop <= 1'b1;
      else if (detect_stop)
        visual_0_gen_stop <= 1'b0;
 
      if (!bus_busy)
        visual_0_master_slave <= msta;
      else
        visual_0_master_slave <= master_slave;
 
    end
 
  end
 
 
  //   ************************  Main State Machine Process ************************
  //   The following process contains the main I2C state machine for both master and slave
  //   modes. This state machine is clocked on the falling edge of SCL. DETECT_STOP must stay as
  //   an asynchronous reset because once STOP has been generated, SCL clock stops.
  always @( negedge (scl) or negedge (reset))
  begin
    if (!reset)
    begin
      visual_0_state <= `state_type_IDLE;
      visual_0_sm_stop <= 1'b0;
    end
    else
      case (state)
        `state_type_IDLE :
          //  ----------- IDLE STATE -------------
          if (detect_start)
            visual_0_state <= `state_type_HEADER;
          else if (detect_stop)
          begin
            visual_0_state <= `state_type_IDLE;
            visual_0_sm_stop <= 1'b0;
          end
 
        `state_type_HEADER :
          //  ----------- HEADER STATE -------------
          if (bit_cnt == `CNT_DONE)
            visual_0_state <= `state_type_ACK_HEADER;
          else if (detect_stop)
          begin
            visual_0_state <= `state_type_IDLE;
            visual_0_sm_stop <= 1'b0;
          end
 
        `state_type_ACK_HEADER :
          //  ----------- ACK_HEADER STATE -------------
          if (arb_lost)
            visual_0_state <= `state_type_IDLE;
          else if (detect_stop)
          begin
            visual_0_state <= `state_type_IDLE;
            visual_0_sm_stop <= 1'b0;
          end
          else if (!sda_in)
            //   ack has been received, check for master/slave
            if (master_slave)
              //   master, so check mtx bit for direction
              if (!mtx)
                //   receive mode
                visual_0_state <= `state_type_RCV_DATA;
              else
                //  transmit mode
                visual_0_state <= `state_type_XMIT_DATA;
 
            else
              if (addr_match)
                //  if maas = '1' then
                //   addressed slave, so check I2C_HEADER(0) for direction
                if (!i2c_header[0])
                  //   receive mode
                  visual_0_state <= `state_type_RCV_DATA;
                else
                  //   transmit mode
                  visual_0_state <= `state_type_XMIT_DATA;
 
              else
                //   not addressed, go back to IDLE
                visual_0_state <= `state_type_IDLE;
 
 
          else
          begin
            //   no ack received, stop
            visual_0_state <= `state_type_IDLE;
            if (master_slave)
              visual_0_sm_stop <= 1'b1;
 
          end
 
        `state_type_RCV_DATA :
          //  ----------- RCV_DATA State --------------
          //   If stop signal detected
          //  if (detect_stop = '1') then
          //  state <= IDLE;
          //   Continue transmitting
          if (bit_cnt == `CNT_DONE)
            //   Send an acknowledge
            visual_0_state <= `state_type_ACK_DATA;
          else if (detect_stop)
          begin
            visual_0_state <= `state_type_IDLE;
            visual_0_sm_stop <= 1'b0;
          end
 
        `state_type_XMIT_DATA :
          //  ---------- XMIT_DATA State --------------
          //   If stop signal detected
          //  if (detect_stop = '1') then
          //     state <= IDLE;
          if (bit_cnt == `CNT_DONE)
            //   Wait for acknowledge
            visual_0_state <= `state_type_WAIT_ACK;
          else if (detect_stop)
          begin
            visual_0_state <= `state_type_IDLE;
            visual_0_sm_stop <= 1'b0;
          end
 
        `state_type_ACK_DATA :
        begin
          //  ----------- ACK_DATA State --------------
          visual_0_state <= `state_type_RCV_DATA;
          if (detect_stop)
          begin
            visual_0_state <= `state_type_IDLE;
            visual_0_sm_stop <= 1'b0;
          end
 
        end
        `state_type_WAIT_ACK :
          //  ----------- WAIT_ACK State --------------
          if (arb_lost)
            visual_0_state <= `state_type_IDLE;
          else if (detect_stop)
          begin
            visual_0_state <= `state_type_IDLE;
            visual_0_sm_stop <= 1'b0;
          end
          else if ((!sda))
            visual_0_state <= `state_type_XMIT_DATA;
          else
          begin
            //   no ack received, generate a stop and return
            //   to IDLE state
            if (master_slave)
              visual_0_sm_stop <= 1'b1;
 
            visual_0_state <= `state_type_IDLE;
          end
 
      endcase
 
 
  end
 
 
  //   ************************  START/STOP Detect Process ************************
  //   This process detects the start and stop conditions.
  //   by using SDA as a clock.
  always @( negedge (sda) or negedge (reset))
  begin
    if (!reset)
      visual_0_detect_start <= 1'b0;
    else
      if (scl)
        visual_0_detect_start <= 1'b1;
      else if (state == `state_type_HEADER)
        visual_0_detect_start <= 1'b0;
      else
        visual_0_detect_start <= 1'b0;
 
 
  end
 
 
  //   RXAK - Received Acknowledge
  //   RXAK contains the value of SDA during the acknowledge bit of a bus cycle. If =0, then
  //   an acknowledge signal has been received, if 1, then no acknowledge has been received.
  //   This bit is not cleared at reset. The CPLD will reset this bit upon power-up
  always @( negedge (scl) )
  begin
 
    begin
    begin
      if (state == `state_type_ACK_HEADER || state == `state_type_ACK_DATA ||
          state == `state_type_WAIT_ACK)
        visual_0_rxak <= sda_in;
 
    end
    end
 
  end
 
 
  always @( posedge (sda) or negedge (reset))
  begin
    if (!reset)
      visual_0_detect_stop <= 1'b0;
    else
      if (scl)
        visual_0_detect_stop <= 1'b1;
      else if (detect_start)
        visual_0_detect_stop <= 1'b0;
      else
        visual_0_detect_stop <= 1'b0;
 
 
  end
 
 
  always @( posedge (sys_clk) or negedge (reset) )
  begin
    if (!reset)
      visual_0_i2c_header_en <= 1'b0;
    else
      if ((detect_start) || (state == `state_type_HEADER))
        visual_0_i2c_header_en <= 1'b1;
      else
        visual_0_i2c_header_en <= 1'b0;
 
 
  end
 
 
  //   ************************  Bus Busy Process ************************
  //   This process detects the start and stop conditions and sets the bus busy bit
  //   It also describes a delayed version of the bus busy bit which is used to determine
  //   MAL. MAL should be set if a start is detected while the bus is busy, however, the code below
  //   sets bus_busy as soon as START is detected which would always set MAL. Therefore, a delayed
  //   version of bus_busy is generated and used to determine MAL.
  always @( posedge (sys_clk) or negedge (reset) )
  begin
    if (!reset)
    begin
      visual_0_bus_busy <= 1'b0;
      visual_0_bus_busy_d1 <= 1'b0;
    end
    else
    begin
      visual_0_bus_busy_d1 <= bus_busy;
      if (detect_start)
        visual_0_bus_busy <= 1'b1;
 
      if (detect_stop)
        visual_0_bus_busy <= 1'b0;
 
    end
 
  end
 
 
  //   set SDA and SCL
  assign sda = (sda_oe == 1'b1 ? 1'b0 : 1'bz);
  assign scl = (scl_out_reg == 1'b0 ? 1'b0 : 1'bz);
  assign scl_not =  (~ (scl)) ;
  //   sda_oe is set when master and arbitration is not lost and data to be output = 0 or
  //   when slave and data to be output is 0
  assign sda_oe = (((master_slave == 1'b1 && arb_lost == 1'b0 && sda_out_reg ==
                  1'b0) || (master_slave == 1'b0 && slave_sda == 1'b0) ||
                  stop_scl_reg == 1'b1) ? 1'b1 : 1'b0);
  //   the following signals are only here because Viewlogic's VHDL compiler won't allow a constant
  //   to be used in a component instantiation
  assign reg_clr = `CLR_REG;
  assign zero_sig = ZERO;
  assign cnt_zero = `ZERO_CNT;
  assign cnt_start = `START_CNT;
  assign rep_start = rsta; //   repeat start signal is RSTA control bit
  //   MBB - Bus Busy Bit
  //   This bit indicates the status of the bus. This bit is set when a START signal is detected and
  //   cleared when a stop signal is detected. It is also cleared on reset. This bit is identical to
  //   the signal bus_busy set in the process set_bus_busy.
  assign mbb = bus_busy;
  //   ************************  uP Address Register ************************
  assign addr_match = (i2c_header[7:1] == madr[7:1] ? 1'b1 : 1'b0);
  assign i2c_header_ld = 1'b0;
  //   Counter control lines
  assign bit_cnt_en = ((state == `state_type_HEADER) || (state ==
                      `state_type_RCV_DATA) || (state == `state_type_XMIT_DATA)
                       ? 1'b1 : 1'b0);
  assign bit_cnt_ld = ((state == `state_type_IDLE) || (state ==
                      `state_type_ACK_HEADER) || (state == `state_type_ACK_DATA)
                      || (state == `state_type_WAIT_ACK) ? 1'b1 : 1'b0);
 
  //   MAL - Arbitration Lost Bit
  //   This bit is set when the arbitration procedure is lost. Arbitration is lost when:
  //  	1. SDA is sampled low when the master drives high during addr or data transmit cycle
  //  	2. SDA is sampled low when the master drives high during the acknowledge bit of a
  //  		data receive cycle
  //  	3. A start cycle is attempted when the bus is busy
  //  	4. A repeated start is requested in slave mode
  //  	5. A stop condition is detected that the master did not request it.
  //   This bit is cleared upon reset and when the software writes a '0' to it
  //   Conditions 1 & 2 above simply result in SDA_IN not matching SDA_OUT while SCL is high. This
  //   design will not generate a START condition while the bus is busy. When a START is detected, this hardware
  //   will set the bus busy bit and gen_start stays set until detect_start asserts, therefore will have
  //   to compare with a delayed version of bus_busy. Condition 3 is really just
  //   a check on the uP software control registers as is condition 4. Condition 5 is also taken care
  //   of by the fact that SDA_IN does not equal SDA_OUT, however, this process also tests for if a stop
  //   condition has been detected when this master did not generate it
  always @( posedge (sys_clk) or negedge (reset) )
  begin
    if (!reset)
      visual_0_mal <= 1'b0;
    else
    begin
      if (mal_bit_reset)
        visual_0_mal <= 1'b0;
      else if (master_slave)
      begin
        if ((arb_lost) || (bus_busy_d1 && gen_start) || (detect_stop && !
            gen_stop && !sm_stop))
          visual_0_mal <= 1'b1;
 
      end
      else if (rsta)
        //   repeated start requested while slave
        visual_0_mal <= 1'b1;
 
    end
 
  end
 
 
  //   MAAS - Addressed As Slave Bit
  //   When its own specific address (MADR) matches the I2C Address, this bit is set. The CPU is
  //   interrupted provided the MIEN is set. Then the CPU needs to check the SRW bit and set its
  //   TX-RX mode accordingly. Writing to the MBCR clears this bit
  always @( posedge (sys_clk) or negedge (reset) )
  begin
    if (!reset)
      visual_0_maas <= 1'b0;
    else
      if (mbcr_wr)
        visual_0_maas <= 1'b0;
      else if (state == `state_type_ACK_HEADER)
        visual_0_maas <= addr_match;  //   the signal address match compares MADR with I2_ADDR
      else
        visual_0_maas <= maas;
 
 
  end
 
 
  //   ************************  uP Status Register Bits Processes ************************
  //   The following processes and assignments set the bits of the MBUS status register MBSR
  //
  //   MCF - Data transferring bit
  //   While one byte of data is being transferred, this bit is cleared. It is set by the falling edge
  //   of the 9th clock of a byte transfer and is not cleared at reset
  always @( negedge (scl) or negedge (reset) )
  begin
    if (!reset)
      visual_0_mcf <= 1'b0;
    else
      if (bit_cnt == `CNT_DONE)
        visual_0_mcf <= 1'b1;
      else
        visual_0_mcf <= 1'b0;
 
 
  end
 
 
  //   SRW - Slave Read/Write Bit
  //   When MAAS is set, SRW indicates the value of the R/W command bit of the calling address sent
  //   from the master. This bit is only valid when a complete transfer has occurred and no other
  //   transfers have been initiated. The CPU uses this bit to set the slave transmit/receive mode.
  //   This bit is reset by reset
  always @( posedge (sys_clk) or negedge (reset) )
  begin
    if (!reset)
      visual_0_srw <= 1'b0;
    else
      if (state == `state_type_ACK_HEADER)
        visual_0_srw <= i2c_header[0];
      else
        visual_0_srw <= srw;
 
 
  end
 
 
  always @( posedge (sys_clk) or negedge (reset) )
  begin
    if (!reset)
    begin
      visual_0_shift_reg_en <= 1'b0;
      visual_0_shift_reg_ld <= 1'b0;
    end
    else
    begin
      if (((master_slave && state == `state_type_HEADER) || (state ==
          `state_type_RCV_DATA) || (state == `state_type_XMIT_DATA)))
        visual_0_shift_reg_en <= 1'b1;
      else
        visual_0_shift_reg_en <= 1'b0;
 
      if (((master_slave && state == `state_type_IDLE) || (state ==
          `state_type_WAIT_ACK) || (state == `state_type_ACK_HEADER &&
          i2c_header[0] && !master_slave) || (state == `state_type_ACK_HEADER &&
          mtx && master_slave)))
        visual_0_shift_reg_ld <= 1'b1;
      else
        visual_0_shift_reg_ld <= 1'b0;
 
    end
 
  end
 
 
  //   MIF - M-bus Interrupt
  //   The MIF bit is set when an interrupt is pending, which causes a processor interrupt
  //   request provided MIEN is set. MIF is set when:
  //  	1. Byte transfer is complete (set at the falling edge of the 9th clock
  //  	2. MAAS is set when in slave receive mode
  //  	3. Arbitration is lost
  //   This bit is cleared by reset and software writting a '0'to it
  always @( posedge (sys_clk) or negedge (reset) )
  begin
    if (!reset)
      visual_0_mif <= 1'b0;
    else
    begin
      if (mif_bit_reset)
        visual_0_mif <= 1'b0;
      else if (mal || mcf || (maas && !i2c_header[0] && !master_slave))
        visual_0_mif <= 1'b1;
 
    end
 
  end
 
 
  //   ************************  Slave and Master SDA ************************
  always @( negedge (reset) or posedge (sys_clk) )
  begin
    if (!reset)
    begin
      visual_0_master_sda <= 1'b1;
      visual_0_slave_sda <= 1'b1;
    end
    else
    begin
      if (state == `state_type_HEADER || state == `state_type_XMIT_DATA)
        visual_0_master_sda <= shift_out;
      else if (state == `state_type_ACK_DATA)
        visual_0_master_sda <= txak;
      else
        visual_0_master_sda <= 1'b1;
 
      //   For the slave SDA, address match (MAAS) only has to be checked when
      //   state is ACK_HEADER because state
      //   machine will never get to state XMIT_DATA or ACK_DATA
      //   unless address match is a one.
      if ((maas && state == `state_type_ACK_HEADER) || (state ==
          `state_type_ACK_DATA))
        visual_0_slave_sda <= txak;
      else if ((state == `state_type_XMIT_DATA))
        visual_0_slave_sda <= shift_out;
      else
        visual_0_slave_sda <= 1'b1;
 
    end
 
  end
 
 
  //   ************************  uP Data Register ************************
  //   Register for uP interface MBDR_I2C
  always @( posedge (sys_clk) or negedge (reset) )
  begin
    if (!reset)
      visual_0_mbdr_i2c <= {{8{ 1'b0 }}};
    else
      if ((state == `state_type_ACK_DATA) || (state == `state_type_WAIT_ACK))
        visual_0_mbdr_i2c <= shift_reg;
      else
        visual_0_mbdr_i2c <= mbdr_i2c;
 
 
  end
 
 
endmodule


