//--------------------------------------------------
//  
//      Verilog code generated by Visual HDL
//
//  Design Unit:
//  ------------
//      Unit    Name  :  uC_interface_blk
//      Library Name  :  i2c_work
//  
//      Creation Date :  Mon Mar 12 10:42:23 2001
//      Version       :  6.7.0 build 17 from Oct  2 2000
//  
//  Options Used:
//  -------------
//      Target
//         HDL        :  Verilog
//         Purpose    :  Synthesis
//         Vendor     :  Design Compiler
//  
//      Style
//         Use Procedures                 :  No
//         Code Destination               :  Combined file
//         Attach Directives              :  Yes
//         Structural                     :  No
//         Preserve spacing for free text :  Yes
//         Sort Ports by mode             :  No
//         Declaration alignment          :  No
//
//--------------------------------------------------
//--------------------------------------------------
//  
//  Library Name :  i2c_work
//  Unit    Name :  uC_interface_blk
//  Unit    Type :  Block Diagram
//  
//----------------------------------------------------
// Revised:  2-22-02 JRH
 
module uC_interface (clk, reset, addr_bus, data_bus, as, ds, r_w, dtack, irq
                         , madr, men, mien, msta, mtx, txak, rsta, mbcr_wr, mcf,
                         maas, mbb, mal, srw, mif, rxak, mal_bit_reset,
                         mif_bit_reset, msta_rst, mbdr_micro, mbdr_i2c,
                         mbdr_read);
 
  parameter UC_ADDRESS = 16'b0000000000000000;
  //   68000 parallel bus interface
  input clk;
  input reset;
  input [23:0] addr_bus;
  inout [7:0] data_bus;
  input as;                //   Address strobe, active low	
  input ds;                //   Data strobe, active low
  //   Directional pins
  input r_w;               //   Active low write,
  //    active high read
  output dtack;            //   Data transfer acknowledge
  output irq;              //   Interrupt request
  //   Internal I2C Bus Registers
  //   Address Register (Contains slave address)
  inout [7:0] madr;
  //   Control Register		
  inout men;               //   I2C Enable bit
  inout mien;              //   interrupt enable
  inout msta;              //   Master/Slave bit
  inout mtx;               //   Master read/write
  inout txak;              //   acknowledge bit
  inout rsta;              //   repeated start
  output mbcr_wr;          //   indicates that the control reg has been written
  //   Status Register
  input mcf;               //   end of data transfer
  input maas;              //   addressed as slave
  input mbb;               //   bus busy
  input mal;               //   arbitration lost
  input srw;               //   slave read/write
  input mif;               //   interrupt pending
  input rxak;              //   received acknowledge
  output mal_bit_reset;    //   indicates that the MAL bit should be reset
  output mif_bit_reset;    //   indicates that the MIF bit should be reset
  input msta_rst;          //   resets the MSTA bit if arbitration is lost
  //   Data Register
  inout [7:0] mbdr_micro;
  input [7:0] mbdr_i2c;
  output mbdr_read;
 
  //   State Machine Signals
  `define STATE_TYPE_IDLE	 2'd0
  `define STATE_TYPE_ADDR	 2'd1
  `define STATE_TYPE_DATA_TRS	 2'd2
  `define STATE_TYPE_ASSERT_DTACK	 2'd3
  //   Constant Declarations
  parameter RESET_ACTIVE = 1'b0;
  //   Base Address for I2C Module (addr_bus[23:8])
  parameter MBASE = UC_ADDRESS;
  //   Register Addresses (5 Total):
  //   Address Register (MBASE + 8Dh)
  `define MADR_ADDR	 8'b10001101
 
  //   Control Register (MBASE + 91h)
  `define MBCR_ADDR	 8'b10010001
 
  //   Status Register (MBASE + 93h)
  `define MBSR_ADDR	 8'b10010011
 
  //   Data I/O Register (MBASE + 95h)
  `define MBDR_ADDR	 8'b10010101
 
  //   Register Enable Lines
  wire addr_en;            //   i2c address register is selected
  wire addr_ready;
  //   Address match
  wire address_match;
  //   Signal Declarations
  //   Internal handshaking lines for microprocessor
  wire as_int;
  wire as_int_d1;
  wire cntrl_en;           //   control register is selected
  wire data_en;            //   data register is selected			
  wire [7:0] data_in;      //   holds the data to be input to the chip
  wire [7:0] data_out;     //   holds the data to be output on the data bus
  wire ds_int;
  wire dtack_com;
  wire dtack_int;
  wire dtack_oe;
  wire [1:0] next_state;
  //   State signals for target state machine
  wire [1:0] prs_state;
  wire stat_en;            //   status register is selected
 
  reg visual_0_address_match;
  assign address_match = visual_0_address_match;
 
  reg visual_0_ds_int;
  assign ds_int = visual_0_ds_int;
 
  reg visual_0_as_int;
  assign as_int = visual_0_as_int;
 
  reg visual_0_as_int_d1;
  assign as_int_d1 = visual_0_as_int_d1;
 
  reg visual_0_dtack_oe;
  assign dtack_oe = visual_0_dtack_oe;
 
  reg visual_0_dtack_com;
  assign dtack_com = visual_0_dtack_com;
 
  reg [1:0] visual_0_next_state;
  assign next_state = visual_0_next_state;
 
  reg visual_0_dtack_int;
  assign dtack_int = visual_0_dtack_int;
 
  reg [1:0] visual_0_prs_state;
  assign prs_state = visual_0_prs_state;
 
  reg visual_0_data_en;
  assign data_en = visual_0_data_en;
 
  reg visual_0_stat_en;
  assign stat_en = visual_0_stat_en;
 
  reg visual_0_cntrl_en;
  assign cntrl_en = visual_0_cntrl_en;
 
  reg visual_0_addr_en;
  assign addr_en = visual_0_addr_en;
 
  reg [7:0] visual_0_data_out;
  assign data_out = visual_0_data_out;
 
  reg visual_0_mbdr_read;
  assign mbdr_read = visual_0_mbdr_read;
 
  reg [7:0] visual_0_mbdr_micro;
  assign mbdr_micro = visual_0_mbdr_micro;
 
  reg visual_0_mif_bit_reset;
  assign mif_bit_reset = visual_0_mif_bit_reset;
 
  reg visual_0_mal_bit_reset;
  assign mal_bit_reset = visual_0_mal_bit_reset;
 
  reg visual_0_mbcr_wr;
  assign mbcr_wr = visual_0_mbcr_wr;
 
  reg visual_0_rsta;
  assign rsta = visual_0_rsta;
 
  reg visual_0_txak;
  assign txak = visual_0_txak;
 
  reg visual_0_mtx;
  assign mtx = visual_0_mtx;
 
  reg visual_0_msta;
  assign msta = visual_0_msta;
 
  reg visual_0_mien;
  assign mien = visual_0_mien;
 
  reg visual_0_men;
  assign men = visual_0_men;
 
  reg [7:0] visual_0_madr;
  assign madr = visual_0_madr;
 
 
  //   Process:   SYNCH_INPUTS
  //   Function:  To synchronize uProcessor asynchronous control lines to
  //  	      internal clock
  always @( negedge (reset) or posedge (clk) )
  begin
    if (!reset)
    begin
      visual_0_as_int <= 1'b1;
      visual_0_as_int_d1 <= 1'b1;
      visual_0_ds_int <= 1'b1;
      visual_0_address_match <= 1'b0;
    end
    else
    begin
      visual_0_as_int <= as;
      visual_0_as_int_d1 <= as_int;
      visual_0_ds_int <= ds;
      if ((!as && as_int_d1 && addr_bus[23:8] == MBASE))
        visual_0_address_match <= 1'b1;
      else
        visual_0_address_match <= 1'b0;
 
    end
 
  end
 
 
  //   Process:   COMBINATIONAL
  //   Function:  Contains the synchronous target state machine to mediate
  //  	      the handshaking taking place with the uProc parallel bus
  always @(prs_state or as or as_int_d1 or ds_int or address_match)
  begin
    visual_0_next_state <= prs_state;
    visual_0_dtack_com <= 1'b1;
    visual_0_dtack_oe <= 1'b0;
    case (prs_state)
      `STATE_TYPE_IDLE :
        //  ----------- IDLE State (00) -------------
        //   Wait for falling edge of as
        if (as_int_d1 && !as)
          //   falling edge of AS
          visual_0_next_state <= `STATE_TYPE_ADDR;
 
      `STATE_TYPE_ADDR :
        //  ---------- ADDR State (01) --------------
        //   Check that this module is being address
        if (address_match)
          //   Wait for ds to be asserted, active low
          if (!ds_int)
            visual_0_next_state <= `STATE_TYPE_DATA_TRS;
          else
            visual_0_next_state <= `STATE_TYPE_ADDR;
 
        else
          //   this module is not being addressed
          visual_0_next_state <= `STATE_TYPE_IDLE;
 
      `STATE_TYPE_DATA_TRS :
      begin
        //  -------- DATA_TRS State (10) ------------
        //   Read or write from enabled register
        visual_0_next_state <= `STATE_TYPE_ASSERT_DTACK;
        visual_0_dtack_oe <= 1'b1;
      end
      `STATE_TYPE_ASSERT_DTACK :
      begin
        //  ------ ASSERT_DTACK State (11) ----------
        //   Assert dtack to uProcessor
        visual_0_dtack_com <= 1'b0;
        visual_0_dtack_oe <= 1'b1;
        //   Wait for rising edge of as and ds
        if ((!as_int_d1) && (!ds_int))
          visual_0_next_state <= `STATE_TYPE_ASSERT_DTACK;
        else if ((as_int_d1) && (ds_int))
          visual_0_next_state <= `STATE_TYPE_IDLE;
 
      end
    endcase
 
  end
 
 
  //   Process:  SEQUENTIAL
  //   Function: Synchronize target state machine
  always @( posedge (clk) or negedge (reset) )
  begin
    if (!reset)
    begin
      visual_0_prs_state <= `STATE_TYPE_IDLE;
      visual_0_dtack_int <= 1'b1;
    end
    else
    begin
      visual_0_prs_state <= next_state;
      visual_0_dtack_int <= dtack_com;
    end
 
  end
 
 
  //   Process:  ADDR_DECODE
  //   Function:  Mapping address from uProc to enable appropriate register
  always @( negedge (reset) or posedge (clk) )
  begin
    if (!reset)
    begin
      visual_0_addr_en <= 1'b0;
      visual_0_cntrl_en <= 1'b0;
      visual_0_stat_en <= 1'b0;
      visual_0_data_en <= 1'b0;
                           //   Synchronize with rising edge of clock
    end
    else
      //   I2C bus is specified by uProc and address is stable
      if (address_match)
        //   Check appropriate register address
        case (addr_bus[7:0])
          `MADR_ADDR :
          begin
            visual_0_addr_en <= 1'b1;
            visual_0_cntrl_en <= 1'b0;
            visual_0_stat_en <= 1'b0;
            visual_0_data_en <= 1'b0;
          end
          `MBCR_ADDR :
          begin
            visual_0_cntrl_en <= 1'b1;
            visual_0_addr_en <= 1'b0;
            visual_0_stat_en <= 1'b0;
            visual_0_data_en <= 1'b0;
          end
          `MBSR_ADDR :
          begin
            visual_0_stat_en <= 1'b1;
            visual_0_addr_en <= 1'b0;
            visual_0_cntrl_en <= 1'b0;
            visual_0_data_en <= 1'b0;
          end
          `MBDR_ADDR :
          begin
            visual_0_data_en <= 1'b1;
            visual_0_addr_en <= 1'b0;
            visual_0_cntrl_en <= 1'b0;
            visual_0_stat_en <= 1'b0;
          end
          default  :
          begin
            visual_0_addr_en <= 1'b0;
            visual_0_cntrl_en <= 1'b0;
            visual_0_stat_en <= 1'b0;
            visual_0_data_en <= 1'b0;
          end
        endcase
 
      else
      begin
        //   this device is not addressed
        visual_0_addr_en <= 1'b0;
        visual_0_cntrl_en <= 1'b0;
        visual_0_stat_en <= 1'b0;
        visual_0_data_en <= 1'b0;
      end
 
 
  end
 
 
  //   Process:  DATA_DIR
  //   Function: Read from or write to appropriate registers specified
  //  	     by uProc address
  always @( posedge (clk) or negedge (reset))
  begin
    //   Initialize all internal registers upon reset
    if (!reset)
    begin
      //   Address Register
      visual_0_madr <= {{8{ 1'b0 }}};
      //   Control Register
      visual_0_men <= 1'b0;
      visual_0_mien <= 1'b0;
      visual_0_msta <= 1'b0;
      visual_0_mtx <= 1'b0;
      visual_0_txak <= 1'b0;
      visual_0_rsta <= 1'b0;
      visual_0_mbcr_wr <= 1'b0;
      //   Status Register
      visual_0_mal_bit_reset <= 1'b0;
      visual_0_mif_bit_reset <= 1'b0;
      //   Data Register
      visual_0_mbdr_micro <= {{8{ 1'b0 }}};
      visual_0_mbdr_read <= 1'b0;
      //   Initialize data bus
      visual_0_data_out <= {{8{ 1'b0 }}};
                           //   Check for rising edge of clock
    end
    else
    begin
      if ((prs_state == `STATE_TYPE_IDLE))
      begin
        //   reset signals that indicate read from mbdr or write to mbcr
        visual_0_mbcr_wr <= 1'b0;
        visual_0_mbdr_read <= 1'b0;
                           //   Check for data transfer state
      end
      else if ((prs_state == `STATE_TYPE_DATA_TRS))
      begin
        //   Address register
        if (addr_en)
          if (!r_w)
            //   uC write
            visual_0_madr <= {data_in[7:1] , 1'b0};
          else
            //   uC read
            visual_0_data_out <= madr;
 
 
        //   Control Register
        if (cntrl_en)
          if (!r_w)
          begin
            //   uC write
            visual_0_mbcr_wr <= 1'b1;
            visual_0_men <= data_in[7];
            visual_0_mien <= data_in[6];
            visual_0_msta <= data_in[5];
            visual_0_mtx <= data_in[4];
            visual_0_txak <= data_in[3];
            visual_0_rsta <= data_in[2];
          end
          else
          begin
            //   uC read
            visual_0_mbcr_wr <= 1'b0;
            visual_0_data_out <= {{{{{{{men , mien} , msta} , mtx} , txak} ,
                                 rsta} , 1'b0} , 1'b0};
          end
 
        else
          visual_0_mbcr_wr <= 1'b0;
 
        //   Status Register
        if (stat_en)
          if (!r_w)
          begin
            //   uC write to these bits generates a reset
            if (!data_in[4])
              visual_0_mal_bit_reset <= 1'b1;
 
            if (!data_in[2])
              visual_0_mif_bit_reset <= 1'b1;
 
          end
          else
          begin
            //   uC read
            visual_0_data_out <= {{{{{{{mcf , maas} , mbb} , mal} , 1'b0} , srw}
                                 , mif} , rxak};
            visual_0_mal_bit_reset <= 1'b0;
            visual_0_mif_bit_reset <= 1'b0;
          end
 
 
        //   Data Register
        if (data_en)
          if (!r_w)
          begin
            //   uC write
            visual_0_mbdr_read <= 1'b0;
            visual_0_mbdr_micro <= data_in;
          end
          else
          begin
            //   uC Read
            visual_0_mbdr_read <= 1'b1;
            visual_0_data_out <= mbdr_i2c;
          end
 
        else
          visual_0_mbdr_read <= 1'b0;
 
      end
 
      //   if arbitration is lost, the I2C Control component will generate a reset for the
      //   MSTA bit to force the design to slave mode
      //   will do this reset synchronously
      if (msta_rst)
        visual_0_msta <= 1'b0;
 
    end
 
  end
 
 
  //   Interrupt signal to uProcessor
  assign irq = ((mien == 1'b1) && (mif == 1'b1) ? 1'b0 : 1'bz);
  //   DTACK signal to uProcession
  assign dtack = ((dtack_oe == 1'b1) ? dtack_int : 1'bz);
  //   Bi-directional Data bus
  assign data_bus = ((r_w == 1'b1 && dtack_oe == 1'b1) ? data_out : {{8{ 1'bz }}
                    });
  assign data_in = (r_w == 1'b0 ? data_bus : {{8{ 1'b0 }}});
 
endmodule


