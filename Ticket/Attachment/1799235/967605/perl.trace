>> await-nested.pl:9: my $N = shift @ARGV // 0;
>> await-nested.pl:11: my $f;
>> await-nested.pl:17: }
>> await-nested.pl:22: }
>> await-nested.pl:24: $f = Future->new;
>> /home/leo/lib/perl5/Future.pm:254:    my $proto = shift;
>> /home/leo/lib/perl5/Future.pm:259:          ( do { my $at = Carp::shortmess( "constructed" );
>> await-nested.pl:26: my $fret = ( $N == 1 ) ? inner() : outer();
>> await-nested.pl:21:    await inner();
>> await-nested.pl:15:    ( $N == 2 ) or await $f;
ENTER await curcv=0x55d5b3889790
>> /home/leo/lib/perl5/Future.pm:499:    my $self = shift;
>> /home/leo/lib/perl5/Future.pm:500:    return $self->{ready};
  UNREADY
>> /home/leo/lib/perl5/Future.pm:761:    my $self = shift;
>> /home/leo/lib/perl5/Future.pm:762:    my ( $code ) = @_;
>> /home/leo/lib/perl5/Future.pm:764:    my $is_future = blessed( $code ) && $code->isa( "Future" );
>> /home/leo/lib/perl5/Future.pm:765:    $is_future or _callable( $code ) or
>> /home/leo/lib/perl5/Future.pm:248:    my ( $cb ) = @_;
>> /home/leo/lib/perl5/Future.pm:249:    defined $cb and ( reftype($cb) eq 'CODE' || overload::Method($cb, '&{}') );
>> /home/leo/lib/perl5/Future.pm:768:    if( $self->{ready} ) {
>> /home/leo/lib/perl5/Future.pm:780:       push @{ $self->{callbacks} }, [ CB_ALWAYS|CB_SELF, $self->wrap_cb( on_ready => $code ) ];
>> /home/leo/lib/perl5/Future.pm:780:       push @{ $self->{callbacks} }, [ CB_ALWAYS|CB_SELF, $self->wrap_cb( on_ready => $code ) ];
>> /home/leo/lib/perl5/Future.pm:2170:    my $self = shift;
>> /home/leo/lib/perl5/Future.pm:2171:    my ( $op, $cb ) = @_;
>> /home/leo/lib/perl5/Future.pm:2172:    return $cb;
>> /home/leo/lib/perl5/Future.pm:783:    return $self;
>> /home/leo/lib/perl5/Future.pm:254:    my $proto = shift;
>> /home/leo/lib/perl5/Future.pm:259:          ( do { my $at = Carp::shortmess( "constructed" );
LEAVE await curcv=0x55d5b3416d40
ENTER await curcv=0x55d5b38a1138
>> /home/leo/lib/perl5/Future.pm:499:    my $self = shift;
>> /home/leo/lib/perl5/Future.pm:500:    return $self->{ready};
  UNREADY
>> /home/leo/lib/perl5/Future.pm:761:    my $self = shift;
>> /home/leo/lib/perl5/Future.pm:762:    my ( $code ) = @_;
>> /home/leo/lib/perl5/Future.pm:764:    my $is_future = blessed( $code ) && $code->isa( "Future" );
>> /home/leo/lib/perl5/Future.pm:765:    $is_future or _callable( $code ) or
>> /home/leo/lib/perl5/Future.pm:248:    my ( $cb ) = @_;
>> /home/leo/lib/perl5/Future.pm:249:    defined $cb and ( reftype($cb) eq 'CODE' || overload::Method($cb, '&{}') );
>> /home/leo/lib/perl5/Future.pm:768:    if( $self->{ready} ) {
>> /home/leo/lib/perl5/Future.pm:780:       push @{ $self->{callbacks} }, [ CB_ALWAYS|CB_SELF, $self->wrap_cb( on_ready => $code ) ];
>> /home/leo/lib/perl5/Future.pm:780:       push @{ $self->{callbacks} }, [ CB_ALWAYS|CB_SELF, $self->wrap_cb( on_ready => $code ) ];
>> /home/leo/lib/perl5/Future.pm:2170:    my $self = shift;
>> /home/leo/lib/perl5/Future.pm:2171:    my ( $op, $cb ) = @_;
>> /home/leo/lib/perl5/Future.pm:2172:    return $cb;
>> /home/leo/lib/perl5/Future.pm:783:    return $self;
>> /home/leo/lib/perl5/Future.pm:254:    my $proto = shift;
>> /home/leo/lib/perl5/Future.pm:259:          ( do { my $at = Carp::shortmess( "constructed" );
LEAVE await curcv=0x55d5b340c438
>> await-nested.pl:28: $f->done( "result" );
>> /home/leo/lib/perl5/Future.pm:593:    my $self = shift;
>> /home/leo/lib/perl5/Future.pm:595:    if( ref $self ) {
>> /home/leo/lib/perl5/Future.pm:596:       $self->{cancelled} and return $self;
>> /home/leo/lib/perl5/Future.pm:597:       $self->{ready} and Carp::croak "${\$self->__selfstr} is already ".$self->state." and cannot be ->done";
>> /home/leo/lib/perl5/Future.pm:598:       $self->{subs} and Carp::croak "${\$self->__selfstr} is not a leaf Future, cannot be ->done";
>> /home/leo/lib/perl5/Future.pm:599:       $self->{result} = [ @_ ];
>> /home/leo/lib/perl5/Future.pm:600:       $self->_mark_ready( "done" );
>> /home/leo/lib/perl5/Future.pm:374:    my $self = shift;
>> /home/leo/lib/perl5/Future.pm:375:    $self->{ready} = 1;
>> /home/leo/lib/perl5/Future.pm:376:    $self->{ready_at} = _shortmess $_[0] if DEBUG;
>> /home/leo/lib/perl5/Future.pm:378:    if( $TIMES ) {
>> /home/leo/lib/perl5/Future.pm:382:    delete $self->{on_cancel};
>> /home/leo/lib/perl5/Future.pm:383:    my $callbacks = delete $self->{callbacks} or return;
>> /home/leo/lib/perl5/Future.pm:385:    my $cancelled = $self->{cancelled};
>> /home/leo/lib/perl5/Future.pm:386:    my $fail      = defined $self->{failure};
>> /home/leo/lib/perl5/Future.pm:387:    my $done      = !$fail && !$cancelled;
>> /home/leo/lib/perl5/Future.pm:389:    my @result  = $done ? $self->get :
>> /home/leo/lib/perl5/Future.pm:817:    my $self = shift;
>> /home/leo/lib/perl5/Future.pm:818:    until( $self->{ready} ) { $self->await }
>> /home/leo/lib/perl5/Future.pm:819:    if( $self->{failure} ) {
>> /home/leo/lib/perl5/Future.pm:824:    $self->{cancelled} and Carp::croak "${\$self->__selfstr} was cancelled";
>> /home/leo/lib/perl5/Future.pm:825:    return $self->{result}->[0] unless wantarray;
>> /home/leo/lib/perl5/Future.pm:826:    return @{ $self->{result} };
>> /home/leo/lib/perl5/Future.pm:826:    return @{ $self->{result} };
>> /home/leo/lib/perl5/Future.pm:393:    foreach my $cb ( @$callbacks ) {
>> /home/leo/lib/perl5/Future.pm:394:       my ( $flags, $code ) = @$cb;
>> /home/leo/lib/perl5/Future.pm:395:       my $is_future = blessed( $code ) && $code->isa( "Future" );
>> /home/leo/lib/perl5/Future.pm:397:       next if $done      and not( $flags & CB_DONE );
>> /home/leo/lib/perl5/Future.pm:398:       next if $fail      and not( $flags & CB_FAIL );
>> /home/leo/lib/perl5/Future.pm:399:       next if $cancelled and not( $flags & CB_CANCEL );
>> /home/leo/lib/perl5/Future.pm:401:       $self->{reported} = 1 if $fail;
>> /home/leo/lib/perl5/Future.pm:403:       if( $is_future ) {
>> /home/leo/lib/perl5/Future.pm:462:          $code->(
ENTER await curcv=0x55d5b3416d40
  RESUME
>> /home/leo/lib/perl5/Future.pm:499:    my $self = shift;
>> /home/leo/lib/perl5/Future.pm:500:    return $self->{ready};
  READY
>> /home/leo/lib/perl5/Future.pm:817:    my $self = shift;
>> /home/leo/lib/perl5/Future.pm:818:    until( $self->{ready} ) { $self->await }
>> /home/leo/lib/perl5/Future.pm:819:    if( $self->{failure} ) {
>> /home/leo/lib/perl5/Future.pm:824:    $self->{cancelled} and Carp::croak "${\$self->__selfstr} was cancelled";
>> /home/leo/lib/perl5/Future.pm:825:    return $self->{result}->[0] unless wantarray;
LEAVE await curcv=0x55d5b3416d40
>> await-nested.pl:16:    die "Oopsie\n";
>> /home/leo/lib/perl5/Future.pm:640:    my $self = shift;
>> /home/leo/lib/perl5/Future.pm:641:    my ( $exception, @details ) = @_;
>> /home/leo/lib/perl5/Future.pm:643:    $_[0] or Carp::croak "$self ->fail requires an exception that is true";
>> /home/leo/lib/perl5/Future.pm:645:    if( ref $self ) {
>> /home/leo/lib/perl5/Future.pm:646:       $self->{cancelled} and return $self;
>> /home/leo/lib/perl5/Future.pm:647:       $self->{ready} and Carp::croak "${\$self->__selfstr} is already ".$self->state." and cannot be ->fail'ed";
>> /home/leo/lib/perl5/Future.pm:648:       $self->{subs} and Carp::croak "${\$self->__selfstr} is not a leaf Future, cannot be ->fail'ed";
>> /home/leo/lib/perl5/Future.pm:649:       $self->{failure} = [ $exception, @details ];
>> /home/leo/lib/perl5/Future.pm:650:       $self->_mark_ready( "failed" );
>> /home/leo/lib/perl5/Future.pm:374:    my $self = shift;
>> /home/leo/lib/perl5/Future.pm:375:    $self->{ready} = 1;
>> /home/leo/lib/perl5/Future.pm:376:    $self->{ready_at} = _shortmess $_[0] if DEBUG;
>> /home/leo/lib/perl5/Future.pm:378:    if( $TIMES ) {
>> /home/leo/lib/perl5/Future.pm:382:    delete $self->{on_cancel};
>> /home/leo/lib/perl5/Future.pm:383:    my $callbacks = delete $self->{callbacks} or return;
>> /home/leo/lib/perl5/Future.pm:385:    my $cancelled = $self->{cancelled};
>> /home/leo/lib/perl5/Future.pm:386:    my $fail      = defined $self->{failure};
>> /home/leo/lib/perl5/Future.pm:387:    my $done      = !$fail && !$cancelled;
>> /home/leo/lib/perl5/Future.pm:389:    my @result  = $done ? $self->get :
>> /home/leo/lib/perl5/Future.pm:935:    my $self = shift;
>> /home/leo/lib/perl5/Future.pm:936:    until( $self->{ready} ) { $self->await }
>> /home/leo/lib/perl5/Future.pm:937:    return unless $self->{failure};
>> /home/leo/lib/perl5/Future.pm:938:    $self->{reported} = 1;
>> /home/leo/lib/perl5/Future.pm:939:    return $self->{failure}->[0] if !wantarray;
>> /home/leo/lib/perl5/Future.pm:940:    return @{ $self->{failure} };
>> /home/leo/lib/perl5/Future.pm:940:    return @{ $self->{failure} };
>> /home/leo/lib/perl5/Future.pm:393:    foreach my $cb ( @$callbacks ) {
>> /home/leo/lib/perl5/Future.pm:394:       my ( $flags, $code ) = @$cb;
>> /home/leo/lib/perl5/Future.pm:395:       my $is_future = blessed( $code ) && $code->isa( "Future" );
>> /home/leo/lib/perl5/Future.pm:397:       next if $done      and not( $flags & CB_DONE );
>> /home/leo/lib/perl5/Future.pm:398:       next if $fail      and not( $flags & CB_FAIL );
>> /home/leo/lib/perl5/Future.pm:399:       next if $cancelled and not( $flags & CB_CANCEL );
>> /home/leo/lib/perl5/Future.pm:401:       $self->{reported} = 1 if $fail;
>> /home/leo/lib/perl5/Future.pm:403:       if( $is_future ) {
>> /home/leo/lib/perl5/Future.pm:462:          $code->(
ENTER await curcv=0x55d5b340c438
  RESUME
>> /home/leo/lib/perl5/Future.pm:499:    my $self = shift;
>> /home/leo/lib/perl5/Future.pm:500:    return $self->{ready};
  READY
>> /home/leo/lib/perl5/Future.pm:817:    my $self = shift;
>> /home/leo/lib/perl5/Future.pm:818:    until( $self->{ready} ) { $self->await }
>> /home/leo/lib/perl5/Future.pm:819:    if( $self->{failure} ) {
>> /home/leo/lib/perl5/Future.pm:820:       $self->{reported} = 1;
>> /home/leo/lib/perl5/Future.pm:821:       my $exception = $self->{failure}->[0];
>> /home/leo/lib/perl5/Future.pm:822:       !ref $exception && $exception =~ m/\n$/ ? CORE::die $exception : Carp::croak $exception;
>> /home/leo/lib/perl5/Future.pm:640:    my $self = shift;
>> /home/leo/lib/perl5/Future.pm:641:    my ( $exception, @details ) = @_;
>> /home/leo/lib/perl5/Future.pm:643:    $_[0] or Carp::croak "$self ->fail requires an exception that is true";
>> /home/leo/lib/perl5/Future.pm:645:    if( ref $self ) {
>> /home/leo/lib/perl5/Future.pm:646:       $self->{cancelled} and return $self;
>> /home/leo/lib/perl5/Future.pm:647:       $self->{ready} and Carp::croak "${\$self->__selfstr} is already ".$self->state." and cannot be ->fail'ed";
>> /home/leo/lib/perl5/Future.pm:648:       $self->{subs} and Carp::croak "${\$self->__selfstr} is not a leaf Future, cannot be ->fail'ed";
>> /home/leo/lib/perl5/Future.pm:649:       $self->{failure} = [ $exception, @details ];
>> /home/leo/lib/perl5/Future.pm:650:       $self->_mark_ready( "failed" );
>> /home/leo/lib/perl5/Future.pm:374:    my $self = shift;
>> /home/leo/lib/perl5/Future.pm:375:    $self->{ready} = 1;
>> /home/leo/lib/perl5/Future.pm:376:    $self->{ready_at} = _shortmess $_[0] if DEBUG;
>> /home/leo/lib/perl5/Future.pm:378:    if( $TIMES ) {
>> /home/leo/lib/perl5/Future.pm:382:    delete $self->{on_cancel};
>> /home/leo/lib/perl5/Future.pm:383:    my $callbacks = delete $self->{callbacks} or return;
>> /home/leo/lib/perl5/Future.pm:385:    my $cancelled = $self->{cancelled};
>> /home/leo/lib/perl5/Future.pm:386:    my $fail      = defined $self->{failure};
>> /home/leo/lib/perl5/Future.pm:387:    my $done      = !$fail && !$cancelled;
>> /home/leo/lib/perl5/Future.pm:389:    my @result  = $done ? $self->get :
>> /home/leo/lib/perl5/Future.pm:935:    my $self = shift;
>> /home/leo/lib/perl5/Future.pm:936:    until( $self->{ready} ) { $self->await }
>> /home/leo/lib/perl5/Future.pm:937:    return unless $self->{failure};
>> /home/leo/lib/perl5/Future.pm:938:    $self->{reported} = 1;
>> /home/leo/lib/perl5/Future.pm:939:    return $self->{failure}->[0] if !wantarray;
>> /home/leo/lib/perl5/Future.pm:940:    return @{ $self->{failure} };
>> /home/leo/lib/perl5/Future.pm:940:    return @{ $self->{failure} };
>> /home/leo/lib/perl5/Future.pm:393:    foreach my $cb ( @$callbacks ) {
>> /home/leo/lib/perl5/Future.pm:659:    return $self;
LEAVEASYNC
>> /home/leo/lib/perl5/Future.pm:659:    return $self;
>> /home/leo/lib/perl5/Future.pm:270: END { $GLOBAL_END = 1; }
