--- a/MPFR.xs
+++ b/MPFR.xs
@@ -5836,7 +5836,7 @@
     croak("2nd arg to Math::MPFR::_d_bytes_fr must be 53");
 
   if(mpfr_get_prec(*str) != 53)
-    croak("Precison of 1st arg supplied to _d_bytes_fr must be 53, not %u", mpfr_get_prec(*str));
+    croak("Precision of 1st arg supplied to _d_bytes_fr must be 53, not %u", mpfr_get_prec(*str));
 
   if((size_t)bits != DBL_MANT_DIG)
     croak("2nd arg (%u) supplied to Math::MPFR::_d_bytes_fr does not match DBL_MANT_DIG (%u)", bits, DBL_MANT_DIG);
@@ -5937,7 +5937,7 @@
     croak("2nd arg to Math::MPFR::_dd_bytes must be 106");
 
   if(mpfr_get_prec(*str) != 2098)
-    croak("Precison of 1st arg supplied to _dd_bytes_fr must be 2098, not %u", mpfr_get_prec(*str));
+    croak("Precision of 1st arg supplied to _dd_bytes_fr must be 2098, not %u", mpfr_get_prec(*str));
 
   mpfr_init2(temp, 2098);
 
@@ -6049,7 +6049,7 @@
   }
 
   if(mpfr_get_prec(*str) != bits)
-    croak("Precison of 1st arg (%u) supplied to _ld_bytes_fr must match 2nd arg (%d)", mpfr_get_prec(*str), bits);
+    croak("Precision of 1st arg (%u) supplied to _ld_bytes_fr must match 2nd arg (%d)", mpfr_get_prec(*str), bits);
 
   if((size_t)bits != LDBL_MANT_DIG)
     croak("2nd arg (%u) supplied to Math::MPFR::_ld_bytes_fr does not match LDBL_MANT_DIG (%u)", bits, LDBL_MANT_DIG);
@@ -6155,7 +6155,7 @@
     croak("2nd arg to Math::MPFR::_f128_bytes_fr must be 113");
 
   if(mpfr_get_prec(*str) != 113)
-    croak("Precison of 1st arg supplied to _f128_bytes_fr must be 113, not %u", mpfr_get_prec(*str));
+    croak("Precision of 1st arg supplied to _f128_bytes_fr must be 113, not %u", mpfr_get_prec(*str));
 
   if((size_t)bits != FLT128_MANT_DIG)
     croak("2nd arg (%u) supplied to Math::MPFR::_f128_bytes_fr does not match FLT128_MANT_DIG (%u)", bits, FLT128_MANT_DIG);
--- a/t/bytes.t
+++ b/t/bytes.t
@@ -277,7 +277,7 @@
 
 eval {Math::MPFR::_d_bytes_fr($fr_breaker, 53);};
 
-if($@ =~ /^Precison of 1st arg supplied to _d_bytes_fr must be 53, not 200/) {print "ok 14\n"}
+if($@ =~ /^Precision of 1st arg supplied to _d_bytes_fr must be 53, not 200/) {print "ok 14\n"}
 else {
   warn "\$\@: $@\n";
   print "not ok 14\n";
@@ -285,7 +285,7 @@
 
 eval {Math::MPFR::_dd_bytes_fr($fr_breaker, 106);};
 
-if($@ =~ /^Precison of 1st arg supplied to _dd_bytes_fr must be 2098, not 200/) {print "ok 15\n"}
+if($@ =~ /^Precision of 1st arg supplied to _dd_bytes_fr must be 2098, not 200/) {print "ok 15\n"}
 else {
   warn "\$\@: $@\n";
   print "not ok 15\n";
@@ -294,7 +294,7 @@
 eval {Math::MPFR::_ld_bytes_fr($fr_breaker, 64);};
 
 
-if($@ =~ /^Precison of 1st arg \(200\) supplied to _ld_bytes_fr must match 2nd arg \(64\)/) {print "ok 16\n"}
+if($@ =~ /^Precision of 1st arg \(200\) supplied to _ld_bytes_fr must match 2nd arg \(64\)/) {print "ok 16\n"}
 else {
   warn "\$\@: $@\n";
   print "not ok 16\n";
@@ -302,7 +302,7 @@
 
 eval {Math::MPFR::_f128_bytes_fr($fr_breaker, 113);};
 
-if($@ =~ /^Precison of 1st arg supplied to _f128_bytes_fr must be 113, not 200/ ||
+if($@ =~ /^Precision of 1st arg supplied to _f128_bytes_fr must be 113, not 200/ ||
    $@ =~ /^__float128 support not built into this Math::MPFR/) {print "ok 17\n"}
 else {
   warn "\$\@: $@\n";
@@ -377,7 +377,7 @@
 
 eval{$h = Math::MPFR::bytes($d_fr, 'Long Double');};
 
-if($@ =~ /^Precison of 1st arg \(53\) supplied to _ld_bytes_fr must match 2nd arg \(64\)/) {print "ok 22\n"}
+if($@ =~ /^Precision of 1st arg \(53\) supplied to _ld_bytes_fr must match 2nd arg \(64\)/) {print "ok 22\n"}
 else {
   warn "\$\@: $@";
   print "not ok 22\n";
--- a/MPFR.pm
+++ b/MPFR.pm
@@ -1094,7 +1094,7 @@
     the entire string is a valid number in base $base. otherwise
     it returns -1.
     If -1 is returned:
-      1) the non-numeric flag (which was initalised to 0) will be
+      1) the non-numeric flag (which was initialised to 0) will be
          incremented. You can query/clear/reset the value of the
          flag with (resp.) nnumflag()/clear_nnum()/set_nnum() - all
          of which are documented below (in "MISCELLANEOUS");
@@ -1258,7 +1258,7 @@
     rounded to direction $rnd. If $str was a valid number, then
     $si will be set to 0. Else it will be set to -1.
     If $si is -1 :
-      1) the non-numeric flag (which was initalised to 0) will be
+      1) the non-numeric flag (which was initialised to 0) will be
          incremented. You can query/clear/reset the value of the
          flag with (resp.) nnumflag()/clear_nnum()/set_nnum() - all
          of which are documented below (in "MISCELLANEOUS");
@@ -1949,7 +1949,7 @@
     Return the number of bytes read, or if non-numeric characters were
     encountered in the input, return 0.
     If 0 is returned:
-      1) the non-numeric flag (which was initalised to 0) will be
+      1) the non-numeric flag (which was initialised to 0) will be
          incremented. You can query/clear/reset the value of the
          flag with (resp.) nnumflag()/clear_nnum()/set_nnum() - all
          of which are documented below;
@@ -2785,7 +2785,7 @@
    which will set $max_len to 15.
 
    That is, so long as your base 10 float consists of no more than 15
-   siginificant digits, you can pass it to a 53-bit double and back again,
+   significant digits, you can pass it to a 53-bit double and back again,
    and be assured of retrieving the original value.
    (Again, we assume absence of bugs and correct rounding practice.)
 
