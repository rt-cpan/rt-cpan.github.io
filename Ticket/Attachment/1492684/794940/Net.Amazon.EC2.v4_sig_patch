--- Net/Amazon/EC2.pm.orig	2013-12-09 04:44:12.000000000 +0000
+++ Net/Amazon/EC2.pm	2015-03-04 03:42:57.822078084 +0000
@@ -7,13 +7,14 @@
 use XML::Simple;
 use LWP::UserAgent;
 use LWP::Protocol::https;
-use Digest::SHA qw(hmac_sha256);
+use Digest::SHA qw(hmac_sha256 hmac_sha256_hex sha256_hex);
 use URI;
-use MIME::Base64 qw(encode_base64 decode_base64);
+use MIME::Base64 qw(decode_base64);
 use POSIX qw(strftime);
 use Params::Validate qw(validate SCALAR ARRAYREF HASHREF);
 use Data::Dumper qw(Dumper);
 use URI::Escape qw(uri_escape_utf8);
+use Encode qw(encode_utf8);
 use Carp;
 
 use Net::Amazon::EC2::DescribeImagesResponse;
@@ -181,7 +182,6 @@
 			     }
 );
 has 'debug'				=> ( is => 'ro', isa => 'Str', required => 0, default => 0 );
-has 'signature_version'	=> ( is => 'ro', isa => 'Int', required => 1, default => 2 );
 has 'version'			=> ( is => 'ro', isa => 'Str', required => 1, default => '2012-07-20' );
 has 'region'			=> ( is => 'ro', isa => 'Str', required => 1, default => 'us-east-1' );
 has 'ssl'				=> ( is => 'ro', isa => 'Bool', required => 1, default => 1 );
@@ -192,7 +192,7 @@
 	required	=> 1,
 	lazy		=> 1,
 	default		=> sub {
-		return 'http' . ($_[0]->ssl ? 's' : '') . '://' . $_[0]->region . '.ec2.amazonaws.com';
+		return 'http' . ($_[0]->ssl ? 's' : '') . '://ec2.' . $_[0]->region . '.amazonaws.com';
 	}
 );
 has 'temp_creds'       => ( is => 'ro',
@@ -248,45 +248,75 @@
 sub _sign {
 	my $self						= shift;
 	my %args						= @_;
-	my $action						= delete $args{Action};
-	my %sign_hash					= %args;
-	my $timestamp					= $self->timestamp;
-
-	$sign_hash{AWSAccessKeyId}		= $self->AWSAccessKeyId;
-	$sign_hash{Action}				= $action;
-	$sign_hash{Timestamp}			= $timestamp;
-	$sign_hash{Version}				= $self->version;
-	$sign_hash{SignatureVersion}	= $self->signature_version;
-    $sign_hash{SignatureMethod}     = "HmacSHA256";
-	if ($self->has_temp_creds) {
-	    $sign_hash{SecurityToken} = $self->temp_creds->{'Token'};
-	}
 
+	my $algorithm					= "AWS4-HMAC-SHA256";
+	my $service						= "ec2";
 
-	my $sign_this = "POST\n";
-	my $uri = URI->new($self->base_url);
+	my @now							= gmtime();
+	my $amz_date					= strftime("%Y%m%dT%H%M%SZ", @now);
+	my $datestamp					= strftime("%Y%m%d", @now);
+	my $credential_scope 			= $datestamp . "/" . $self->region . "/" . $service . "/aws4_request";
 
-    $sign_this .= lc($uri->host) . "\n";
-    $sign_this .= "/\n";
+	my $content_type				= "application/x-www-form-urlencoded";
+	my $signed_headers				= "content-type;host;x-amz-date";
 
-    my @signing_elements;
-
-	foreach my $key (sort keys %sign_hash) {
-		push @signing_elements, uri_escape_utf8($key)."=".uri_escape_utf8($sign_hash{$key});
+	# Assemble the content
+	$args{Version} = $self->version;
+	if ($self->has_temp_creds) {
+		$args{'X-Amz-Security-Token'} = $self->temp_creds->{'Token'};
 	}
 
-    $sign_this .= join "&", @signing_elements;
-
-	$self->_debug("QUERY TO SIGN: $sign_this");
-	my $encoded = $self->_hashit($self->SecretAccessKey, $sign_this);
+	my @content_elements;
+    foreach my $key (sort keys %args) {
+    	push @content_elements, uri_escape_utf8($key)."=".uri_escape_utf8($args{$key});
+    }
+    my $content .= join "&", @content_elements;
 
-    my $content = join "&", @signing_elements, 'Signature=' . uri_escape_utf8($encoded);
+	# Step 1: create canonical request string
+	my $uri = URI->new($self->base_url);
+	my $canonical_headers = "content-type:" . $content_type . "\n" .
+							"host:" . lc($uri->host) . "\n" .
+							"x-amz-date:" . $amz_date . "\n";
+
+	my $canonical_request = "POST\n";				# method
+	$canonical_request .= "/\n";					# uri
+	$canonical_request .= "\n";						# query-string
+	$canonical_request .= $canonical_headers . "\n";# headers
+	$canonical_request .= $signed_headers . "\n";	# signed headers
+	$canonical_request .= sha256_hex($content);		# payload
+
+	# Step 2: create string to sign
+	my $sign_this = $algorithm . "\n";
+	$sign_this .= $amz_date . "\n";
+	$sign_this .= $credential_scope . "\n";
+	$sign_this .= sha256_hex($canonical_request);
+
+	$self->_debug("STRING TO SIGN: $sign_this");
+
+	# Step 3: calculate the signature
+	my $key_date = $self->_hmac(encode_utf8('AWS4' . $self->SecretAccessKey), $datestamp);
+	my $key_region = $self->_hmac($key_date, $self->region);
+	my $key_service = $self->_hmac($key_region, $service);
+	my $signing_key = $self->_hmac($key_service, 'aws4_request');
+
+	my $signature = $self->_hmac($signing_key, encode_utf8($sign_this), 1);
+
+	# send request
+	my $auth_header = $algorithm .
+					  ' Credential=' . $self->AWSAccessKeyId . '/' . $credential_scope .
+					  ', SignedHeaders=' . $signed_headers .
+					  ', Signature=' . $signature;
 
 	my $ur	= $uri->as_string();
 	$self->_debug("GENERATED QUERY URL: $ur");
 	my $ua	= LWP::UserAgent->new();
     $ua->env_proxy;
-	my $res	= $ua->post($ur, Content => $content);
+	my $res	= $ua->post($ur,
+			"Authorization" => $auth_header,
+			"Content-Type" => $content_type,
+			"X-Amz-Date" => $amz_date,
+			Content => $content);
+
 	# We should force <item> elements to be in an array
 	my $xs	= XML::Simple->new(
         ForceArray => qr/(?:item|Errors)/i, # Always want item elements unpacked to arrays
@@ -368,12 +398,11 @@
 	}
 }
 
-# HMAC sign the query with the aws secret access key and base64 encodes the result.
-sub _hashit {
-	my $self								= shift;
-	my ($secret_access_key, $query_string)	= @_;
-	
-	return encode_base64(hmac_sha256($query_string, $secret_access_key), '');
+sub _hmac {
+	my $self				= shift;
+	my ($key, $msg, $hex) 	= @_;
+	my $func = $hex ? \&hmac_sha256_hex : \&hmac_sha256;
+	return &$func(encode_utf8($msg), $key);
 }
 
 sub _build_filters {
